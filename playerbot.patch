-f12ff28c81640c77bd76dee63bb2232a51633fca
+2cd6ee393209ca709d34880e75fd2f483d468013
diff -ruN mangos-classic/bot_readme.txt portalclassic/bot_readme.txt
--- mangos-classic/bot_readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/bot_readme.txt	2016-06-20 09:28:56.000000000 +0200
@@ -0,0 +1,231 @@
+What it is:
+===========
+
+Playerbot lets you add another character from your account as a bot that you can control and which will hopefully help you. Only characters from your account can be used, so you can have a maximum of 9 bots at one time.
+
+This was taken from the Trinity site, and modified slightly by me to get some of the kinks out. I reworked the priest class and also added a mage class and a warrior class, which are still in crude form. Any class can be used as a bot - just don't expect much in the way of spells or abilities until someone writes the code for them.
+
+Bots will only use abilities that they have - for example, a priest will only use the renew spell if it has been trained. Also, bot's equipment will lose durability like any other character. So every so often you'll need to log in and repair and train your bot.
+
+For MaNGOS 10816+
+
+Commands:
+=========
+
+/s .bot add BOTNAME (add character to world)
+/s .bot remove BOTNAME (remove character from world)
+/s .bot co|combatorder BOTNAME COMBATORDER [TARGET] (TANK | ASSIST | PROTECT | HEAL)
+/invite BOTNAME (bot will auto accept invite)
+/uninvite BOTNAME (bot will auto accept uninvite)
+/t BOTNAME attack (bot will attack selected target, similar to the way a pet can attack)
+/t BOTNAME follow (orders bot to follow player; will also revive bot if dead or teleport bot if far away)
+/t BOTNAME stay (orders bot to not follow player and stand still)
+/t BOTNAME spells (replies with all spells known to bot)
+/t BOTNAME cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME use [ITEM LINK] (use a specified item i.e quest item, food or drink etc..)
+/t BOTNAME equip [ITEM LINK] (equip a specified item i.e. weapon, armour, bag etc..)
+/t BOTNAME reset (will reset states, orders and loot list)
+/t BOTNAME report (bot reports all items, creatures or gameobjects needed to finish quests)
+/t BOTNAME stats (bot shows available money, free inventory space and estimated item repair costs)
+/t BOTNAME survey (bot shows all available gameobjects, within a local perimeter around the bot)
+/t BOTNAME find [GAMEOBJECT LINK] (bot will travel to the gameobject location and then wait)
+/t BOTNAME get [GAMEOBJECT LINK] (bot will fetch the selected gameobject and then return to the player)
+/t BOTNAME quest (Shows bot's current quests)
+/t BOTNAME quest <(a)dd> [QUESTLINK] (Adds a quest)
+/t BOTNAME quest <(d)rop> [QUESTLINK] (Drop a quest)
+/t BOTNAME quest <(e)nd> (Turns in a completed quest)
+/t BOTNAME quest <(l)ist> (Shows new quests offered by questgiver)
+/t BOTNAME orders (Shows bot's combat orders)
+/t BOTNAME pet spells (Shows spells known to bot's pet. Autocast spells will be shown in green)
+/t BOTNAME pet cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME pet toggle <SPELLID | (part of) SPELLNAME | [SPELLLINK]> (Toggle autocast for a given spell)
+/t BOTNAME pet state (Shows current react mode of bot's pet)
+/t BOTNAME pet react <(a)ggressive | (d)efensive | (p)assive> (Set bot's pet reaction mode)
+/t BOTNAME collect (shows collect subcommand options and current collect status)
+/t BOTNAME collect <subcommand(s)> (subcommands can be alone or together [none combat loot objects profession quest])
+/t BOTNAME sell [ITEM LINK] (bot will add item to it's m_itemIds, for later sale)
+/t BOTNAME auction (bot will display all it's active owned auctions. Auction info will include an [AUCTION LINK] )
+/t BOTNAME auction add [ITEM LINK] (bot will add item to it's m_itemIds, for later auction)
+/t BOTNAME auction remove [AUCTION LINK] (bot will add auctionid to it's m_auctions, for later auction cancellation)
+/t BOTNAME repair [ITEM LINK] (bot will seek out armourer and repair selected items specified by [ITEM LINK] )
+/t BOTNAME repair all (bot(s) will seek out armourer and repair all damaged items equipped, or in bags )
+/t BOTNAME bank  (Lists bot(s) bank balance)
+/t BOTNAME bank deposit [Item Link][Item Link] .. (Deposit item(s) in bank)
+/t BOTNAME bank withdraw [Item Link][Item Link] ..  (Withdraw item(s) from bank. ([Item Link] from bank))
+/t BOTNAME skill (lists all [PROFESSION LINK] bot Primary profession skills)
+/t BOTNAME skill train (lists [TRAINING LINK] available class, weapon & profession (Primary or Secondary) skills & spells, from selected trainer)
+/t BOTANME skill learn [TRAINING LINK] (learn selected skill or spell, from selected trainer)
+/t BOTNAME skill unlearn [PROFESSION LINK] (unlearn selected primary profession skill & all associated spells)
+
+Shortcuts:
+c = cast
+e = equip
+f = find
+g = get
+s = sell
+
+Gameobject interaction with bots:
+=================================
+
+  The bot(s) can interact with gameobjects. This is particularly useful, in order to complete 'gather' type
+  quests (e.g Milly's harvest in Northshire). The bot(s) can also harvest 'ore deposits' and 'herbs'
+
+  Four commands have been introduced 'collect', 'survey, 'find' & 'get', to facilitate this feature.
+
+  The 'collect' command provides a way to have a bot automatically get loot or objects in the world.
+  The command by itself gives you a display of what settings the bots have. Defaults are stored in
+  the playerbot.conf. The subcommands do the actual work:
+    combat - bot will loot after combat for the options that are set
+    loot - bot will grab all loot available from corpse
+    quest - bot will grab all quest items on corpse
+    profession - bot will grab any profession related item that the bot has from corpse
+    skin - if you have skinning, and corpse has been looted, bot will skin corpse. Most of
+        the time you may want this option and the loot option enabled, but if you are grabbing
+        the stuff as you are going around, the bot will skin afterwards.
+    objects - bot will collect things that are specified by the survey and get <shift-click> commands
+    none - removes any collect options that have been set
+
+  The 'survey' command provides the means for bot(s) to detect gameobjects in the world. It can be used to detect
+  available gameobjects local to a single bot, or more effectively (wider area) those for a party of bots.
+
+  Suggestion: setup the 'survey' command as an assigned macro button, on the client (e.g /p survey). You can
+  then quickly refresh the gameobject list.
+
+  Gameobject list [GAMEOBJECT LINK] (Currently bots can only interact with ore, herb and needed quest items)
+  ---------------
+
+  [Copper Vein][Silverleaf][Earthroot][Milly's Harvest][Battered Chest][Food Crate]
+
+  Then, use the 'find' or 'get' commands to interect with the gameobject.
+
+  Using the gameobject list information, it is possible to locate and/or fetch each of the gameobjects. To select
+  a [GAMEOBJECT LINK], hold down the shift key and click on the relevant link with your mouse.
+
+Creature interaction with bots:
+===============================
+
+  The bot(s) can now interact directly with creatures. This will enable bot(s) to independently contact NPCs, without
+  the need for player's selection. This opens up new possiblities for bot/NPC commerce.
+
+  Each bot will maintain it's own item list (m_itemIds - This is a list of paired data). The first component (UNIT_NPC_FLAG)
+  dictates what is to done with the second component (itemid).
+
+  Each bot will also maintain it's own active auction list (m_auctions - This is a list of paired data). The first component
+  (ActionFlags) dictates the action to be performed on the second component (auctionid).
+
+  While(m_itemIds not empty)
+  {
+      bot will scan for surrounding creatures (findNearbyCreature()) who can service m_itemIds
+      if(found)
+          Search is carried out for all itemids that can be processed by this creature.
+          if(processed successfully)
+              This instance of the data pair (npcflag,itemid) will be removed from m_itemIds
+              While(m_auctions not empty)
+                  process contained auctionids according to ActionFlag & then update m_auctions
+  }
+
+  Please note that bot(s) m_itemIds & m_auctions will be emptied, when bot(s) are dismissed.
+
+Repair with bots:
+=================
+
+  bot(s) can now repair <all or selected> items, either equipped or in bags. If the bot(s) is a member of a guild, then they pay
+  else the bot(s) pays. If the bot(s) cannot pay for the repair, they remain damaged.
+
+  The new 'stats' command provides useful information to help in the repair decision.
+
+  First:  Money available to bot(s)
+  Second: Free inventory slots for bot(s)
+  Third:  Estimated (excludes NPC reputation discount) item damage cost for bot(s).
+
+Combat Orders explained:
+========================
+
+  There are primary and secondary commands which can be combined. In this way it is
+  possible to define a bot to assist the main tank and also protect the healer, making
+  combat management much easier.
+  The commands assist and protect require a target parameter or a friendly player
+  selected by bots master.
+  Available Combat Orders:
+    tank        pri     try to bind all targets involved in combat by gaining highest threat
+    assist      pri     do damage on selected targets attacker without getting highest threat
+    heal        pri     concentrate on healing - no offensive spells, try to keep threat low
+    protect     sec     if target of protect get's directly attacked gain higher threat on attacker
+    reset       -       clear out assist and protect targets and set combat order to nothing
+  Examples:
+    .bot co TheTank tank
+    .bot co MyHealer heal
+    .bot co TheBrutal assist TheTank
+    .bot co TheBrutal protect MyHealer
+
+Trading with bots:
+==================
+
+To trade items/money with your bot simply initiate a trade and the bot will tell you how much money and items are available. To request an item simple whisper the bot and shift click the link of the item you would like. You can link multiple items on the same line. You can also request money in the following manner when the trade window is open:
+/w BOTNAME 10g <-- request that the bot give you 10 gold
+/w BOTNAME 6g500s25c <-- request 6 gold, 500 silver, and 25 cooper
+
+A bot is also able to show an item in its 'Will not be traded' slot. The item can be either
+in its bags or be equipped and even be soulbound. By this you can cast spells/enchantments
+on soulbound items ('nt' stands for 'not trading').
+/w BOTNAME nt [Powerful Soulbound Item]
+
+More Information:
+=================
+
+If specifying a spell substring, the spell chosen will be in priority of exact name match, highest spell rank, and spell using no reagents. Case does not matter. Here's some examples:
+/t BOTNAME c greater heal
+/t BOTNAME cast pain
+/w BOTNAME c poly
+/w BOTNAME cast fort
+/t BOTNAME cast <SPELLID>
+- OR -
+/w BOTNAME c <SPELLID>
+
+Also all commands can be broadcast to the party. For example:
+/p follow
+/p spells
+
+To use or equip items for your bot say:
+/w BOTNAME use [ITEMLINK1][ITEMLINK2]
+/w BOTNAME equip [ITEMLINK1][ITEMLINK2]
+- OR -
+/w BOTNAME u [ITEMLINK1][ITEMLINK2]
+/w BOTNAME e [ITEMLINK1] [ITEMLINK2]
+
+If you inspect your bot, your bot will tell you what items you have in your inventory that you can equip. To create a link in the chat window, hold the shift key and press the left mouse button when clicking the link.
+
+
+Changes from Trinity to Mangos:
+===============================
+
+I added the following in SharedDefines.h.
+
+enum SpellCategory
+{
+	SPELL_CATEGORY_FOOD             = 11,
+	SPELL_CATEGORY_DRINK            = 59
+};
+
+I also had to add the following to Player.h:
+
+enum PlayerStateType
+{
+	PLAYER_STATE_NONE              = 0,
+	PLAYER_STATE_SIT               = 1
+};
+
+
+Configuration variables:
+========================
+Also see src/mangosd/mangosd.conf.dist for configuration variables!
+
+    PlayerbotAI.DebugWhisper
+        Enable debug output by whispering master
+        Default: 0 - off
+                 1 - on
+
+    PlayerbotAI.FollowDistanceMin
+    PlayerbotAI.FollowDistanceMax
+        Min. and max. follow distance for bots
+        Default: 0.5 / 1.0
diff -ruN mangos-classic/bot_todo.txt portalclassic/bot_todo.txt
--- mangos-classic/bot_todo.txt	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/bot_todo.txt	2016-06-20 09:28:56.000000000 +0200
@@ -0,0 +1,29 @@
+[DONE] ///---Quest---///
+[DONE] Bot can accept quest.
+[DONE] Bot can join quest.
+
+[DONE] ///---Loot---///
+[DONE] Bot can loot.
+[DONE] Bot can loot --- maybe only needed q item.
+
+//---Instance teleport Problems---///
+[DONE] Needs some fix.
+
+///---Combat and Movement Orders---///
+[DONE] Movement orders (stay, follow)
+[DONE] Combat orders (protect, assist)
+Combat order TANK
+Combat order HEAL
+
+///---Temporary item enchantments---///
+[DONE] Rogue	: Poison
+Warrior	: Sharpening Stone, Rune of Warding, Rune of Shielding.
+
+//---After fear bot's lose target---///
+Needs some fix.
+
+///---Move behind target---///
+[DONE] Rogue	: some abilitys require Rogue to be stealthed and behind target.
+
+///---Implement locale independet way of getting spellIDs---///
+[DONE] Hardcode lowest rank spellID, use function to get highest rank
diff -ruN mangos-classic/botguy_readme.txt portalclassic/botguy_readme.txt
--- mangos-classic/botguy_readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/botguy_readme.txt	2016-06-20 09:28:56.000000000 +0200
@@ -0,0 +1,12 @@
+What it is:
+===========
+
+The new revised'botguy' utilizes NPCs already distributed throughout the world, to allow players to
+summon and dismiss bots at will, from their own account.
+
+This is a revised (more stable) version that utilizes the new 'GOSSIP MENU SYSTEM' to modify the menus of existing NPCs
+(e.g Trainers etc) to include the bot Recruit/Dismiss menu. (No GameMaster account necessary).
+
+Install (Server administrators only)
+=======
+Please apply 'mangos_botguy.sql' once to the world database to update the 'gossip_menu_option' table.
Binary files mangos-classic/contrib/.DS_Store and portalclassic/contrib/.DS_Store differ
Binary files mangos-classic/contrib/vmap_extractor/.DS_Store and portalclassic/contrib/vmap_extractor/.DS_Store differ
Binary files mangos-classic/contrib/vmap_extractor/win/.DS_Store and portalclassic/contrib/vmap_extractor/win/.DS_Store differ
diff -ruN mangos-classic/doc/README.Playerbot portalclassic/doc/README.Playerbot
--- mangos-classic/doc/README.Playerbot	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/doc/README.Playerbot	2016-06-20 09:28:56.000000000 +0200
@@ -0,0 +1,354 @@
+What it is:
+===========
+
+Playerbot lets you add another character from your account as a bot that you can command. Only characters from your account can be used, so you can have a maximum of 9 bots at one time per account.
+
+This was taken from the Trinity site, and modified slightly by me to get some of the kinks out.
+
+Bots will only use abilities that they have - for example, a priest will only use the renew spell if it has been trained. A bot's equipment will lose durability like any other character.
+
+All help is welcome be it through code development, reports from play testing or just discussion. Meet us in the MaNGOS forum thread.
+
+For MaNGOS 11834+
+
+Commands:
+=========
+
+/s .bot add BOTNAME (add character to world)
+/s .bot remove BOTNAME
+/s .bot co|combatorder BOTNAME COMBATORDER [TARGET]
+/invite BOTNAME (bot will auto accept invite)
+
+For a full list of commands, use '/t BOTNAME help' or various subcommands e.g. '/t BOTNAME help auction remove'.
+
+Note that these commands work both in whisper and in party chat (assuming the bot is in the party). Any command in party chat will be obeyed by all bots in the party (if applicable).
+
+/t BOTNAME attack (bot will attack selected target, similar to the way a pet can attack)
+/t BOTNAME follow (orders bot to follow player; will also revive bot if dead or teleport bot if far away)
+/t BOTNAME follow far (increases the bots follow distance from the player)
+/t BOTNAME follow near (decreases the bots follow distance from the player)
+/t BOTNAME follow reset (resets the bots follow distance to the config default setting. this commmand will be phased out)
+/t BOTNAME follow auto (turns off auto variable follow distance which is ON by default)
+/t BOTNAME follow info (Shows Automatic Follow Distance, toggle status ON or OFF)
+/t BOTNAME combat delay <0-10> (sets the amount of time the bot will wait before engaging your target in combat)
+/t BOTNAME stay
+/t BOTNAME assist (you'll need to be attacking something and the bot only does melee atm)
+/t BOTNAME spells (replies with all spells known to bot)
+/t BOTNAME cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME craft < alchemy | a >                  (List all learnt alchemy [RECIPE]..)
+                 < blacksmithing | b >            (List all learnt blacksmith [RECIPE]..)
+                 < cooking | c >                  (List all learnt cooking [RECIPE]..)
+                 < engineering | e >              (List all learnt engineering [RECIPE]..)
+                 < firstaid | f >                 (List all learnt firstaid [RECIPE]..)
+                 < inscription | i >              (List all learnt inscription [RECIPE]..)
+                 < jewelcrafting | j >            (List all learnt jewelcrafting [RECIPE]..)
+                 < leatherworking | l >           (List all learnt leatherworking [RECIPE]..)
+                 < magic | m >                    (List all learnt enchanting [RECIPE]..)
+                 < smelting | s >                 (List all learnt mining [RECIPE]..)
+                 < tailoring | t >                (List all learnt tailoring [RECIPE]..)
+/t BOTNAME craft [RECIPE] (craft any recipe that consumes reagents)
+/t BOTNAME craft [RECIPE] all (craft all instances of a particular recipe, indicated by it's [charge])
+/t BOTNAME process < disenchant | d > [ITEM LINK] (disenchants green [ITEM LINK] or better)
+/t BOTNAME process < mill | m > [ITEM LINK] (grinds 5 herbs [ITEM LINK] to produce pigments)
+/t BOTNAME process < prospect | p > [ITEM LINK] (searches 5 metal ore [ITEM LINK] for precious gems)
+/t BOTNAME enchant (lists all enchantments [SPELLLINK] learnt by the bot)
+/t BOTNAME enchant [SPELLLINK][ITEM LINK] (enchants selected tradable [ITEM LINK] either equipped or in bag)
+/t BOTNAME use [ITEM LINK] (use item on self. If item hold quest, it will be accepted. If inventory item is lootable, it will be looted)
+/t BOTNAME use [ITEM LINK] TARGET (use item on selected unit)
+/t BOTNAME use [ITEM LINK][EQUIPPED ITEM LINK] (use item on equipped item)
+/t BOTNAME use [ITEM LINK][GAMEOBJECT LINK] (use item on gameobject)
+/t BOTNAME equip [ITEM LINK]
+/t BOTNAME equip auto (*toggle* auto equip acquired items based on usefulness)
+/t BOTNAME equip info (Show auto equip toggle status ON or OFF)
+/t BOTNAME equip auto <on | off | once> (explicitly turn auto equip ON or OFF, or run autoequip once after which it will turn off)
+/t BOTNAME reset (will reset states, orders and loot list)
+/t BOTNAME stats (bot shows available money, free inventory space and estimated item repair costs)
+/t BOTNAME survey (bot shows all available gameobjects, within a local perimeter around the bot)
+/t BOTNAME find [GAMEOBJECT LINK] (bot will travel to the gameobject location and then wait)
+/t BOTNAME get [GAMEOBJECT LINK] (bot will fetch the selected gameobject and then return to the player)
+/t BOTNAME quest (Shows bot's current quests)
+/t BOTNAME quest < add | a > [QUESTLINK] (Adds a quest)
+/t BOTNAME quest < drop | d > [QUESTLINK] (Drop a quest)
+/t BOTNAME quest < end | e > (Turns in a completed quest)
+/t BOTNAME quest < end | e > (Turns in a completed quest)
+/t BOTNAME quest < report | r > (bot reports all items, creatures or gameobjects needed to finish quests)
+/t BOTNAME quest fetch (bot will automatically check for and accept all acceptable quests from target questgiver)
+/t BOTNAME orders (Shows bot's combat orders)
+/t BOTNAME pet abandon (abandon current active hunter pet)
+/t BOTNAME pet tame TARGET (tame selected creature, if bot has 'tame beast' spell in spellbook)
+/t BOTNAME pet spells (Shows spells known to bot's pet. Autocast spells will be shown in green)
+/t BOTNAME pet cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME pet toggle <SPELLID | (part of) SPELLNAME | [SPELLLINK]> (Toggle autocast for a given spell)
+/t BOTNAME pet state (Shows current react mode of bot's pet)
+/t BOTNAME pet react <(a)ggressive | (d)efensive | (p)assive> (Set bot's pet reaction mode)
+/t BOTNAME collect (shows collect subcommand options and current collect status)
+/t BOTNAME collect <subcommand(s)> (subcommands can be alone or together [none combat loot objects profession quest])
+/t BOTNAME sell [ITEM LINK] (bot will sell item(s) with nearest vendor)
+/t BOTNAME sell all (causes bot(s) to sell all normal(white) useless items. type .help for details (based on a number of comparisons)
+/t BOTNAME buy [ITEM LINK] (bot buy item(s) from selected vendor)
+/t BOTNAME drop [ITEM LINK] (bot will drop item immediately, permanently destroying it)
+/t BOTNAME auction (bot will display all it's active owned auctions. Auction info will include an [AUCTION LINK] )
+/t BOTNAME auction add [ITEM LINK] (bot will add item to it's m_itemIds, for later auction)
+/t BOTNAME auction remove [AUCTION LINK] (bot will add auctionid to it's m_auctions, for later auction cancellation)
+/t BOTNAME mail inbox [MAILBOX] (Lists all bot mail from selected [MAILBOX])
+/t BOTNAME mail getcash [MAIL ID].. (gets all cash from selected [MAIL ID])
+/t BOTNAME mail getitem [MAIL ID].. (gets all items from selected [MAIL ID])
+/t BOTNAME mail delete [MAIL ID].. (delete all bot mail selected [MAIL ID])
+/t BOTNAME repair [ITEM LINK] (bot will seek out armourer and repair selected items specified by [ITEM LINK] )
+/t BOTNAME repair all (bot(s) will seek out armourer and repair all damaged items equipped, or in bags )
+/t BOTNAME talent (Lists bot(s) active talents [TALENT LINK] & glyphs [GLYPH LINK], unspent talent points & cost to reset all talents)
+/t BOTNAME talent learn [TALENT LINK} .. (Learn selected talent from bot client 'inspect' dialog -> 'talent' tab or from talent command (shift click icon or link))
+/t BOTNAME talent reset (Resets all talents)
+/t BOTNAME talent spec (Lists talent specs available to this bot's class, with #, to use below)
+/t BOTNAME talent spec # (If valid, uses this # talent spec for this bot (see # from talent spec above))
+/t BOTNAME bank  (Lists bot(s) bank balance)
+/t BOTNAME bank deposit [Item Link][Item Link] .. (Deposit item(s) in bank)
+/t BOTNAME bank withdraw [Item Link][Item Link] ..  (Withdraw item(s) from bank. ([Item Link] from bank))
+/t BOTNAME skill (lists all [PROFESSION LINK] bot Primary profession skills)
+/t BOTNAME skill learn (lists [TRAINING LINK] available class, weapon & profession (Primary or Secondary) skills & spells, from selected trainer)
+/t BOTNAME skill learn [TRAINING LINK] (learn selected skill or spell, from selected trainer)
+/t BOTNAME skill unlearn [PROFESSION LINK] (unlearn selected primary profession skill & all associated spells)
+/t BOTNAME skill fetch (bot will automatically check for and learn all available skills/spells from the targeted trainer)
+/t BOTNAME help (lists all the commands above and how they work. Except for the ".bot command" ones.)
+/t BOTNAME gm check talent spec (Does a validity check on all talentspecs in the database, only works for GMs or higher)
+/t BOTNAME resumeorders (causes bot or party to restore previous combat orders)
+
+Shortcuts:
+c = cast
+e = equip
+u = use
+
+Gameobject interaction with bots:
+=================================
+
+  The bot(s) can interact with gameobjects. This is particularly useful, in order to complete 'gather' type
+  quests (e.g Milly's harvest in Northshire). The bot(s) can also harvest 'ore deposits' and 'herbs'
+
+  Four commands have been introduced 'collect', 'survey, 'find' & 'get', to facilitate this feature.
+
+  The 'collect' command provides a way to have a bot automatically get loot or objects in the world.
+  The command by itself gives you a display of what settings the bots have. Defaults are stored in
+  the playerbot.conf. The subcommands do the actual work:
+    combat - bot will loot after combat for the options that are set
+    loot - bot will grab all loot available from corpse
+    quest - bot will grab all quest items on corpse
+    profession - bot will grab any profession related item that the bot has from corpse
+    skin - if you have skinning, and corpse has been looted, bot will skin corpse. Most of
+        the time you may want this option and the loot option enabled, but if you are grabbing
+        the stuff as you are going around, the bot will skin afterwards.
+    objects - bot will collect things that are specified by the survey and get <shift-click> commands
+    distance:<value> - bot will loot objects in the specified distance value
+    none - removes any collect options that have been set
+
+  The 'survey' command provides the means for bot(s) to detect gameobjects in the world. It can be used to detect
+  available gameobjects local to a single bot, or more effectively (wider area) those for a party of bots.
+
+  Suggestion: setup the 'survey' command as an assigned macro button, on the client (e.g /p survey). You can
+  then quickly refresh the gameobject list.
+
+  Gameobject list [GAMEOBJECT LINK] (Currently bots can only interact with ore, herb and needed quest items)
+  ---------------
+
+  [Copper Vein][Silverleaf][Earthroot][Milly's Harvest][Battered Chest][Food Crate]
+
+  Then, use the 'find' or 'get' commands to interect with the gameobject.
+
+  Using the gameobject list information, it is possible to locate and/or fetch each of the gameobjects. To select
+  a [GAMEOBJECT LINK], hold down the shift key and click on the relevant link with your mouse.
+
+Creature interaction with bots:
+===============================
+
+  The bot(s) can now interact directly with creatures. This will enable bot(s) to independently contact NPCs, without
+  the need for player's selection. This opens up new possiblities for bot/NPC commerce.
+
+  Each bot will maintain it's own item list (m_itemIds - This is a list of paired data). The first component (UNIT_NPC_FLAG)
+  dictates what is to done with the second component (itemid).
+
+  Each bot will also maintain it's own active auction list (m_auctions - This is a list of paired data). The first component
+  (ActionFlags) dictates the action to be performed on the second component (auctionid).
+
+  While(m_itemIds not empty)
+  {
+      bot will scan for surrounding creatures (findNearbyCreature()) who can service m_itemIds
+      if(found)
+          Search is carried out for all itemids that can be processed by this creature.
+          if(processed successfully)
+              This instance of the data pair (npcflag,itemid) will be removed from m_itemIds
+              While(m_auctions not empty)
+                  process contained auctionids according to ActionFlag & then update m_auctions
+  }
+
+  Please note that bot(s) m_itemIds & m_auctions will be emptied, when bot(s) are dismissed.
+
+Repair with bots:
+=================
+
+  Bots will now automatically unequip worn items before they break, and will
+  notify the master of worn items.  They will not equip worn items (less than 10% of max durability)
+
+  Bot can now repair <all or selected> items - equipped or in bags. If the bot is
+  a member of a guild, then the guild fund is used for repairs. If not, the bots own
+  gold supply is used. If the bot cannot pay for the repair, they remain damaged.
+
+  The new 'stats' command provides useful information to help in the repair decision.
+
+  First:  Money available to bot(s)
+  Second: Free inventory slots for bot(s)
+  Third:  Estimated (excludes NPC reputation discount) item damage cost for bot(s).
+
+Combat Orders explained:
+========================
+
+  There are primary and secondary commands which can be combined. In this way it is
+  possible to define a bot to assist the main tank and also protect the healer, making
+  combat management much easier.
+  The commands assist and protect require a target parameter or a friendly player
+  selected by bots master.
+  Available Combat Orders:
+    tank        pri     try to bind all targets involved in combat by gaining highest threat
+    assist      pri     do damage on selected targets attacker without getting highest threat
+    heal        pri     concentrate on healing - no offensive spells, try to keep threat low
+    protect     sec     if target of protect get's directly attacked gain higher threat on attacker
+    reset       -       clear out assist and protect targets and set combat order to nothing
+  Examples:
+    .bot co TheTank tank
+    .bot co MyHealer heal
+    .bot co TheBrutal assist TheTank
+    .bot co TheBrutal protect MyHealer
+
+Trading with bots:
+==================
+
+To trade items/money with your bot simply initiate a trade and the bot will tell you how much money and items are available. To request an item simple whisper the bot and shift click the link of the item you would like. You can link multiple items on the same line. You can also request money in the following manner when the trade window is open:
+/w BOTNAME 10g <-- request that the bot give you 10 gold
+/w BOTNAME 6g500s25c <-- request 6 gold, 500 silver, and 25 copper
+
+A bot is also able to show an item in its 'Will not be traded' slot. The item can be either
+in its bags or be equipped and even be soulbound. Using this you can cast spells/enchantments
+on soulbound items ('nt' stands for 'not trading').
+/w BOTNAME nt [Enchantable Soulbound Item]
+
+More Information:
+=================
+
+If specifying a spell substring, the spell chosen will be in priority of exact name match, highest spell rank, and spell using no reagents. Case does not matter. Here's some examples:
+/t BOTNAME c greater heal
+/t BOTNAME cast pain
+/w BOTNAME c poly
+/w BOTNAME cast fort
+/t BOTNAME cast <SPELLID>
+- OR -
+/w BOTNAME c <SPELLID>
+
+Also all commands can be broadcast to the party. For example:
+/p follow
+/p spells
+
+To use or equip items for your bot say:
+/w BOTNAME use [ITEMLINK1][ITEMLINK2]
+/w BOTNAME equip [ITEMLINK1][ITEMLINK2]
+- OR -
+/w BOTNAME u [ITEMLINK1][ITEMLINK2]
+/w BOTNAME e [ITEMLINK1] [ITEMLINK2]
+
+If you inspect your bot, your bot will tell you what items you have in your inventory that you can equip. To create a link in the chat window, hold the shift key and press the left mouse button when clicking the link.
+
+
+Installation:
+=============
+Merge PlayerbotAI code with your favorite core/mods, or simply compile. Follow Mangos Core installation steps.
+
+Copy src/game/playerbot/playerbot.conf.dist.in for configuration variables!
+Install appropriate files from sql/playerbotai
+
+Developers:
+===========
+When updating the playerbot.conf version, keep in mind the following locations (YYYYMMDDVV = Year, Month, Day, Version (version starting at 01, counting up as releases happen on the same day)):
+* src/game/playerbot/config.h
+define PLAYERBOT_CONF_VERSION    YYYYMMDDVV
+* src/game/playerbot/config.h.in
+define PLAYERBOT_CONF_VERSION    YYYYMMDDVV
+* src/game/playerbot/playerbot.conf.dist.in
+ConfVersion=YYYYMMDDVV
+* Of course don't forget to update your server's playerbot.conf.
+
+When updating the sql file(s), keep in mind the following:
+
+=== File Name Description in [sql/playerbotai] folder ===
+
+    FULL_playerbotai_characters_r2_update
+    |    |           |          |  |
+    |    |           |          |  Only if the sql updates a previous sql
+    |    |           |          |
+    |    |           |          Playerbot revision related to sql 
+    |    |           |
+    |    |           |Name of affected DB (default recommended name)
+    |    |
+    |    Playerbot sql file..drrr!
+    |
+    For clean install, just apply this sql
+
+* src/game/playerbot/revision_sql.h
+#define REVISION_DB_PLAYERBOTAI "required_playerbotai_characters_svdata_003"
+NOTE: This string should be an exact copy of your SQL file's second field name in the `playerbotai_db_version` table.
+
+BotGuy NPC Menu System
+======================
+
+The new revised'botguy' utilizes NPCs already distributed throughout the world, to allow players to summon and dismiss
+bots at will, from their own account.
+
+This is a revised (more stable) version that utilizes the new 'GOSSIP MENU SYSTEM' to modify the menus of existing 
+NPCs(e.g Trainers etc) to include the bot Recruit/Dismiss menu.(No GameMaster account necessary).
+
+Install (Server administrators only)
+=======
+Please apply 'mangos_botguy.sql' (in sql/playerbotai) once to the world database to update the 'gossip_menu_option' table.
+
+                                    ---------------------------------------------------------
+
+ToDo
+====
+
+[DONE] ///---Quest---///
+[DONE] Bot can accept quest.
+[DONE] Bot can join quest.
+
+[DONE] ///---Loot---///
+[DONE] Bot can loot.
+[DONE] Bot can loot --- maybe only needed q item.
+
+//---Instance teleport Problems---///
+[DONE] Needs some fix.
+
+///---Combat and Movement Orders---///
+[DONE] Movement orders (stay, follow)
+[DONE] Combat orders (protect, assist)
+Combat order TANK
+Combat order HEAL
+
+///---Temporary item enchantments---///
+[DONE] Rogue	: Poison
+Warrior	: Sharpening Stone, Rune of Warding, Rune of Shielding.
+
+//---After fear bot's lose target---///
+Needs some fix.
+
+///---Move behind target---///
+[DONE] Rogue	: some abilitys require Rogue to be stealthed and behind target.
+
+///---Implement locale independet way of getting spellIDs---///
+[DONE] Hardcode lowest rank spellID, use function to get highest rank
+
+///---Maintenance on portal repository--- 21/07/2012
+[DONE] git fsck --full
+//cd .git/objects/pack
+[DONE] git gc --aggressive
+[DONE] git verify-pack -v *.idx
+object pack files (*.idx) verified, no errors
+///---Maintenance on portal repository--- 21/07/2012
+
+History:
+========
+This project was ported from a Trinity mod.
diff -ruN mangos-classic/mangos_botguy.sql portalclassic/mangos_botguy.sql
--- mangos-classic/mangos_botguy.sql	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/mangos_botguy.sql	2016-06-20 09:28:56.000000000 +0200
@@ -0,0 +1 @@
+INSERT INTO `gossip_menu_option` VALUES('0','16','0','GOSSIP_OPTION_BOT','99','1','0','0','0','0','0',NULL,'0','0','0','0','0','0','0','0','0');
diff -ruN mangos-classic/sql/playerbotai/playerbotai_characters_svdata_001.sql portalclassic/sql/playerbotai/playerbotai_characters_svdata_001.sql
--- mangos-classic/sql/playerbotai/playerbotai_characters_svdata_001.sql	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/sql/playerbotai/playerbotai_characters_svdata_001.sql	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+Navicat MySQL Data Transfer
+
+Source Server : Moo
+Source Server Version : 50145
+Source Host : localhost:****
+Source Database : characters
+
+Target Server Type : MYSQL
+Target Server Version : 50145
+File Encoding : yep
+
+Date: 2012-03-05 20:25:14
+*/
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for `playerbot_saved_data`
+-- ----------------------------
+DROP TABLE IF EXISTS `playerbot_saved_data`;
+CREATE TABLE `playerbot_saved_data` (
+  `guid` int(11) unsigned NOT NULL DEFAULT '0',
+  `bot_primary_order` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `bot_secondary_order` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `primary_target` int(11) unsigned NOT NULL DEFAULT '0',
+  `secondary_target` int(11) unsigned NOT NULL DEFAULT '0',
+  `pname` varchar(12) NOT NULL DEFAULT '',
+  `sname` varchar(12) NOT NULL DEFAULT '',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+-- ----------------------------
+-- Records of playerbot_saved_data
+-- ----------------------------
diff -ruN mangos-classic/sql/playerbotai/playerbotai_characters_svdata_002.sql portalclassic/sql/playerbotai/playerbotai_characters_svdata_002.sql
--- mangos-classic/sql/playerbotai/playerbotai_characters_svdata_002.sql	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/sql/playerbotai/playerbotai_characters_svdata_002.sql	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,18 @@
+/*
+Navicat MySQL Data Transfer
+
+Source Server : Moo
+Source Server Version : 50145
+Source Host : localhost:****
+Source Database : characters
+
+Target Server Type : MYSQL
+Target Server Version : 50145
+File Encoding : yep
+
+Date: 2012-03-05 20:25:14
+*/
+
+ALTER TABLE `playerbot_saved_data`
+    ADD COLUMN `combat_delay` INT(11) unsigned NOT NULL DEFAULT '0';
+    
\ No newline at end of file
diff -ruN mangos-classic/sql/playerbotai/playerbotai_characters_svdata_003.sql portalclassic/sql/playerbotai/playerbotai_characters_svdata_003.sql
--- mangos-classic/sql/playerbotai/playerbotai_characters_svdata_003.sql	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/sql/playerbotai/playerbotai_characters_svdata_003.sql	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,2 @@
+ALTER TABLE `playerbot_saved_data` DROP COLUMN `bot_secondary_order`;
+ALTER TABLE playerbot_saved_data CHANGE COLUMN `bot_primary_order` `combat_order` int(11);
diff -ruN mangos-classic/src/game/CMakeLists.txt portalclassic/src/game/CMakeLists.txt
--- mangos-classic/src/game/CMakeLists.txt	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/CMakeLists.txt	2016-06-20 09:28:57.000000000 +0200
@@ -42,6 +42,34 @@
   ${CMAKE_BINARY_DIR}/src/shared
 )
 
+set(SRC_GRP_PLAYERBOT
+	playerbot/config.h
+	playerbot/PlayerbotAI.cpp
+	playerbot/PlayerbotAI.h
+	playerbot/PlayerbotClassAI.cpp
+	playerbot/PlayerbotClassAI.h
+	playerbot/PlayerbotDruidAI.cpp
+	playerbot/PlayerbotDruidAI.h
+	playerbot/PlayerbotHunterAI.cpp
+	playerbot/PlayerbotHunterAI.h
+	playerbot/PlayerbotMageAI.cpp
+	playerbot/PlayerbotMageAI.h
+	playerbot/PlayerbotMgr.cpp
+	playerbot/PlayerbotMgr.h
+	playerbot/PlayerbotPaladinAI.cpp
+	playerbot/PlayerbotPaladinAI.h
+	playerbot/PlayerbotPriestAI.cpp
+	playerbot/PlayerbotPriestAI.h
+	playerbot/PlayerbotRogueAI.cpp
+	playerbot/PlayerbotRogueAI.h
+	playerbot/PlayerbotShamanAI.cpp
+	playerbot/PlayerbotShamanAI.h
+	playerbot/PlayerbotWarlockAI.cpp
+	playerbot/PlayerbotWarlockAI.h
+	playerbot/PlayerbotWarriorAI.cpp
+	playerbot/PlayerbotWarriorAI.h
+)
+
 set(SRC_GRP_AHBOT
     AuctionHouseBot/AuctionHouseBot.cpp
     AuctionHouseBot/AuctionHouseBot.h
@@ -369,6 +397,7 @@
 )
 
 set(LIBRARY_SRCS
+	${SRC_GRP_PLAYERBOT}
     ${SRC_GRP_AHBOT}
     ${SRC_GRP_BATTLEGROUND}
     ${SRC_GRP_CHAT_COMMANDS}
@@ -385,6 +414,11 @@
     pchdef.h
 )
 
+source_group("PlayerBot"
+  FILES
+    ${SRC_GRP_PLAYERBOT}
+)
+
 source_group("AhBot"
   FILES
     ${SRC_GRP_AHBOT}
@@ -473,3 +507,5 @@
 if(PCH)
   cotire(${LIBRARY_NAME})
 endif()
+
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/playerbot/playerbot.conf.dist.in DESTINATION ${CONF_DIR} RENAME playerbot.conf.dist)
diff -ruN mangos-classic/src/game/CharacterHandler.cpp portalclassic/src/game/CharacterHandler.cpp
--- mangos-classic/src/game/CharacterHandler.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/CharacterHandler.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -40,6 +40,9 @@
 #include "Chat.h"
 #include "SpellMgr.h"
 
+// Playerbot mod:
+#include "playerbot/PlayerbotMgr.h"
+
 // config option SkipCinematics supported values
 enum CinematicsSkipMode
 {
@@ -124,6 +127,30 @@
             }
             session->HandlePlayerLogin((LoginQueryHolder*)holder);
         }
+        // Playerbot mod: is different from the normal HandlePlayerLoginCallback in that it
+        // sets up the bot's world session and also stores the pointer to the bot player in the master's
+        // world session m_playerBots map
+        void HandlePlayerBotLoginCallback(QueryResult * /*dummy*/, SqlQueryHolder * holder)
+        {
+            if (!holder)
+                return;
+
+            LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
+
+            WorldSession* masterSession = sWorld.FindSession(lqh->GetAccountId());
+
+            if (! masterSession || sObjectMgr.GetPlayer(lqh->GetGuid()))
+            {
+                delete holder;
+                return;
+            }
+
+            // The bot's WorldSession is owned by the bot's Player object
+            // The bot's WorldSession is deleted by PlayerbotMgr::LogoutPlayerBot
+            WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, 0, LOCALE_enUS);
+            botSession->HandlePlayerLogin(lqh); // will delete lqh
+            masterSession->GetPlayer()->GetPlayerbotMgr()->OnBotLogin(botSession->GetPlayer());
+        }
 } chrHandler;
 
 void WorldSession::HandleCharEnum(QueryResult* result)
@@ -440,6 +467,27 @@
     CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerLoginCallback, holder);
 }
 
+// Playerbot mod. Can't easily reuse HandlePlayerLoginOpcode for logging in bots because it assumes
+// a WorldSession exists for the bot. The WorldSession for a bot is created after the character is loaded.
+void PlayerbotMgr::LoginPlayerBot(ObjectGuid playerGuid)
+{
+    // has bot already been added?
+    if (sObjectMgr.GetPlayer(playerGuid))
+        return;
+
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(playerGuid);
+    if (accountId == 0)
+        return;
+
+    LoginQueryHolder *holder = new LoginQueryHolder(accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+    CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+}
+
 void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 {
     ObjectGuid playerGuid = holder->GetGuid();
diff -ruN mangos-classic/src/game/Chat.cpp portalclassic/src/game/Chat.cpp
--- mangos-classic/src/game/Chat.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/Chat.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -759,10 +759,13 @@
         { "combatstop",     SEC_GAMEMASTER,     false, &ChatHandler::HandleCombatStopCommand,          "", nullptr },
         { "repairitems",    SEC_GAMEMASTER,     true,  &ChatHandler::HandleRepairitemsCommand,         "", nullptr },
         { "stable",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleStableCommand,              "", nullptr },
+        //Playerbot mod
+        { "bot",            SEC_PLAYER,         false, &ChatHandler::HandlePlayerbotCommand,           "", nullptr },
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", nullptr },
         { "quit",           SEC_CONSOLE,        true,  &ChatHandler::HandleQuitCommand,                "", nullptr },
         { "mmap",           SEC_GAMEMASTER,     false, nullptr,                                        "", mmapCommandTable },
 
+
         { nullptr,          0,                  false, nullptr,                                        "", nullptr }
     };
 
diff -ruN mangos-classic/src/game/Chat.h portalclassic/src/game/Chat.h
--- mangos-classic/src/game/Chat.h	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/Chat.h	2016-06-20 09:28:57.000000000 +0200
@@ -575,6 +575,7 @@
         bool HandleRepairitemsCommand(char* args);
         bool HandleStableCommand(char* args);
         bool HandleWaterwalkCommand(char* args);
+        bool HandlePlayerbotCommand(char* args);
         bool HandleQuitCommand(char* args);
 
         bool HandleMmapPathCommand(char* args);
diff -ruN mangos-classic/src/game/ChatHandler.cpp portalclassic/src/game/ChatHandler.cpp
--- mangos-classic/src/game/ChatHandler.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/ChatHandler.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -35,6 +35,9 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 
+// Playerbot mod
+#include "playerbot/PlayerbotAI.h"
+
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -211,7 +214,15 @@
                 }
             }
 
-            GetPlayer()->Whisper(msg, lang, player->GetObjectGuid());
+            // Playerbot mod: handle whispered command to bot
+            if (player->GetPlayerbotAI())
+            {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                GetPlayer()->Whisper(msg, lang, player->GetObjectGuid());
         } break;
 
         case CHAT_MSG_PARTY:
@@ -240,6 +251,19 @@
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != nullptr; itr=itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, ChatMsg(type), msg.c_str(), Language(lang), _player->GetChatTag(), _player->GetObjectGuid(), _player->GetName());
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetObjectGuid()));
diff -ruN mangos-classic/src/game/Creature.h portalclassic/src/game/Creature.h
--- mangos-classic/src/game/Creature.h	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/Creature.h	2016-06-20 09:28:57.000000000 +0200
@@ -373,10 +373,10 @@
 
 struct TrainerSpell
 {
-    TrainerSpell() : spell(0), spellCost(0), reqSkill(0), reqSkillValue(0), reqLevel(0), isProvidedReqLevel(false) {}
+    TrainerSpell() : spell(0), spellCost(0), reqSkill(0), reqSkillValue(0), reqLevel(0), learnedSpell(0), isProvidedReqLevel(false) {}
 
-    TrainerSpell(uint32 _spell, uint32 _spellCost, uint32 _reqSkill, uint32 _reqSkillValue, uint32 _reqLevel, bool _isProvidedReqLevel)
-        : spell(_spell), spellCost(_spellCost), reqSkill(_reqSkill), reqSkillValue(_reqSkillValue), reqLevel(_reqLevel), isProvidedReqLevel(_isProvidedReqLevel)
+    TrainerSpell(uint32 _spell, uint32 _spellCost, uint32 _reqSkill, uint32 _reqSkillValue, uint32 _reqLevel, uint32 _learnedspell, bool _isProvidedReqLevel)
+        : spell(_spell), spellCost(_spellCost), reqSkill(_reqSkill), reqSkillValue(_reqSkillValue), reqLevel(_reqLevel), learnedSpell(_learnedspell), isProvidedReqLevel(_isProvidedReqLevel)
     {}
 
     uint32 spell;
@@ -384,7 +384,11 @@
     uint32 reqSkill;
     uint32 reqSkillValue;
     uint32 reqLevel;
+    uint32 learnedSpell;
     bool isProvidedReqLevel;
+
+    // helpers
+    bool IsCastable() const { return learnedSpell != spell; }
 };
 
 typedef std::unordered_map < uint32 /*spellid*/, TrainerSpell > TrainerSpellMap;
@@ -505,6 +509,9 @@
         bool IsTotem() const { return m_subtype == CREATURE_SUBTYPE_TOTEM; }
         bool IsTemporarySummon() const { return m_subtype == CREATURE_SUBTYPE_TEMPORARY_SUMMON; }
 
+        // Playerbot mod - adds functionality to load/unload bots from NPC, also need to apply SQL scripts
+        void LoadBotMenu(Player *pPlayer);
+
         bool IsCorpse() const { return getDeathState() ==  CORPSE; }
         bool IsDespawned() const { return getDeathState() ==  DEAD; }
         void SetCorpseDelay(uint32 delay) { m_corpseDelay = delay; }
diff -ruN mangos-classic/src/game/GossipDef.h portalclassic/src/game/GossipDef.h
--- mangos-classic/src/game/GossipDef.h	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/GossipDef.h	2016-06-20 09:28:57.000000000 +0200
@@ -49,6 +49,8 @@
     GOSSIP_OPTION_ARMORER           = 15,                   // UNIT_NPC_FLAG_ARMORER             (4096)
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   // UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   // UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
+    // Playerbot mod
+    GOSSIP_OPTION_BOT               = 99,                   // UNIT_NPC_FLAG_GOSSIP              (1) UNUSED (just for bot system)
     GOSSIP_OPTION_MAX
 };
 
diff -ruN mangos-classic/src/game/Group.cpp portalclassic/src/game/Group.cpp
--- mangos-classic/src/game/Group.cpp	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/Group.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -29,6 +29,7 @@
 #include "BattleGround/BattleGround.h"
 #include "MapManager.h"
 #include "MapPersistentStateMgr.h"
+#include "playerbot/PlayerbotMgr.h"
 
 //===================================================
 //============== Group ==============================
@@ -268,6 +269,14 @@
 
 uint32 Group::RemoveMember(ObjectGuid guid, uint8 method)
 {
+    //Playerbot mod - if master leaves group, all bots leave group
+    {
+        Player* const player = sObjectMgr.GetPlayer(guid);
+        if (player && player->GetPlayerbotMgr())
+            player->GetPlayerbotMgr()->RemoveAllBotsFromGroup();
+    }
+    //END Playerbot mod
+
     // remove member and change leader (if need) only if strong more 2 members _before_ member remove
     if (GetMembersCount() > uint32(isBGGroup() ? 1 : 2))    // in BG group case allow 1 members group
     {
diff -ruN mangos-classic/src/game/Map.cpp portalclassic/src/game/Map.cpp
--- mangos-classic/src/game/Map.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/Map.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -624,7 +624,8 @@
     SendRemoveTransports(player);
     UpdateObjectVisibility(player, cell, p);
 
-    player->ResetMap();
+    // Playerbot: Fix for instance teleportation issue (from commit 01ab2c51...)
+    // player->ResetMap();
     if (remove)
         DeleteFromWorld(player);
 }
diff -ruN mangos-classic/src/game/Player.cpp portalclassic/src/game/Player.cpp
--- mangos-classic/src/game/Player.cpp	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/Player.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -61,6 +61,11 @@
 #include "SQLStorages.h"
 #include "LootMgr.h"
 
+// Playerbot mod:
+#include "playerbot/PlayerbotAI.h"
+#include "playerbot/PlayerbotMgr.h"
+#include "Config/Config.h"
+
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
@@ -77,6 +82,8 @@
 #define SKILL_PERM_BONUS(x)    int16(PAIR32_HIPART(x))
 #define MAKE_SKILL_BONUS(t, p) MAKE_PAIR32(t,p)
 
+extern Config botConfig;
+
 // [-ZERO] need recheck, some values known not existed in 1.12.1
 enum CharacterFlags
 {
@@ -370,6 +377,10 @@
 {
     m_transport = nullptr;
 
+    // Playerbot mod:
+    m_playerbotAI = 0;
+    m_playerbotMgr = 0;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -564,6 +575,16 @@
     // clean up player-instance binds, may unload some instance saves
     for (BoundInstancesMap::iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end(); ++itr)
         itr->second.state->RemovePlayer(this);
+
+    // Playerbot mod
+    if (m_playerbotAI) {
+        delete m_playerbotAI;
+        m_playerbotAI = 0;
+    }
+    if (m_playerbotMgr) {
+        delete m_playerbotMgr;
+        m_playerbotMgr = 0;
+    }
 }
 
 void Player::CleanupsBeforeDelete()
@@ -1303,6 +1324,12 @@
 
     if (IsHasDelayedTeleport())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    // Playerbot mod
+    if (m_playerbotAI)
+        m_playerbotAI->UpdateAI(p_time);
+    else if (m_playerbotMgr)
+        m_playerbotMgr->UpdateAI(p_time);
 }
 
 void Player::SetDeathState(DeathState s)
@@ -1509,6 +1536,11 @@
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
+    // Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    if (GetPlayerbotMgr())
+        GetPlayerbotMgr()->Stay();
+
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
     // don't let gm level > 1 either
     if (!InBattleGround() && mEntry->IsBattleGround())
@@ -10887,6 +10919,15 @@
                 case GOSSIP_OPTION_TABARDDESIGNER:
                 case GOSSIP_OPTION_AUCTIONEER:
                     break;                                  // no checks
+                case GOSSIP_OPTION_BOT:
+                {
+                    std::string reqQuestIds = botConfig.GetStringDefault("PlayerbotAI.BotguyQuests","");
+                    uint32 cost = botConfig.GetIntDefault("PlayerbotAI.BotguyCost",0);
+                    if((reqQuestIds == "" || requiredQuests(reqQuestIds.c_str())) && !pCreature->isInnkeeper() && this->GetMoney() >= cost)
+                        pCreature->LoadBotMenu(this);
+                    hasMenuItem = false;
+                    break;
+                }
                 default:
                     sLog.outErrorDb("Creature entry %u have unknown gossip option %u for menu %u", pCreature->GetEntry(), gossipMenu.option_id, gossipMenu.menu_id);
                     hasMenuItem = false;
@@ -11021,12 +11062,12 @@
         }
     }
 
-    GossipMenuItemData pMenuData = gossipmenu.GetItemData(gossipListId);
-
     switch (gossipOptionId)
     {
         case GOSSIP_OPTION_GOSSIP:
         {
+            GossipMenuItemData pMenuData = gossipmenu.GetItemData(gossipListId);
+
             if (pMenuData.m_gAction_poi)
                 PlayerTalkClass->SendPointOfInterest(pMenuData.m_gAction_poi);
 
@@ -11108,8 +11149,63 @@
             GetSession()->SendBattlegGroundList(guid, bgTypeId);
             break;
         }
+        case GOSSIP_OPTION_BOT:
+        {
+            // DEBUG_LOG("GOSSIP_OPTION_BOT");
+            PlayerTalkClass->CloseGossip();
+            uint32 guidlo = PlayerTalkClass->GossipOptionSender(gossipListId);
+            uint32 cost = botConfig.GetIntDefault("PlayerbotAI.BotguyCost",0);
+
+            if (!GetPlayerbotMgr())
+                SetPlayerbotMgr(new PlayerbotMgr(this));
+
+            if(GetPlayerbotMgr()->GetPlayerBot(ObjectGuid(HIGHGUID_PLAYER,guidlo)) != nullptr)
+            {
+                GetPlayerbotMgr()->LogoutPlayerBot(ObjectGuid(HIGHGUID_PLAYER,guidlo));
+            }
+            else if(GetPlayerbotMgr()->GetPlayerBot(ObjectGuid(HIGHGUID_PLAYER,guidlo)) == nullptr)
+            {
+                QueryResult *resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
+                if(resultchar)
+                {
+                    Field *fields = resultchar->Fetch();
+                    int maxnum = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+                    int acctcharcount = fields[0].GetUInt32();
+                    if(!(m_session->GetSecurity() > SEC_PLAYER))
+                        if(acctcharcount > maxnum)
+                        {
+                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon anymore bots.(Current Max: |cffffffff%u)",maxnum);
+                            delete resultchar;
+                            break;
+                        }
+                }
+                delete resultchar;
+
+                QueryResult *resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guidlo);
+                if(resultlvl)
+                {
+                    Field *fields=resultlvl->Fetch();
+                    int maxlvl = botConfig.GetIntDefault("PlayerbotAI.RestrictBotLevel", 80);
+                    int charlvl = fields[0].GetUInt32();
+                    if(!(m_session->GetSecurity() > SEC_PLAYER))
+                        if(charlvl > maxlvl)
+                        {
+                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.(Current Max:lvl |cffffffff%u)",fields[1].GetString(),maxlvl);
+                            delete resultlvl;
+                            break;
+                        }
+                }
+                delete resultlvl;
+
+                GetPlayerbotMgr()->LoginPlayerBot(ObjectGuid(HIGHGUID_PLAYER,guidlo));
+                this->ModifyMoney(-(int32)cost);
+            }
+            return;
+        }
     }
 
+    GossipMenuItemData pMenuData = gossipmenu.GetItemData(gossipListId);
+
     if (pMenuData.m_gAction_script)
     {
         if (pSource->GetTypeId() == TYPEID_UNIT)
diff -ruN mangos-classic/src/game/Player.h portalclassic/src/game/Player.h
--- mangos-classic/src/game/Player.h	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/Player.h	2016-06-20 09:28:57.000000000 +0200
@@ -53,6 +53,10 @@
 class Spell;
 class Item;
 
+// Playerbot mod
+#include "playerbot/PlayerbotMgr.h"
+#include "playerbot/PlayerbotAI.h"
+
 struct AreaTrigger;
 
 typedef std::deque<Mail*> PlayerMails;
@@ -1246,6 +1250,13 @@
         void AddTimedQuest(uint32 quest_id) { m_timedquests.insert(quest_id); }
         void RemoveTimedQuest(uint32 quest_id) { m_timedquests.erase(quest_id); }
 
+        // Playerbot mod
+        void chompAndTrim(std::string& str);
+        bool getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId);
+        void skill(std::list<uint32>& m_spellsToLearn);
+        bool requiredQuests(const char* pQuestIdString);
+        uint32 GetSpec();
+
         /*********************************************************/
         /***                   LOAD SYSTEM                     ***/
         /*********************************************************/
@@ -2052,6 +2063,16 @@
         GridReference<Player>& GetGridRef() { return m_gridRef; }
         MapReference& GetMapRef() { return m_mapRef; }
 
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        void SetPlayerbotAI(PlayerbotAI* ai) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        bool IsInDuel() const { return duel && duel->startTime != 0; }
+
     protected:
 
         uint32 m_contestedPvPTimer;
@@ -2290,6 +2311,10 @@
         GridReference<Player> m_gridRef;
         MapReference m_mapRef;
 
+         // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
+
         // Homebind coordinates
         uint32 m_homebindMapId;
         uint16 m_homebindAreaId;
diff -ruN mangos-classic/src/game/QuestHandler.cpp portalclassic/src/game/QuestHandler.cpp
--- mangos-classic/src/game/QuestHandler.cpp	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/QuestHandler.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -30,6 +30,9 @@
 #include "ScriptMgr.h"
 #include "Group.h"
 
+// Playerbot mod:
+#include "playerbot/PlayerbotAI.h"
+
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket& recv_data)
 {
     ObjectGuid guid;
@@ -458,8 +461,15 @@
                     continue;
                 }
 
-                pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetObjectGuid(), true);
                 pPlayer->SetDividerGuid(_player->GetObjectGuid());
+
+                if (pPlayer->GetPlayerbotAI())
+                    pPlayer->GetPlayerbotAI()->AcceptQuest( pQuest, _player );
+                else
+                {
+                    pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetObjectGuid(), true);
+                    pPlayer->SetDividerGuid(_player->GetObjectGuid());
+                }
             }
         }
     }
diff -ruN mangos-classic/src/game/SpellHandler.cpp portalclassic/src/game/SpellHandler.cpp
--- mangos-classic/src/game/SpellHandler.cpp	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/SpellHandler.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -364,7 +364,7 @@
     // client provided targets
     SpellCastTargets targets;
 
-    recvPacket >> targets.ReadForCaster(_player);
+    recvPacket >> targets.ReadForCaster(mover);
 
     // auto-selection buff level base at target level (in spellInfo)
     if (Unit* target = targets.getUnitTarget())
diff -ruN mangos-classic/src/game/SpellMgr.cpp portalclassic/src/game/SpellMgr.cpp
--- mangos-classic/src/game/SpellMgr.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/SpellMgr.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -2270,6 +2270,7 @@
             break;
 
         // if found appropriate level
+        // partial Playerbot mod: fix for core bug (commit 073cdd0e...)
         if (level + 10 >= nextSpellInfo->spellLevel)
             return nextSpellInfo;
 
diff -ruN mangos-classic/src/game/World.cpp portalclassic/src/game/World.cpp
--- mangos-classic/src/game/World.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/game/World.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -1257,6 +1257,8 @@
     sAuctionBot.Initialize();
     sLog.outString();
 
+    PlayerbotMgr::SetInitialWorldSettings();
+
     sLog.outString("---------------------------------------");
     sLog.outString("      CMANGOS: World initialized       ");
     sLog.outString("---------------------------------------");
diff -ruN mangos-classic/src/game/WorldSession.cpp portalclassic/src/game/WorldSession.cpp
--- mangos-classic/src/game/WorldSession.cpp	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/WorldSession.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -43,6 +43,10 @@
 #include <algorithm>
 #include <cstdarg>
 
+// Playerbot mod
+#include "playerbot/PlayerbotMgr.h"
+#include "playerbot/PlayerbotAI.h"
+
 // select opcodes appropriate for processing in Map::Update context for current session state
 static bool MapSessionFilterHelper(WorldSession* session, OpcodeHandler const& opHandle)
 {
@@ -118,6 +122,17 @@
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
+    if (!m_Socket)
+        return;
+
     if (m_Socket->IsClosed())
         return;
 
@@ -219,6 +234,11 @@
                         ExecuteOpcode(opHandle, packet);
 
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
+
+                    // playerbot mod
+                    if (_player && _player->GetPlayerbotMgr())
+                        _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                    // playerbot mod end
                     break;
                 case STATUS_LOGGEDIN_OR_RECENTLY_LOGGEDOUT:
                     if (!_player && !m_playerRecentlyLogout)
@@ -290,6 +310,31 @@
         delete packet;
     }
 
+    // Playerbot mod - Process player bot packets
+    // The PlayerbotAI class adds to the packet queue to simulate a real player
+    // since Playerbots are known to the World obj only by its master's WorldSession object
+    // we need to process all master's bot's packets.
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr()) {
+        for (PlayerBotMap::const_iterator itr = GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsBegin();
+                itr != GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsEnd(); ++itr)
+        {
+            Player* const botPlayer = itr->second;
+            WorldSession* const pBotWorldSession = botPlayer->GetSession();
+            if (botPlayer->IsBeingTeleported())
+                botPlayer->GetPlayerbotAI()->HandleTeleportAck();
+            else if (botPlayer->IsInWorld())
+            {
+                std::for_each(pBotWorldSession->m_recvQueue.begin(), pBotWorldSession->m_recvQueue.end(), [&pBotWorldSession](WorldPacket* packet)
+                {
+                    OpcodeHandler const& opHandle = opcodeTable[packet->GetOpcode()];
+                    (pBotWorldSession->*opHandle.handler)(*packet);
+                    delete packet;
+                });
+                pBotWorldSession->m_recvQueue.clear();
+            }
+        }
+    }
+
     // check if we are safe to proceed with logout
     // logout procedure should happen only in World::UpdateSessions() method!!!
     if (updater.ProcessLogout())
@@ -297,7 +342,7 @@
         ///- If necessary, log the player out
         const time_t currTime = time(nullptr);
 
-        if (m_Socket->IsClosed() || (ShouldLogOut(currTime) && !m_playerLoading))
+        if (!m_Socket || m_Socket->IsClosed() || (ShouldLogOut(currTime) && !m_playerLoading))
         {
             LogoutPlayer(true);
             return false;
@@ -319,6 +364,10 @@
 
     if (_player)
     {
+        // Playerbot mod: log out all player bots owned by this toon
+        if (_player->GetPlayerbotMgr())
+            _player->GetPlayerbotMgr()->LogoutAllBots();
+
         sLog.outChar("Account: %d (IP: %s) Logout Character:[%s] (guid: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName() , _player->GetGUIDLow());
 
         if (Loot* loot = sLootMgr.GetLoot(_player))
@@ -407,8 +456,11 @@
         // No SQL injection as AccountID is uint32
         static SqlStatementID id;
 
-        SqlStatement stmt = LoginDatabase.CreateStatement(id, "UPDATE account SET active_realm_id = ? WHERE id = ?");
-        stmt.PExecute(uint32(0), GetAccountId());
+        if (! _player->GetPlayerbotAI())
+        {
+            SqlStatement stmt = LoginDatabase.CreateStatement(id, "UPDATE account SET active_realm_id = ? WHERE id = ?");
+            stmt.PExecute(uint32(0), GetAccountId());
+        }
 
         ///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
         if (Guild* guild = sGuildMgr.GetGuildById(_player->GetGuildId()))
@@ -438,7 +490,7 @@
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
-        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && !m_Socket->IsClosed())
+        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket && !m_Socket->IsClosed())
             _player->RemoveFromGroup();
 
         ///- Send update to group
@@ -449,6 +501,9 @@
         sSocialMgr.SendFriendStatus(_player, FRIEND_OFFLINE, _player->GetObjectGuid(), true);
         sSocialMgr.RemovePlayerSocial(_player->GetGUIDLow());
 
+        // Playerbot - remember player GUID for update SQL below
+        uint32 guid = _player->GetGUIDLow();
+
         ///- Remove the player from the world
         // the player may not be in the world when logging out
         // e.g if he got disconnected during a transfer to another map
@@ -475,8 +530,9 @@
 
         static SqlStatementID updChars;
 
-        stmt = CharacterDatabase.CreateStatement(updChars, "UPDATE characters SET online = 0 WHERE account = ?");
-        stmt.PExecute(GetAccountId());
+        // Playerbot mod: set for only character instead of accountid
+        SqlStatement stmt = CharacterDatabase.CreateStatement(updChars, "UPDATE characters SET online = 0 WHERE guid = ?");
+        stmt.PExecute(guid);
 
         DEBUG_LOG("SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
@@ -490,7 +546,7 @@
 /// Kick a player out of the World
 void WorldSession::KickPlayer()
 {
-    if (!m_Socket->IsClosed())
+    if (m_Socket && !m_Socket->IsClosed())
         m_Socket->Close();
 }
 
diff -ruN mangos-classic/src/game/WorldSession.h portalclassic/src/game/WorldSession.h
--- mangos-classic/src/game/WorldSession.h	2016-06-20 09:32:04.000000000 +0200
+++ portalclassic/src/game/WorldSession.h	2016-06-20 09:28:57.000000000 +0200
@@ -150,7 +150,8 @@
         Player* GetPlayer() const { return _player; }
         char const* GetPlayerName() const;
         void SetSecurity(AccountTypes security) { _security = security; }
-        const std::string &GetRemoteAddress() const { return m_Socket->GetRemoteAddress(); }
+        //playerbot mod: player connected without socket are bot
+        const std::string GetRemoteAddress() const { return m_Socket ? m_Socket->GetRemoteAddress() : "bot"; }
         void SetPlayer(Player* plr) { _player = plr; }
 
         /// Session in auth.queue currently
diff -ruN mangos-classic/src/game/playerbot/PlayerbotAI.cpp portalclassic/src/game/playerbot/PlayerbotAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,8082 @@
+#include <stdarg.h>
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "../ItemPrototype.h"
+#include "../World.h"
+#include "../SpellMgr.h"
+#include "../GridNotifiers.h"
+#include "../GridNotifiersImpl.h"
+#include "../CellImpl.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "../Player.h"
+#include "../ObjectMgr.h"
+#include "../Chat.h"
+#include "WorldPacket.h"
+#include "../Spell.h"
+#include "../Unit.h"
+#include "../SpellAuras.h"
+#include "../SharedDefines.h"
+#include "Log.h"
+#include "../GossipDef.h"
+#include "../MotionMaster.h"
+#include "../AuctionHouseMgr.h"
+#include "../Mail.h"
+#include "../Language.h"
+#include "../LootMgr.h"
+
+// returns a float in range of..
+float rand_float(float low, float high)
+{
+    return (rand() / (static_cast<float> (RAND_MAX) + 1.0)) * (high - low) + low;
+}
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
+    bool revive(Player& botPlayer) { return HandleReviveCommand((char *) botPlayer.GetName()); }
+    bool teleport(Player& botPlayer) { return HandleNamegoCommand((char *) botPlayer.GetName()); }
+    void sysmessage(const char *str) { SendSysMessage(str); }
+    bool dropQuest(char *str) { return HandleQuestRemoveCommand(str); }
+};
+
+PlayerbotAI::PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot) :
+m_mgr(mgr), m_bot(bot), m_classAI(0), m_ignoreAIUpdatesUntilTime(CurrentTime()),
+m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVE),
+m_TimeDoneEating(0), m_TimeDoneDrinking(0),
+m_CurrentlyCastingSpellId(0), m_spellIdCommand(0),
+m_targetGuidCommand(ObjectGuid()),
+m_taxiMaster(ObjectGuid())
+{
+
+    // set bot state and needed item list
+    m_botState = BOTSTATE_NORMAL;
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+
+    // reset some pointers
+    m_targetChanged = false;
+    m_targetType = TARGET_NORMAL;
+    m_targetCombat = 0;
+    m_targetAssist = 0;
+    m_targetProtect = 0;
+
+    // set collection options
+    m_collectionFlags = 0;
+    if (m_mgr->m_confCollectCombat)
+        SetCollectFlag(COLLECT_FLAG_COMBAT);
+    if (m_mgr->m_confCollectQuest)
+        SetCollectFlag(COLLECT_FLAG_QUEST);
+    if (m_mgr->m_confCollectProfession)
+        SetCollectFlag(COLLECT_FLAG_PROFESSION);
+    if (m_mgr->m_confCollectLoot)
+        SetCollectFlag(COLLECT_FLAG_LOOT);
+    if (m_mgr->m_confCollectSkin && m_bot->HasSkill(SKILL_SKINNING))
+        SetCollectFlag(COLLECT_FLAG_SKIN);
+    if (m_mgr->m_confCollectObjects)
+        SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+
+    // start following master (will also teleport bot to master)
+    SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
+    BotDataRestore();
+    m_DelayAttackInit = CurrentTime();
+
+    // get class specific ai
+    ReloadAI();
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    if (m_classAI) delete m_classAI;
+}
+
+Player* PlayerbotAI::GetMaster() const
+{
+    return m_mgr->GetMaster();
+}
+
+bool PlayerbotAI::CanReachWithSpellAttack(Unit* target)
+{
+    bool inrange = false;
+    float dist = m_bot->GetCombatDistance(target,false);
+
+    for (SpellRanges::iterator itr = m_spellRangeMap.begin(); itr != m_spellRangeMap.end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        // ignore positive spells
+        if (IsPositiveSpell(spellId))
+            continue;
+
+        // ignore active auras
+        if (target->HasAura(spellId, EFFECT_INDEX_0))
+            continue;
+
+        const SpellEntry* spellInfo = sSpellStore.LookupEntry(spellId);
+        if (!spellInfo)
+            continue;
+
+        // ignore non-ranged spells
+        if (!spellInfo->HasAttribute(SPELL_ATTR_RANGED))
+            continue;
+
+        float maxrange = itr->second;
+
+        // DEBUG_LOG("[%s] spell (%s) : dist (%f) < maxrange (%f)",m_bot->GetName(), spellInfo->SpellName[0], dist, maxrange);
+
+        if (dist < maxrange)
+        {
+            inrange = true;
+            break;
+        }
+    }
+    return inrange;
+}
+
+bool PlayerbotAI::In_Reach(Unit* Target, uint32 spellId)
+{
+    if (!Target)
+        return false;
+
+    float range = 0;
+    float dist = m_bot->GetCombatDistance(Target,false);
+    SpellRanges::iterator it;
+    it = m_spellRangeMap.find(spellId);
+    (it != m_spellRangeMap.end()) ? range = it->second : range = 0;
+
+    // DEBUG_LOG("spell (%u) : range (%f)", spellId, range);
+
+    if (dist > range)
+        return false;
+
+    return true;
+}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if (master)
+        loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    else
+        loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+            continue;
+
+        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+
+uint32 PlayerbotAI::getPetSpellId(const char* args) const
+{
+    if (!*args)
+        return 0;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
+            continue;
+
+        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+
+uint32 PlayerbotAI::initSpell(uint32 spellId)
+{
+    // Check if bot knows this spell
+    if (!m_bot->HasSpell(spellId))
+        return 0;
+
+    uint32 next = 0;
+    SpellChainMapNext const& nextMap = sSpellMgr.GetSpellChainNext();
+    for (SpellChainMapNext::const_iterator itr = nextMap.lower_bound(spellId); itr != nextMap.upper_bound(spellId); ++itr)
+    {
+        // Work around buggy chains
+        if (sSpellStore.LookupEntry(spellId)->SpellIconID != sSpellStore.LookupEntry(itr->second)->SpellIconID)
+            continue;
+
+        SpellChainNode const* node = sSpellMgr.GetSpellChainNode(itr->second);
+        // If next spell is a requirement for this one then skip it
+        if (node->req == spellId)
+            continue;
+        if (node->prev == spellId)
+        {
+            next = initSpell(itr->second);
+            break;
+        }
+    }
+    if (next == 0)
+    {
+        const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+        DEBUG_LOG ("[PlayerbotAI]: initSpell - Playerbot spell init: %s is %u", pSpellInfo->SpellName[0], spellId);
+
+        // Add spell to spellrange map
+        Spell *spell = new Spell(m_bot, pSpellInfo, false);
+        SpellRangeEntry const* srange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
+        float range = GetSpellMaxRange(srange);
+        if (Player* modOwner = m_bot->GetSpellModOwner())
+            modOwner->ApplySpellMod(pSpellInfo->Id, SPELLMOD_RANGE, range, spell);
+        m_spellRangeMap.insert(std::pair<uint32, float>(spellId, range));
+        delete spell;
+    }
+    return (next == 0) ? spellId : next;
+}
+
+
+// Pet spells do not form chains like player spells.
+// One of the options to initialize a spell is to use spell icon id
+uint32 PlayerbotAI::initPetSpell(uint32 spellIconId)
+{
+    Pet * pet = m_bot->GetPet();
+
+    if (!pet)
+        return 0;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
+            continue;
+
+        const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (pSpellInfo->SpellIconID == spellIconId)
+            return spellId;
+    }
+
+    // Nothing found
+    return 0;
+}
+
+/*
+ * Send a list of equipment that is in bot's inventor that is currently unequipped.
+ * This is called when the master is inspecting the bot.
+ */
+
+void PlayerbotAI::SendNotEquipList(Player& /*player*/)
+{
+    // find all unequipped items and put them in
+    // a vector of dynamically created lists where the vector index is from 0-18
+    // and the list contains Item* that can be equipped to that slot
+    // Note: each dynamically created list in the vector must be deleted at end
+    // so NO EARLY RETURNS!
+    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+    std::list<Item*>* equip[19];
+    for (uint8 i = 0; i < 19; ++i)
+        equip[i] = nullptr;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == nullptr)
+            equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                // create a list if one doesn't already exist
+                if (equip[equipSlot] == nullptr)
+                    equip[equipSlot] = new std::list<Item*>;
+
+                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip.");
+    ChatHandler ch(GetMaster());
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+                                  "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+                                  "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
+                                  "tabard" };
+
+    // now send client all items that can be equipped by slot
+    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if (equip[equipSlot] == nullptr)
+            continue;
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            const ItemPrototype* const pItemProto = (*it)->GetProto();
+
+            std::string itemName = pItemProto->Name1;
+            ItemLocalization(itemName, pItemProto->ItemId);
+
+            out << " |cffffffff|Hitem:" << pItemProto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+
+        delete itemListForEqSlot; // delete list of Item*
+    }
+}
+
+void PlayerbotAI::SendQuestNeedList()
+{
+    std::ostringstream out;
+
+    for (BotNeedItem::iterator itr = m_needItemList.begin(); itr != m_needItemList.end(); ++itr)
+    {
+        ItemPrototype const* pItemProto = sObjectMgr.GetItemPrototype(itr->first);
+        if(pItemProto)
+        {
+            std::string itemName = pItemProto->Name1;
+            ItemLocalization(itemName, pItemProto->ItemId);
+
+            out << " " << itr->second << "x|cffffffff|Hitem:" << pItemProto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+    }
+
+    for (BotNeedItem::iterator itr = m_needCreatureOrGOList.begin(); itr != m_needCreatureOrGOList.end(); ++itr)
+    {
+        CreatureInfo const* cInfo = ObjectMgr::GetCreatureTemplate(itr->first);
+        if (cInfo)
+        {
+            std::string creatureName = cInfo->Name;
+            CreatureLocalization(creatureName, cInfo->Entry);
+            out << " " << itr->second << "x|cFFFFFF00|Hcreature_entry:" << itr->first << "|h[" << creatureName << "]|h|r";
+        }
+
+        if (m_bot->HasQuestForGO(itr->first))
+        {
+            GameObjectInfo const* gInfo = ObjectMgr::GetGameObjectInfo(itr->first);
+            if (gInfo)
+            {
+                std::string gameobjectName = gInfo->name;
+                GameObjectLocalization(gameobjectName, gInfo->id);
+                out << " " << itr->second << "x|cFFFFFF00|Hgameobject_entry:" << itr->first << "|h[" << gameobjectName << "]|h|r";
+            }
+        }
+    }
+
+    TellMaster("Here's a list of all things needed for quests:");
+    if (!out.str().empty())
+        TellMaster(out.str().c_str());
+}
+
+bool PlayerbotAI::IsItemUseful(uint32 itemid)
+{
+    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
+    {
+        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
+        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
+        SKILL_STAVES,   0,              0,                   SKILL_UNARMED,   0,
+        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
+        SKILL_FISHING
+    };
+
+    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
+    {
+        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0
+    };
+
+    ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(itemid);
+    if (!pProto || pProto->Quality < ITEM_QUALITY_NORMAL)
+        return false;
+
+    // do we already have the max allowed of item if more than zero?
+    if (pProto->MaxCount > 0 && m_bot->HasItemCount(itemid, pProto->MaxCount, true))
+        return false;
+
+    // quest related items
+    if (pProto->StartQuest > 0 && HasCollectFlag(COLLECT_FLAG_QUEST))
+        return true;
+
+    switch (pProto->Class)
+    {
+        case ITEM_CLASS_WEAPON:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_WEAPON)
+                return false;
+            else
+                return m_bot->HasSkill(item_weapon_skills[pProto->SubClass]);
+                break;
+        case ITEM_CLASS_ARMOR:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_ARMOR)
+                return false;
+            else
+                return (m_bot->HasSkill(item_armor_skills[pProto->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto->SubClass+1]));
+                break;
+        case ITEM_CLASS_QUEST:
+            if (!HasCollectFlag(COLLECT_FLAG_QUEST))
+                break;
+        case ITEM_CLASS_KEY:
+            return true;
+        case ITEM_CLASS_TRADE_GOODS:
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_PARTS:
+                case ITEM_SUBCLASS_EXPLOSIVES:
+                case ITEM_SUBCLASS_DEVICES:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_CLOTH:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_LEATHER:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_METAL_STONE:
+                    if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                        m_bot->HasSkill(SKILL_ENGINEERING) ||
+                        m_bot->HasSkill(SKILL_MINING)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_MEAT:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_HERB:
+                    if ((m_bot->HasSkill(SKILL_HERBALISM) ||
+                        m_bot->HasSkill(SKILL_ALCHEMY)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ELEMENTAL:
+                    return true;    // pretty much every profession uses these a bit
+                case ITEM_SUBCLASS_ENCHANTING:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case ITEM_CLASS_RECIPE:
+        {
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            // skip recipes that we have
+            if (m_bot->HasSpell(pProto->Spells[2].SpellId))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_TAILORING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_BLACKSMITHING:
+                    if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_COOKING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                    if (m_bot->HasSkill(SKILL_ALCHEMY))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FIRST_AID))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FISHING_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FISHING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+        }
+        default:
+            break;
+    }
+
+    return false;
+}
+
+void PlayerbotAI::ReloadAI()
+{
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_MAGE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
+            {
+                m_combatStyle = COMBAT_MELEE;
+            }
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
+            {
+                m_combatStyle = COMBAT_MELEE;
+            }
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(GetMaster(), m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+}
+
+void PlayerbotAI::SendOrders(Player& /*player*/)
+{
+    std::ostringstream out;
+
+    if (!m_combatOrder)
+        out << "Got no combat orders!";
+    else if (m_combatOrder & ORDERS_TANK)
+        out << "I TANK";
+    else if (m_combatOrder & ORDERS_ASSIST)
+        out << "I ASSIST " << (m_targetAssist ? m_targetAssist->GetName() : "unknown");
+    else if (m_combatOrder & ORDERS_HEAL)
+        out << "I HEAL and DISPEL";
+    else if (m_combatOrder & ORDERS_NODISPEL)
+        out << "I HEAL and WON'T DISPEL";
+    else if (m_combatOrder & ORDERS_PASSIVE)
+        out << "I'm PASSIVE";
+    if ((m_combatOrder & ORDERS_PRIMARY) && (m_combatOrder & (ORDERS_PROTECT | ORDERS_RESIST)))
+    {
+        out << " and ";
+        if (m_combatOrder & ORDERS_PROTECT)
+                out << "I PROTECT " << (m_targetProtect ? m_targetProtect->GetName() : "unknown");
+        if (m_combatOrder & ORDERS_RESIST)
+        {
+            if (m_combatOrder & ORDERS_RESIST_FIRE)
+                out << "I RESIST FIRE";
+            if (m_combatOrder & ORDERS_RESIST_NATURE)
+                out << "I RESIST NATURE";
+            if (m_combatOrder & ORDERS_RESIST_FROST)
+                out << "I RESIST FROST";
+            if (m_combatOrder & ORDERS_RESIST_SHADOW)
+                out << "I RESIST SHADOW";
+        }
+    }
+    out << ".";
+
+    if (m_mgr->m_confDebugWhisper)
+    {
+        out << " " << (IsInCombat() ? "I'm in COMBAT! " : "Not in combat. ");
+        out << "Current state is ";
+        if (m_botState == BOTSTATE_NORMAL)
+            out << "NORMAL";
+        else if (m_botState == BOTSTATE_COMBAT)
+            out << "COMBAT";
+        else if (m_botState == BOTSTATE_DEAD)
+            out << "DEAD";
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+            out << "RELEASED";
+        else if (m_botState == BOTSTATE_LOOTING)
+            out << "LOOTING";
+        else if (m_botState == BOTSTATE_FLYING)
+            out << "FLYING";
+        out << ". Movement order is ";
+        if (m_movementOrder == MOVEMENT_NONE)
+            out << "NONE";
+        else if (m_movementOrder == MOVEMENT_FOLLOW)
+            out << "FOLLOW " << (m_followTarget ? m_followTarget->GetName() : "unknown");
+        else if (m_movementOrder == MOVEMENT_STAY)
+            out << "STAY";
+        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
+        out << " Next action in " << (m_ignoreAIUpdatesUntilTime - time(0)) << "sec.";
+    }
+
+    TellMaster(out.str().c_str());
+    if (m_DelayAttack)
+        TellMaster("My combat delay is '%u'", m_DelayAttack);
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        case SMSG_DUEL_WINNER:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+        }
+        case SMSG_DUEL_COMPLETE:
+        {
+            SetIgnoreUpdateTime(4);
+            m_ScenarioType = SCENARIO_PVE;
+            ReloadAI();
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+        }
+        case SMSG_DUEL_OUTOFBOUNDS:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+        }
+        case SMSG_DUEL_REQUESTED:
+        {
+            SetIgnoreUpdateTime(0);
+            WorldPacket p(packet);
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+            Player* const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if (canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+                // follow target in casting range
+                float angle = rand_float(0, M_PI_F);
+                float dist = rand_float(4, 10);
+
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelectionGuid(ObjectGuid(playerGuid));
+                SetIgnoreUpdateTime(4);
+                m_ScenarioType = SCENARIO_PVP_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_AUCTION_COMMAND_RESULT:
+        {
+            uint32 auctionId, Action, ErrorCode;
+            std::string action[3] = {"Creating", "Cancelling", "Bidding"};
+            std::ostringstream out;
+
+            WorldPacket p(packet);
+            p >> auctionId;
+            p >> Action;
+            p >> ErrorCode;
+            p.resize(12);
+
+            switch (ErrorCode)
+            {
+                case AUCTION_OK:
+                {
+                    out << "|cff1eff00|h" << action[Action] << " was successful|h|r";
+                    break;
+                }
+                case AUCTION_ERR_DATABASE:
+                {
+                    out << "|cffff0000|hWhile" << action[Action] << ", an internal error occured|h|r";
+                    break;
+                }
+                case AUCTION_ERR_NOT_ENOUGH_MONEY:
+                {
+                    out << "|cffff0000|hWhile " << action[Action] << ", I didn't have enough money|h|r";
+                    break;
+                }
+                case AUCTION_ERR_ITEM_NOT_FOUND:
+                {
+                    out << "|cffff0000|hItem was not found!|h|r";
+                    break;
+                }
+                case AUCTION_ERR_BID_OWN:
+                {
+                    out << "|cffff0000|hI cannot bid on my own auctions!|h|r";
+                    break;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 err;
+            p >> err;
+
+            if (m_inventory_full)
+                return;
+
+            m_inventory_full = true;
+
+            if (err != EQUIP_ERR_OK)
+            {
+                switch (err)
+                {
+                    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+                        TellMaster("I can't carry anymore of those.");
+                        return;
+                    case EQUIP_ERR_MISSING_REAGENT:
+                        TellMaster("I'm missing some reagents for that.");
+                        return;
+                    case EQUIP_ERR_ITEM_LOCKED:
+                        TellMaster("That item is locked.");
+                        return;
+                    case EQUIP_ERR_ALREADY_LOOTED:
+                        TellMaster("That is already looted.");
+                        return;
+                    case EQUIP_ERR_INVENTORY_FULL:
+                        TellMaster("My inventory is full.");
+                        return;
+                    case EQUIP_ERR_NOT_IN_COMBAT:
+                        TellMaster("I can't use that in combat.");
+                        return;
+                    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+                        TellMaster("I can't get that now.");
+                        return;
+                    case EQUIP_ERR_BANK_FULL:
+                        TellMaster("My bank is full.");
+                        return;
+                    case EQUIP_ERR_ITEM_NOT_FOUND:
+                        TellMaster("I can't find the item.");
+                        return;
+                    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+                        TellMaster("I'm too far from the bank.");
+                        return;
+                    default:
+                        TellMaster("I can't use that.");
+                        DEBUG_LOG ("[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_INVENTORY_CHANGE_FAILURE: %u", err);
+                        return;
+                }
+            }
+        }
+
+/*        case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            uint32 spellId;
+            uint8 result;
+            // uint8 castCount;
+
+            p.hexlike();
+
+            p >> spellId >> result;
+            p.resize(5);
+
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spellId);
+            if (!spellInfo)
+                return;
+
+            if (result != SPELL_CAST_OK)
+            {
+                switch (result)
+                {
+                    case SPELL_FAILED_INTERRUPTED:
+                    {
+                        DEBUG_LOG("spell %s interrupted (%u)",spellInfo->SpellName[0], result);
+                        return;
+                    }
+                    case SPELL_FAILED_BAD_TARGETS:
+                    {
+                        // DEBUG_LOG("[%s]bad target (%u) for spellId (%u) & m_CurrentlyCastingSpellId (%u)",m_bot->GetName(),result,spellId,m_CurrentlyCastingSpellId);
+                        Spell* const pSpell = GetCurrentSpell();
+                        if (pSpell)
+                            pSpell->cancel();
+                        return;
+                    }
+                    default:
+                        //DEBUG_LOG ("[%s] SMSG_CAST_FAIL: %s err (%u)", m_bot->GetName(), spellInfo->SpellName[0],result);
+                        return;
+                }
+            }
+            return;
+        } */
+
+/*        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            ObjectGuid casterGuid;
+
+            p >> casterGuid.ReadAsPacked();
+            if (casterGuid != m_bot->GetObjectGuid())
+                return;
+
+            p >> castCount >> spellId;
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                SetIgnoreUpdateTime(0);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+*/
+        // if a change in speed was detected for the master
+        // make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            ObjectGuid guid;
+
+            p >> guid.ReadAsPacked();
+            if (guid != GetMaster()->GetObjectGuid())
+                return;
+            if (GetMaster()->IsMounted() && !m_bot->IsMounted())
+            {
+                //Player Part
+                if (!GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).empty())
+                {
+                    int32 master_speed1 = 0;
+                    int32 master_speed2 = 0;
+                    master_speed1 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[1];
+                    master_speed2 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[2];
+
+                    //Bot Part
+                    uint32 spellMount = 0;
+                    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                    {
+                        uint32 spellId = itr->first;
+                        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+                            continue;
+                        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+                        if (!pSpellInfo)
+                            continue;
+
+                        if (pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+                        {
+                            if (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                            {
+                                if (pSpellInfo->EffectBasePoints[1] == master_speed1)
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                            else if (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                if (pSpellInfo->EffectBasePoints[2] == master_speed2)
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                        }
+                    }
+                    if (spellMount > 0) m_bot->CastSpell(m_bot, spellMount, false);
+                }
+            }
+            else if (!GetMaster()->IsMounted() && m_bot->IsMounted())
+            {
+                WorldPacket emptyPacket;
+                m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+            }
+            return;
+        }
+
+        // If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name;
+            p >> name;
+            if (m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if (m_bot->GetGroup()->IsMember(GetMaster()->GetObjectGuid()))
+                {
+                    p.resize(8);
+                    p << GetMaster()->GetObjectGuid();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                }
+                else
+                {
+                    p.clear(); // not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+                }
+            }
+            return;
+        }
+
+        // If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation;
+            p >> operation;
+            std::string member;
+            p >> member;
+            uint32 result;
+            p >> result;
+            p.clear();
+            if (operation == PARTY_OP_LEAVE)
+                if (member == GetMaster()->GetName())
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p);  // packet not used updated code
+            return;
+        }
+
+        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
+        case SMSG_GROUP_INVITE:
+        {
+            if (m_bot->GetGroupInvite())
+            {
+                const Group* const grp = m_bot->GetGroupInvite();
+                if (!grp)
+                    return;
+
+                Player* const inviter = sObjectMgr.GetPlayer(grp->GetLeaderGuid());
+                if (!inviter)
+                    return;
+
+                WorldPacket p;
+                if (!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += GetMaster()->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+                }
+                else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
+            }
+            return;
+        }
+
+        // Handle when another player opens the trade window with the bot
+        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if (m_bot->GetTrader() == nullptr)
+                break;
+
+            WorldPacket p(packet);
+            uint32 status;
+            p >> status;
+            p.resize(4);
+
+            //4 == TRADE_STATUS_TRADE_ACCEPT
+            if (status == 4)
+            {
+                m_bot->GetSession()->HandleAcceptTradeOpcode(p);  // packet not used
+                SetQuestNeedItems();
+            }
+
+            //1 == TRADE_STATUS_BEGIN_TRADE
+            else if (status == 1)
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
+                {
+                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    return;
+                }
+
+                // list out items available for trade
+                std::ostringstream out;
+
+                out << "In my main backpack:";
+                // list out items in main backpack
+                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if (pItem)
+                        MakeItemLink(pItem, out, true);
+                }
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+
+                // list out items in other removable backpacks
+                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if (pBag)
+                    {
+                        std::ostringstream outbag;
+                        outbag << "In my ";
+                        const ItemPrototype* const pBagProto = pBag->GetProto();
+                        std::string bagName = pBagProto->Name1;
+                        ItemLocalization(bagName, pBagProto->ItemId);
+                        outbag << bagName << ":";
+
+                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                            if (pItem)
+                                MakeItemLink(pItem, outbag, true);
+                        }
+                        ch.SendSysMessage(outbag.str().c_str());
+                    }
+                }
+
+                // calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                // send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                        << "|r|cfffffc00g|r|cff00ff00" << silver
+                        << "|r|cffcdcdcds|r|cff00ff00" << copper
+                        << "|r|cffffd333c|r";
+                SendWhisper(whisper.str().c_str(), *(m_bot->GetTrader()));
+            }
+            return;
+        }
+
+        case SMSG_SPELL_START:
+        {
+
+            WorldPacket p(packet);
+
+            ObjectGuid castItemGuid;
+            p >> castItemGuid.ReadAsPacked();
+            ObjectGuid casterGuid;
+            p >> casterGuid.ReadAsPacked();
+            if (casterGuid != m_bot->GetObjectGuid())
+                return;
+
+            uint32 spellId;
+            p >> spellId;
+            uint16 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            // DEBUG_LOG("castItemGuid (%s) casterItemGuid(%s) spellId (%u) castFlags (%u) msTime (%u)",castItemGuid.GetString().c_str(),casterGuid.GetString().c_str(), spellId, castFlags, msTime);
+
+            const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                return;
+
+            if (pSpellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+                return;
+
+            uint32 CastingTime = !IsChanneledSpell(pSpellInfo) ? GetSpellCastTime(pSpellInfo) : GetSpellDuration(pSpellInfo);
+
+            SetIgnoreUpdateTime((msTime / 1000) + 1);
+
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+
+            ObjectGuid castItemGuid;
+            p >> castItemGuid.ReadAsPacked();
+            ObjectGuid casterGuid;
+            p >> casterGuid.ReadAsPacked();
+            if (casterGuid != m_bot->GetObjectGuid())
+                return;
+
+            uint32 spellId;
+            p >> spellId;
+            uint16 castFlags;
+            p >> castFlags;
+
+            return;
+        }
+
+        // if someone tries to resurrect, then accept
+        case SMSG_RESURRECT_REQUEST:
+        {
+            if (!m_bot->isAlive())
+            {
+                WorldPacket p(packet);
+                ObjectGuid guid;
+                p >> guid;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8 + 1);
+                *packet << guid;
+                *packet << uint8(1);                        // accept
+                m_bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+                // set back to normal
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            return;
+        }
+
+        case SMSG_LOOT_RESPONSE:
+        {
+            WorldPacket p(packet); // (8+1+4+1+1+4+4+4+4+4+1)
+            ObjectGuid guid;
+            uint8 loot_type;
+
+            p >> guid;      // 8 corpse guid
+            p >> loot_type; // 1 loot type
+
+            // Create the loot object and check it exists
+            Loot* loot = sLootMgr.GetLoot(m_bot, guid);
+            if (!loot)
+            {
+                sLog.outError("PLAYERBOT Debug Error cannot get loot object info in SMSG_LOOT_RESPONSE!");
+                return;
+            }
+
+            // Pickup money
+            if (loot->GetGoldAmount())
+                loot->SendGold(m_bot);
+
+            // Pick up the items
+            // Get the list of items first and iterate it
+            LootItemList lootList;
+            loot->GetLootItemsListFor(m_bot, lootList);
+
+            for (LootItemList::const_iterator lootItr = lootList.begin(); lootItr != lootList.end(); ++lootItr)
+            {
+                LootItem* lootItem = *lootItr;
+
+                // Skip non lootable items
+                if (lootItem->GetSlotTypeForSharedLoot(m_bot, loot) != LOOT_SLOT_NORMAL)
+                    continue;
+
+                // If bot is skinning or has collect all orders: autostore all items
+                // else bot has order to only loot quest or useful items
+                if (loot_type == LOOT_SKINNING || HasCollectFlag(COLLECT_FLAG_LOOT) || (loot_type == LOOT_CORPSE && (IsInQuestItemList(lootItem->itemId) || IsItemUseful(lootItem->itemId))))
+                {
+                    // item may be blocked by roll system or already looted or another cheating possibility
+                    if (lootItem->isBlocked || lootItem->GetSlotTypeForSharedLoot(m_bot, loot) == MAX_LOOT_SLOT_TYPE)
+                    {
+                        sLog.outError("PLAYERBOT debug Bot %s have no right to loot itemId(%u)", m_bot->GetGuidStr().c_str(), lootItem->itemId);
+                        continue;
+                    }
+
+                    // Try to send the item to bot
+                    InventoryResult result = loot->SendItem(m_bot, lootItem);
+
+                    // If inventory is full: release loot
+                    if (result == EQUIP_ERR_INVENTORY_FULL)
+                    {
+                        loot->Release(m_bot);
+                        return;
+                    }
+
+                    ObjectGuid const& lguid = loot->GetLootGuid();
+
+                    // Check that bot has either equiped or received the item
+                    // then change item's loot state
+                    if (result == EQUIP_ERR_OK && lguid.IsItem())
+                    {
+                        if (Item* item = m_bot->GetItemByGuid(lguid))
+                            item->SetLootState(ITEM_LOOT_CHANGED);
+                    }
+                }
+            }
+
+            // release loot
+            loot->Release(m_bot);
+
+            return;
+        }
+
+        case SMSG_LOOT_RELEASE_RESPONSE:
+        {
+            WorldPacket p(packet);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (guid == m_lootCurrent)
+            {
+                Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+
+                if (c && c->GetCreatureInfo()->SkinningLootId && !c->GetLootStatus() != CREATURE_LOOT_STATUS_LOOTED)
+                {
+                    uint32 reqSkill = c->GetCreatureInfo()->GetRequiredLootSkill();
+                    // check if it is a leather skin and if it is to be collected (could be ore or herb)
+                    if (m_bot->HasSkill(reqSkill) && ((reqSkill != SKILL_SKINNING) ||
+                                                      (HasCollectFlag(COLLECT_FLAG_SKIN) && reqSkill == SKILL_SKINNING)))
+                    {
+                        // calculate skill requirement
+                        uint32 skillValue = m_bot->GetPureSkillValue(reqSkill);
+                        uint32 targetLevel = c->getLevel();
+                        uint32 reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                        if (skillValue >= reqSkillValue)
+                        {
+                            if (m_lootCurrent != m_lootPrev)    // if this wasn't previous loot try again
+                            {
+                                m_lootPrev = m_lootCurrent;
+                                SetIgnoreUpdateTime();
+                                return; // so that the DoLoot function is called again to get skin
+                            }
+                        }
+                        else
+                            TellMaster("My skill is %u but it requires %u", skillValue, reqSkillValue);
+                    }
+                }
+
+                // if previous is current, clear
+                if (m_lootPrev == m_lootCurrent)
+                    m_lootPrev = ObjectGuid();
+                // clear current target
+                m_lootCurrent = ObjectGuid();
+                // clear movement
+                m_bot->GetMotionMaster()->Clear(false);
+                m_bot->GetMotionMaster()->MoveIdle();
+                SetIgnoreUpdateTime();
+            }
+
+            return;
+        }
+
+        case SMSG_LOOT_ROLL_WON:
+        {
+            WorldPacket p(packet);   // (8+4+4+4+4+8+1+1)
+            ObjectGuid guid;
+            uint32 itemid;
+
+            p.read_skip<ObjectGuid>(); // creature guid what we're looting
+            p.read_skip<uint32>();   // item slot in loot
+            p >> itemid;             // the itemEntryId for the item that shall be rolled fo
+            p.read_skip<uint32>();   // randomSuffix
+            p.read_skip<uint32>();   // Item random property
+            p >> guid;               // guid of the player who won
+            p.read_skip<uint8>();    // rollnumber related to SMSG_LOOT_ROLL
+            p.read_skip<uint8>();    // Rolltype related to SMSG_LOOT_ROLL
+
+            if (m_bot->GetObjectGuid() != guid)
+                return;
+
+            SetState(BOTSTATE_DELAYED);
+
+            /* ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(itemid);
+            if(pProto)
+            {
+                std::ostringstream out;
+                out << "|cff009900" << "I won: |r";
+                MakeItemLink(pProto,out);
+                if (FindItem(itemid,true))
+                    out << "and have the item";
+                TellMaster(out.str().c_str());
+            }*/
+            return;
+        }
+
+        case SMSG_PARTYKILLLOG:
+        {
+            // reset AI delay so bots immediately respond to next combat target & or looting/skinning
+            SetIgnoreUpdateTime(0);
+            return;
+        }
+
+        case SMSG_ITEM_PUSH_RESULT:
+        {
+            WorldPacket p(packet);  // (8+4+4+4+1+4+4+4+4+4+4)
+            ObjectGuid guid;
+
+            p >> guid;              // 8 player guid
+            if (m_bot->GetObjectGuid() != guid)
+                return;
+
+            uint8 bagslot;
+            uint32 itemslot, itemid, count, totalcount;
+
+            p.read_skip<uint32>();  // 4 0=looted, 1=from npc
+            p.read_skip<uint32>();  // 4 0=received, 1=created
+            p.read_skip<uint32>();  // 4 IsShowChatMessage
+            p >> bagslot;           // 1 bagslot
+            p >> itemslot;          // 4 item slot, but when added to stack: 0xFFFFFFFF
+            p >> itemid;            // 4 item entry id
+            p.read_skip<uint32>();  // 4 SuffixFactor
+            p.read_skip<uint32>();  // 4 random item property id
+            p >> count;             // 4 count of items
+            p >> totalcount;        // 4 count of items in inventory
+
+            if (IsInQuestItemList(itemid))
+            {
+                m_needItemList[itemid] = (m_needItemList[itemid] - count);
+                if (m_needItemList[itemid] <= 0)
+                    m_needItemList.erase(itemid);
+            }
+
+            return;
+        }
+
+        /* uncomment this and your bots will tell you all their outgoing packet opcode names
+           case SMSG_MONSTER_MOVE:
+           case SMSG_UPDATE_WORLD_STATE:
+           case SMSG_COMPRESSED_UPDATE_OBJECT:
+           case MSG_MOVE_SET_FACING:
+           case MSG_MOVE_STOP:
+           case MSG_MOVE_HEARTBEAT:
+           case MSG_MOVE_STOP_STRAFE:
+           case MSG_MOVE_START_STRAFE_LEFT:
+           case SMSG_UPDATE_OBJECT:
+           case MSG_MOVE_START_FORWARD:
+           case MSG_MOVE_START_STRAFE_RIGHT:
+           case SMSG_DESTROY_OBJECT:
+           case MSG_MOVE_START_BACKWARD:
+           case SMSG_AURA_UPDATE_ALL:
+           case MSG_MOVE_FALL_LAND:
+           case MSG_MOVE_JUMP:
+            return;*/
+
+        default:
+        {
+            /*const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+            std::ostringstream out;
+            out << "botout: " << oc;
+            sLog.outError(out.str().c_str());
+
+            TellMaster(oc);*/
+        }
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
+{
+    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return (100);
+    else
+        return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
+{
+    if (spellId <= 0)
+        return false;
+
+    for (Unit::SpellAuraHolderMap::const_iterator iter = player.GetSpellAuraHolderMap().begin(); iter != player.GetSpellAuraHolderMap().end(); ++iter)
+    {
+        if (iter->second->GetId() == spellId)
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasAura(const char* spellName) const
+{
+    return HasAura(spellName, *m_bot);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return (spellId) ? HasAura(spellId, player) : false;
+}
+
+// looks through all items / spells that bot could have to get a mount
+Item* PlayerbotAI::FindMount(uint32 matchingRidingSkill) const
+{
+    // list out items in main backpack
+
+    Item* partialMatch = nullptr;
+
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK || pItemProto->RequiredSkill != SKILL_RIDING)
+                continue;
+
+            if (pItemProto->RequiredSkillRank == matchingRidingSkill)
+                return pItem;
+
+            else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
+                partialMatch = pItem;
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK || pItemProto->RequiredSkill != SKILL_RIDING)
+                        continue;
+
+                    if (pItemProto->RequiredSkillRank == matchingRidingSkill)
+                        return pItem;
+
+                    else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
+                        partialMatch = pItem;
+                }
+            }
+    }
+    return partialMatch;
+}
+
+Item* PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE)
+                // if is FOOD
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 11
+                if (pItemProto->Spells[0].SpellCategory == 11)
+                    return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    // this enum is no longer defined in mangos. Is it no longer valid?
+                    // according to google it was 11
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE)
+                        // if is FOOD
+                        // this enum is no longer defined in mangos. Is it no longer valid?
+                        // according to google it was 11
+                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                        if (pItemProto->Spells[0].SpellCategory == 11)
+                            return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE)
+                // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 59
+                // if (pItemProto->Spells[0].SpellCategory == 59)
+                if (pItemProto->Spells[0].SpellCategory == 59)
+                    return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE)
+                        // if is WATER
+                        // SPELL_CATEGORY_DRINK is no longer defined in an enum in mangos
+                        // google says the valus is 59. Is this still valid?
+                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+                        if (pItemProto->Spells[0].SpellCategory == 59)
+                            return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindBandage() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                        return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == 6)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == 6)
+                        return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindConsumable(uint32 displayId) const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                        return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+bool PlayerbotAI::FindAmmo() const
+{
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item* pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem)
+        {
+           const ItemPrototype* const pItemProto = pItem->GetProto();
+
+           if (pItemProto->Class == ITEM_CLASS_PROJECTILE && m_bot->CheckAmmoCompatibility(pItemProto))
+           {
+                m_bot->SetAmmo(pItem->GetEntry());
+                return true;
+           }
+        }
+    }
+    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (Bag* pBag = (Bag*)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+        {
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+            {
+                Item* pItem = m_bot->GetItemByPos(i, j);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (pItemProto->Class == ITEM_CLASS_PROJECTILE && m_bot->CheckAmmoCompatibility(pItemProto))
+                    {
+                        m_bot->SetAmmo(pItem->GetEntry());
+                        return true;
+                    }
+                }
+            }
+        }
+    }
+    return false;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);  //changed from thetourist suggestion
+    *packet << m_CurrentlyCastingSpellId;
+    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::Attack(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_lootCurrent = ObjectGuid();
+        m_targetCombat = 0;
+        m_DelayAttackInit = CurrentTime(); // Combat started, new start time to check CombatDelay for.
+    }
+
+    GetCombatTarget(forcedTarget);
+
+    if (!m_targetCombat)
+        return;
+
+    m_bot->Attack(m_targetCombat, true);
+
+    // add thingToAttack to loot list
+    m_lootTargets.push_back(m_targetCombat->GetObjectGuid());
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatTarget(Unit* forcedTarget)
+{
+    // update attacker info now
+    UpdateAttackerInfo();
+
+    // check for attackers on protected unit, and make it a forcedTarget if any
+    if (!forcedTarget && (m_combatOrder & ORDERS_PROTECT) && m_targetProtect)
+    {
+        Unit* newTarget = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_HIGHESTTHREAT), m_targetProtect);
+        if (newTarget && newTarget != m_targetCombat)
+        {
+            forcedTarget = newTarget;
+            m_targetType = TARGET_THREATEN;
+            if (m_mgr->m_confDebugWhisper)
+                TellMaster("Changing target to %s to protect %s", forcedTarget->GetName(), m_targetProtect->GetName());
+        }
+    }
+    else if (forcedTarget)
+    {
+        if (m_mgr->m_confDebugWhisper)
+            TellMaster("Changing target to %s by force!", forcedTarget->GetName());
+        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+    }
+
+    // we already have a target and we are not forced to change it
+    if (m_targetCombat && !forcedTarget)
+        return;
+
+    // forced to change target to current target == null operation
+    if (forcedTarget && forcedTarget == m_targetCombat)
+        return;
+
+    // are we forced on a target?
+    if (forcedTarget)
+    {
+        m_targetCombat = forcedTarget;
+        m_targetChanged = true;
+    }
+    // do we have to assist someone?
+    if (!m_targetCombat && (m_combatOrder & ORDERS_ASSIST) && m_targetAssist)
+    {
+        m_targetCombat = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_LOWESTTHREAT), m_targetAssist);
+        if (m_mgr->m_confDebugWhisper && m_targetCombat)
+            TellMaster("Attacking %s to assist %s", m_targetCombat->GetName(), m_targetAssist->GetName());
+        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // are there any other attackers?
+    if (!m_targetCombat)
+    {
+        m_targetCombat = FindAttacker();
+        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // no attacker found anyway
+    if (!m_targetCombat)
+    {
+        m_targetType = TARGET_NORMAL;
+        m_targetChanged = false;
+        return;
+    }
+
+    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    // this method never gets called when the bot is in a duel and this code
+    // prevents bot from helping
+    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && dynamic_cast<Player*> (m_targetCombat)->duel)
+    {
+        SetIgnoreUpdateTime(6);
+        return;
+    }
+
+    m_bot->SetSelectionGuid((m_targetCombat->GetObjectGuid()));
+    SetIgnoreUpdateTime(1);
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+void PlayerbotAI::GetDuelTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_targetChanged = true;
+        m_targetCombat = forcedTarget;
+        m_targetType = TARGET_THREATEN;
+        m_combatStyle = COMBAT_MELEE;
+    }
+    m_bot->Attack(m_targetCombat, true);
+}
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if (!GetClassAI())
+        return; // error, error...
+
+    if (m_combatOrder == ORDERS_PASSIVE)
+        return;
+
+    // check for new targets
+    if (m_ScenarioType == SCENARIO_PVP_DUEL)
+        GetDuelTarget(GetMaster()); // TODO: Wow... wait... what? So not right.
+    else
+        Attack();
+
+    // clear orders if current target for attacks doesn't make sense anymore
+    if (!m_targetCombat || m_targetCombat->isDead() || !m_targetCombat->IsInWorld() || !m_bot->IsHostileTo(m_targetCombat) || !m_bot->IsInMap(m_targetCombat))
+    {
+        m_bot->AttackStop();
+        m_bot->SetSelectionGuid(ObjectGuid());
+        MovementReset();
+        m_bot->InterruptNonMeleeSpells(true);
+        m_targetCombat = 0;
+        m_targetChanged = false;
+        m_targetType = TARGET_NORMAL;
+        SetQuestNeedCreatures();
+        if (GetCombatOrder() & ORDERS_TEMP)
+        {
+            if (GetCombatOrder() & ORDERS_TEMP_WAIT_TANKAGGRO)
+                TellMaster("I was still waiting for the tank to gain aggro, but that doesn't make sense anymore...");
+            if (GetCombatOrder() & ORDERS_TEMP_WAIT_OOC)
+                TellMaster("I was still waiting OOC but that was way off...");
+            ClearCombatOrder(ORDERS_TEMP);
+        }
+        return;
+    }
+
+    // new target -> DoFirstCombatManeuver
+    if (m_targetChanged)
+    {
+        switch (GetClassAI()->DoFirstCombatManeuver(m_targetCombat))
+        {
+            case RETURN_CONTINUE: // true needed for rogue stealth attack
+                break;
+
+            case RETURN_NO_ACTION_ERROR:
+                TellMaster("FirstCombatManeuver: No action performed due to error. Heading onto NextCombatManeuver.");
+            case RETURN_FINISHED_FIRST_MOVES: // false default
+            case RETURN_NO_ACTION_UNKNOWN:
+            case RETURN_NO_ACTION_OK:
+            default: // assume no action -> no return
+                m_targetChanged = false;
+        }
+    }
+
+    // do normal combat movement
+    DoCombatMovement();
+
+    if (!m_targetChanged)
+    {
+        // if m_targetChanged = false
+        switch (GetClassAI()->DoNextCombatManeuver(m_targetCombat))
+        {
+            case RETURN_NO_ACTION_UNKNOWN:
+            case RETURN_NO_ACTION_OK:
+            case RETURN_CONTINUE:
+            case RETURN_NO_ACTION_ERROR:
+            default:
+                return;
+        }
+    }
+}
+
+void PlayerbotAI::DoCombatMovement()
+{
+    if (!m_targetCombat) return;
+
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(m_targetCombat);
+
+    if (m_combatStyle == COMBAT_MELEE
+        && !m_bot->hasUnitState(UNIT_STAT_CHASE)
+        && ((m_movementOrder == MOVEMENT_STAY && meleeReach) || m_movementOrder != MOVEMENT_STAY)
+        && GetClassAI()->GetWaitUntil() == 0 ) // Not waiting
+    {
+        // melee combat - chase target if in range or if we are not forced to stay
+        m_bot->GetMotionMaster()->Clear(false);
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+    }
+    else if (m_combatStyle == COMBAT_RANGED
+             && m_movementOrder != MOVEMENT_STAY
+             && GetClassAI()->GetWaitUntil() == 0 ) // Not waiting
+    {
+        // ranged combat - just move within spell range
+        if (!CanReachWithSpellAttack(m_targetCombat))
+        {
+            m_bot->GetMotionMaster()->Clear(false);
+            m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        }
+        else
+            MovementClear();
+    }
+}
+
+/*
+ * IsGroupInCombat()
+ *
+ * return true if any member of the group is in combat or (error handling only) occupied in some way
+ */
+bool PlayerbotAI::IsGroupInCombat()
+{
+    if (!m_bot) return false;
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return true; // Let's just say you're otherwise occupied
+    if (m_bot->isInCombat()) return true;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->isAlive() || groupMember->IsInDuel() || groupMember->isInCombat()) // all occupied in some way
+                return true;
+        }
+    }
+
+    return false;
+}
+
+Player* PlayerbotAI::GetGroupTank()
+{
+    if (!m_bot) return nullptr;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI())
+                continue;
+            if (groupMember->GetPlayerbotAI()->IsTank())
+                return groupMember;
+        }
+    }
+
+    return nullptr;
+}
+
+void PlayerbotAI::SetGroupCombatOrder(CombatOrderType co)
+{
+    if (!m_bot) return;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI())
+                continue;
+            groupMember->GetPlayerbotAI()->SetCombatOrder(co);
+        }
+    }
+    else
+        SetCombatOrder(co);
+}
+
+void PlayerbotAI::ClearGroupCombatOrder(CombatOrderType co)
+{
+    if (!m_bot) return;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI())
+                continue;
+            groupMember->GetPlayerbotAI()->ClearCombatOrder(co);
+        }
+    }
+    else
+        ClearCombatOrder(co);
+}
+
+void PlayerbotAI::SetGroupIgnoreUpdateTime(uint8 t)
+{
+    if (!m_bot) return;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI())
+                continue;
+            groupMember->GetPlayerbotAI()->SetIgnoreUpdateTime(t);
+        }
+    }
+    else
+        SetIgnoreUpdateTime(t);
+}
+
+bool PlayerbotAI::GroupHoTOnTank()
+{
+    if (!m_bot) return false;
+
+    bool bReturn = false;
+
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI())
+                continue;
+            if (groupMember->GetPlayerbotAI()->GetClassAI()->CastHoTOnTank())
+                bReturn = true;
+        }
+
+        if (bReturn)
+        {
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+                if (!groupMember || !groupMember->GetPlayerbotAI())
+                    continue;
+                groupMember->GetPlayerbotAI()->SetIgnoreUpdateTime(1);
+            }
+        }
+    }
+    else // No group
+    {
+        if (GetClassAI()->CastHoTOnTank())
+        {
+            SetIgnoreUpdateTime(1);
+            return true;
+        }
+    }
+
+    return bReturn;
+}
+
+bool PlayerbotAI::CanPull(Player &fromPlayer)
+{
+    if (!m_bot) return false;
+    if (!GetClassAI()) return false;
+
+    if (!m_bot->GetGroup() || fromPlayer.GetGroup() != m_bot->GetGroup())
+    {
+        SendWhisper("I can't pull - we're not in the same group.", fromPlayer);
+        return false;
+    }
+
+    if (IsGroupInCombat()) // TODO: add raid support
+    {
+        SendWhisper("Unable to pull - the group is already in combat", fromPlayer);
+        return false;
+    }
+
+    if ((GetCombatOrder() & ORDERS_TANK) == 0)
+    {
+        SendWhisper("I cannot pull as I do not have combat orders to tank.", fromPlayer);
+        return false;
+    }
+
+    switch (m_bot->getClass())
+    {
+       case CLASS_PALADIN:
+            if ( ((PlayerbotPaladinAI*)GetClassAI())->CanPull() == false)
+            {
+                SendWhisper("I cannot pull, I do not have the proper spell or it's not ready yet.", fromPlayer);
+                return false;
+            }
+            break;
+
+        case CLASS_DRUID:
+            if ( ((PlayerbotDruidAI*)GetClassAI())->CanPull() == false)
+            {
+                SendWhisper("I cannot pull, I do not have the proper spell or it's not ready yet.", fromPlayer);
+                return false;
+            }
+            break;
+
+        case CLASS_WARRIOR:
+            if ( ((PlayerbotWarriorAI*)GetClassAI())->CanPull() == false)
+            {
+                SendWhisper("I cannot pull, I do not have the proper weapon and/or ammo.", fromPlayer);
+                return false;
+            }
+            break;
+
+        default:
+            SendWhisper("I cannot pull, I am not a tanking class.", fromPlayer);
+            return false;
+    }
+
+    return true;
+}
+
+// This function assumes a "CanPull()" call was preceded (not doing so will result in odd behavior)
+bool PlayerbotAI::CastPull()
+{
+    if (!m_bot) return false;
+    if (!GetClassAI()) return false;
+    if (!GetCurrentTarget()) return false;
+
+    if ((GetCombatOrder() & ORDERS_TANK) == 0) return false;
+
+    switch (m_bot->getClass())
+    {
+        case CLASS_PALADIN:
+            return ((PlayerbotPaladinAI*)GetClassAI())->Pull();
+
+        case CLASS_DRUID:
+            return ((PlayerbotDruidAI*)GetClassAI())->Pull();
+
+        case CLASS_WARRIOR:
+            return ((PlayerbotWarriorAI*)GetClassAI())->Pull();
+
+        default:
+            return false;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::GroupTankHoldsAggro()
+{
+    if (!m_bot) return false;
+
+    // update attacker info now
+    UpdateAttackerInfo();
+
+    if (m_bot->GetGroup())
+    {
+        Unit* newTarget = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF), GetGroupTank());
+        if (newTarget)
+        {
+            return false;
+        }
+    }
+    else
+        return false; // no group -> no group tank to hold aggro
+
+    return true;
+}
+
+// Wrapper for the UpdateAI cast subfunction
+// Each bot class neutralize function will return a spellId
+// depending on the creatureType of the target
+bool PlayerbotAI::CastNeutralize()
+{
+    if (!m_bot) return false;
+    if (!GetClassAI()) return false;
+    if (!m_targetGuidCommand) return false;
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+    if (!pTarget) return false;
+
+    Creature * pCreature = (Creature*) pTarget;
+    if (!pCreature) return false;
+
+    // Define the target's creature type, so the bot AI will now if
+    // it can neutralize it
+    uint8 creatureType = 0;
+    creatureType = pCreature->GetCreatureInfo()->CreatureType;
+
+    switch (m_bot->getClass())
+    {
+        default:
+            return false;
+    }
+
+    // A spellId was found
+    if (m_spellIdCommand != 0)
+        return true;
+
+    return false;
+}
+
+void PlayerbotAI::SetQuestNeedCreatures()
+{
+    // reset values first
+    m_needCreatureOrGOList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->ReqCreatureOrGOCount[i] || (qInfo->ReqCreatureOrGOCount[i] - qData.m_creatureOrGOcount[i]) <= 0)
+                continue;
+            m_needCreatureOrGOList[qInfo->ReqCreatureOrGOId[i]] = (qInfo->ReqCreatureOrGOCount[i] - qData.m_creatureOrGOcount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    // reset values first
+    m_needItemList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // check for items we not have enough of
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i] - qData.m_itemcount[i]) <= 0)
+                continue;
+            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i] - qData.m_itemcount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetState(BotState state)
+{
+    // DEBUG_LOG ("[PlayerbotAI]: SetState - %s switch state %d to %d", m_bot->GetName(), m_botState, state );
+    m_botState = state;
+}
+
+uint8 PlayerbotAI::GetFreeBagSpace() const
+{
+    uint8 space = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (!pItem)
+            ++space;
+    }
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        Bag* pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pBag && pBag->GetProto()->BagFamily == BAG_FAMILY_NONE)
+            space += pBag->GetFreeSlots();
+    }
+    return space;
+}
+
+void PlayerbotAI::DoFlight()
+{
+    DEBUG_LOG("[PlayerbotAI]: DoFlight - %s : %s", m_bot->GetName(), m_taxiMaster.GetString().c_str());
+
+    Creature *npc = m_bot->GetNPCIfCanInteractWith(m_taxiMaster, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!npc)
+    {
+        DEBUG_LOG("[PlayerbotAI]: DoFlight - %s not found or you can't interact with it.", m_taxiMaster.GetString().c_str());
+        return;
+    }
+
+    m_bot->ActivateTaxiPathTo(m_taxiNodes, npc);
+}
+
+void PlayerbotAI::DoLoot()
+{
+    // clear BOTSTATE_LOOTING if no more loot targets
+    if (m_lootCurrent.IsEmpty() && m_lootTargets.empty())
+    {
+        // DEBUG_LOG ("[PlayerbotAI]: DoLoot - %s is going back to idle", m_bot->GetName());
+        SetState(BOTSTATE_NORMAL);
+        m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+        m_inventory_full = false;
+        return;
+    }
+
+    // set first in list to current
+    if (m_lootCurrent.IsEmpty())
+    {
+        m_lootCurrent = m_lootTargets.front();
+        m_lootTargets.pop_front();
+    }
+
+    WorldObject *wo = m_bot->GetMap()->GetWorldObject(m_lootCurrent);
+
+    // clear invalid object or object that is too far from master
+    if (!wo || GetMaster()->GetDistance(wo) > BOTLOOT_DISTANCE)
+    {
+        m_lootCurrent = ObjectGuid();
+        return;
+    }
+
+    Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+
+    // clear creature or object that is not spawned or if not creature or object
+    if ((c && c->IsDespawned()) || (go && !go->isSpawned()) || (!c && !go))
+    {
+        m_lootCurrent = ObjectGuid();
+        return;
+    }
+
+    uint32 skillId = 0;
+
+    if (c)
+    {
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
+
+        // not a lootable creature, clear it
+        if (!c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) &&
+            (!c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) ||
+             (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && !m_bot->HasSkill(skillId))))
+        {
+            m_lootCurrent = ObjectGuid();
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear(false);
+            m_bot->GetMotionMaster()->MoveIdle();
+            return;
+        }
+    }
+
+    if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectBoundingRadius())
+    {
+        m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), wo->GetPositionX(), wo->GetPositionY(),wo->GetPositionZ());
+        // give time to move to point before trying again
+        SetIgnoreUpdateTime(1);
+    }
+
+    if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+    {
+        uint32 reqSkillValue = 0;
+        uint32 SkillValue = 0;
+        bool keyFailed = false;
+        bool skillFailed = false;
+        bool forceFailed = false;
+
+        if (c)  // creature
+        {
+            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) && !c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            {
+                // loot the creature
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+                *packet << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packet);
+                return; // no further processing is needed
+                // m_lootCurrent is reset in SMSG_LOOT_RELEASE_RESPONSE after checking for skinloot
+            }
+            else if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+                // not all creature skins are leather, some are ore or herb
+                if (m_bot->HasSkill(skillId) && ((skillId != SKILL_SKINNING) ||
+                                                 (HasCollectFlag(COLLECT_FLAG_SKIN) && skillId == SKILL_SKINNING)))
+                {
+                    // calculate skinning skill requirement
+                    uint32 targetLevel = c->getLevel();
+                    reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                }
+
+            // creatures cannot be unlocked or forced open
+            keyFailed = true;
+            forceFailed = true;
+        }
+
+        if (go) // object
+        {
+            // add this GO to our collection list if active and is chest/ore/herb
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+            {
+                m_collectObjects.push_back(go->GetEntry());
+                m_collectObjects.sort();
+                m_collectObjects.unique();
+            }
+
+            uint32 reqItem = 0;
+
+            // check skill or lock on object
+            uint32 lockId = go->GetGOInfo()->GetLockId();
+            LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+            if (lockInfo)
+                for (int i = 0; i < 8; ++i)
+                {
+                    if (lockInfo->Type[i] == LOCK_KEY_ITEM)
+                    {
+                        if (lockInfo->Index[i] > 0)
+                        {
+                            reqItem = lockInfo->Index[i];
+                            if (m_bot->HasItemCount(reqItem, 1))
+                                break;
+                            continue;
+                        }
+                    }
+                    else if (lockInfo->Type[i] == LOCK_KEY_SKILL)
+                    {
+                        switch (LockType(lockInfo->Index[i]))
+                        {
+                            case LOCKTYPE_OPEN:
+                                if (CastSpell(3365))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_CLOSE:
+                                if (CastSpell(6233))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_OPEN:
+                                if (CastSpell(6247))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_CLOSE:
+                                if (CastSpell(6247))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_TINKERING:
+                                if (CastSpell(6477))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_KNEELING:
+                                if (CastSpell(22810))    // Opening; listed with 17667 and 22810
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_ATTACKING:
+                                if (CastSpell(8386))    // Attacking
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_OPEN:
+                                if (CastSpell(21651))   // Opening; also had 26868
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_CLOSE:
+                                if (CastSpell(21652))   // Closing
+                                    return;
+                                break;
+                            default:
+                                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                                {
+                                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                                    reqSkillValue = lockInfo->Skill[i];
+                                }
+                        }
+                    }
+                }
+
+            // use key on object if available
+            if (reqItem > 0 && m_bot->HasItemCount(reqItem, 1))
+            {
+                UseItem(FindItem(reqItem), TARGET_FLAG_OBJECT, m_lootCurrent);
+                m_lootCurrent = ObjectGuid();
+                return;
+            }
+            else
+                keyFailed = true;
+        }
+
+        // determine bot's skill value for object's required skill
+        if (skillId != SKILL_NONE)
+            SkillValue = uint32(m_bot->GetPureSkillValue(skillId));
+
+        // bot has the specific skill or object requires no skill at all
+        if ((m_bot->HasSkill(skillId) && skillId != SKILL_NONE) || (skillId == SKILL_NONE && go))
+        {
+            if (SkillValue >= reqSkillValue)
+            {
+                switch (skillId)
+                {
+                    case SKILL_MINING:
+                        if (CastSpell(MINING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_HERBALISM:
+                        if (CastSpell(HERB_GATHERING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_SKINNING:
+                        if (c && HasCollectFlag(COLLECT_FLAG_SKIN) && CastSpell(SKINNING, *c))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_LOCKPICKING:
+                        if (CastSpell(PICK_LOCK_1))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_NONE:
+                        if (CastSpell(3365)) //Spell 3365 = Opening?
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    default:
+                        TellMaster("I'm not sure how to get that.");
+                        skillFailed = true;
+                        DEBUG_LOG ("[PlayerbotAI]:DoLoot Skill %u is not implemented", skillId);
+                        break;
+                }
+            }
+            else
+            {
+                TellMaster("My skill is not high enough. It requires %u, but mine is %u.",
+                           reqSkillValue, SkillValue);
+                skillFailed = true;
+            }
+        }
+        else
+        {
+            TellMaster("I do not have the required skill.");
+            skillFailed = true;
+        }
+
+        if (go) // only go's can be forced
+        {
+            // if pickable, check if a forcible item is available for the bot
+            if (skillId == SKILL_LOCKPICKING && (m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                                                 m_bot->HasSkill(SKILL_ENGINEERING)))
+            {
+                // check for skeleton keys appropriate for lock value
+                if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                {
+                    Item *kItem = FindKeyForLockValue(reqSkillValue);
+                    if (kItem)
+                    {
+                        TellMaster("I have a skeleton key that can open it!");
+                        UseItem(kItem, TARGET_FLAG_OBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have no skeleton keys that can open that lock.");
+                        forceFailed = true;
+                    }
+                }
+
+                // check for a charge that can blast it open
+                if (m_bot->HasSkill(SKILL_ENGINEERING))
+                {
+                    Item *bItem = FindBombForLockValue(reqSkillValue);
+                    if (bItem)
+                    {
+                        TellMaster("I can blast it open!");
+                        UseItem(bItem, TARGET_FLAG_OBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have nothing to blast it open with.");
+                        forceFailed = true;
+                    }
+                }
+            }
+            else
+                forceFailed = true;
+        }
+
+        // if all attempts failed in some way then clear because it won't get SMSG_LOOT_RESPONSE
+        if (keyFailed && skillFailed && forceFailed)
+        {
+            DEBUG_LOG ("[PlayerbotAI]: DoLoot attempts failed on [%s]",
+                       go ? go->GetGOInfo()->name : c->GetCreatureInfo()->Name);
+            m_lootCurrent = ObjectGuid();
+        }
+        // clear movement target, take next target on next update
+        m_bot->GetMotionMaster()->Clear(false);
+        m_bot->GetMotionMaster()->MoveIdle();
+    }
+}
+
+void PlayerbotAI::AcceptQuest(Quest const *qInfo, Player *pGiver)
+{
+    if (!qInfo || !pGiver)
+        return;
+
+    uint32 quest = qInfo->GetQuestId();
+
+    if (!pGiver->CanShareQuest(qInfo->GetQuestId()))
+    {
+        // giver can't share quest
+        m_bot->ClearDividerGuid();
+        return;
+    }
+
+    if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        // can't take quest
+        m_bot->ClearDividerGuid();
+        return;
+    }
+
+    if (m_bot->GetDividerGuid())
+    {
+        // send msg to quest giving player
+        pGiver->SendPushToPartyResponse(m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST);
+        m_bot->ClearDividerGuid();
+    }
+
+    if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, pGiver);
+
+        if (m_bot->CanCompleteQuest(quest))
+            m_bot->CompleteQuest(quest);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->ReqItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->ReqCreatureOrGOCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if (qInfo->GetSrcSpell() > 0)
+            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), true);
+    }
+}
+
+void PlayerbotAI::TurnInQuests(WorldObject *questgiver)
+{
+    ObjectGuid giverGUID = questgiver->GetObjectGuid();
+
+    if (!m_bot->IsInMap(questgiver))
+        TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelectionGuid(giverGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(giverGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.m_qId;
+            Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (!m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemPrototype const *pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                    }
+
+                    // else multiple rewards - let master pick
+                    else
+                    {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i = 0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemPrototype const * const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE)
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            else if (status == QUEST_STATUS_AVAILABLE)
+                out << "|cff00ff00Quest available:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            if (!out.str().empty())
+                TellMaster(out.str());
+        }
+    }
+}
+
+bool PlayerbotAI::IsInCombat()
+{
+    Pet *pet;
+    bool inCombat = false;
+    inCombat |= m_bot->isInCombat();
+    pet = m_bot->GetPet();
+    if (pet)
+        inCombat |= pet->isInCombat();
+    inCombat |= GetMaster()->isInCombat();
+    if (m_bot->GetGroup())
+    {
+        GroupReference *ref = m_bot->GetGroup()->GetFirstMember();
+        while (ref)
+        {
+            inCombat |= ref->getSource()->isInCombat();
+            pet = ref->getSource()->GetPet();
+            if (pet)
+                inCombat |= pet->isInCombat();
+            ref = ref->next();
+        }
+    }
+    return inCombat;
+}
+
+bool PlayerbotAI::IsRegenerating()
+{
+    Unit::SpellAuraHolderMap& auras = m_bot->GetSpellAuraHolderMap();
+    for (Unit::SpellAuraHolderMap::iterator aura = auras.begin(); aura != auras.end(); aura++)
+    {
+        SpellEntry const* spell = aura->second->GetSpellProto();
+        if (!spell)
+            continue;
+        if (spell->Category == 59 || spell->Category == 11){
+            return true;
+        }
+    }
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    return false;
+}
+
+void PlayerbotAI::UpdateAttackersForTarget(Unit *victim)
+{
+    HostileReference *ref = victim->getHostileRefManager().getFirst();
+    while (ref)
+    {
+        ThreatManager *target = ref->getSource();
+        ObjectGuid guid = target->getOwner()->GetObjectGuid();
+        m_attackerInfo[guid].attacker = target->getOwner();
+        m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+        m_attackerInfo[guid].threat = target->getThreat(victim);
+        m_attackerInfo[guid].count = 1;
+        //m_attackerInfo[guid].source = 1; // source is not used so far.
+        ref = ref->next();
+    }
+}
+
+void PlayerbotAI::UpdateAttackerInfo()
+{
+    // clear old list
+    m_attackerInfo.clear();
+
+    // check own attackers
+    UpdateAttackersForTarget(m_bot);
+    Pet *pet = m_bot->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check master's attackers
+    UpdateAttackersForTarget(GetMaster());
+    pet = GetMaster()->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check all group members now
+    if (m_bot->GetGroup())
+    {
+        GroupReference *gref = m_bot->GetGroup()->GetFirstMember();
+        while (gref)
+        {
+            if (gref->getSource() == m_bot || gref->getSource() == GetMaster())
+            {
+                gref = gref->next();
+                continue;
+            }
+
+            UpdateAttackersForTarget(gref->getSource());
+            pet = gref->getSource()->GetPet();
+            if (pet)
+                UpdateAttackersForTarget(pet);
+
+            gref = gref->next();
+        }
+    }
+
+    // get highest threat not caused by bot for every entry in AttackerInfoList...
+    for (AttackerInfoList::iterator itr = m_attackerInfo.begin(); itr != m_attackerInfo.end(); ++itr)
+    {
+        if (!itr->second.attacker)
+            continue;
+        Unit *a = itr->second.attacker;
+        float t = 0.00;
+        std::list<HostileReference*>::const_iterator i = a->getThreatManager().getThreatList().begin();
+        for (; i != a->getThreatManager().getThreatList().end(); ++i)
+        {
+            if ((*i)->getThreat() > t && (*i)->getTarget() != m_bot)
+                t = (*i)->getThreat();
+        }
+        m_attackerInfo[itr->first].threat2 = t;
+    }
+
+    // DEBUG: output attacker info
+    //sLog.outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
+    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
+    //    sLog.outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
+    //        i->first,
+    //        (i->second.attacker?i->second.attacker->GetGUIDLow():0),
+    //        (i->second.victim?i->second.victim->GetGUIDLow():0),
+    //        i->second.threat,
+    //        i->second.threat2,
+    //        i->second.count,
+    //        i->second.source );
+    //sLog.outBasic( "[PlayerbotAI]: };" );
+}
+
+uint32 PlayerbotAI::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(((INVENTORY_SLOT_BAG_0 << 8) | i));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for (int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for (int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(((j << 8) | i));
+    return TotalCost;
+}
+
+uint32 PlayerbotAI::EstRepair(uint16 pos)
+{
+    Item* item = m_bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if (!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if (!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if (LostDurability > 0)
+    {
+        ItemPrototype const *ditemProto = item->GetProto();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if (!dcost)
+        {
+            sLog.outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if (!dQualitymodEntry)
+        {
+            sLog.outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod));
+
+        if (costs == 0)                                 //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
+
+Unit* PlayerbotAI::FindAttacker(ATTACKERINFOTYPE ait, Unit* victim)
+{
+    // list empty? why are we here?
+    if (m_attackerInfo.empty())
+        return 0;
+
+    // not searching something specific - return first in list
+    if (!ait)
+        return (m_attackerInfo.begin())->second.attacker;
+
+    float t = ((ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00);
+    Unit *a = 0;
+    AttackerInfoList::iterator itr = m_attackerInfo.begin();
+    for (; itr != m_attackerInfo.end(); ++itr)
+    {
+        if ((ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot)
+            continue;
+
+        if (!(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot)
+            continue;
+
+        if ((ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim)
+            continue;
+
+        if (!(ait & (AIT_LOWESTTHREAT | AIT_HIGHESTTHREAT)))
+        {
+            a = itr->second.attacker;
+            itr = m_attackerInfo.end(); // == break;
+        }
+        else
+        {
+            if ((ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat >= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+            else if ((ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat <= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+        }
+    }
+    return a;
+}
+
+/**
+* BotDataRestore()
+* Restores autoequip - the toggle status for the 'equip auto' command.
+* Restores gDelayAttack - the other attributes need a valid target. This function is to be called when the targets
+* may or may not be online (such as upon login). See CombatOrderRestore() for full orders restore.
+* Restores m_DelayAttack - the other attributes need a valid target. This function is to be called when the targets
+*/
+void PlayerbotAI::BotDataRestore()
+{
+    QueryResult* result = CharacterDatabase.PQuery("SELECT combat_delay FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetGUIDLow());
+
+    if (!result)
+    {
+        sLog.outString();
+        sLog.outString(">> [BotDataRestore()] Loaded `playerbot_saved_data`, found no match for guid %u.", m_bot->GetGUIDLow());
+        m_DelayAttack = 0;
+        return;
+    }
+    else
+    {
+        Field* fields = result->Fetch();
+        m_DelayAttack = fields[0].GetUInt8();
+        delete result;
+    }
+}
+
+/**
+* CombatOrderRestore()
+* Restores all saved attributes. This function is to be called when the targets are assumed to be online.
+*/
+
+void PlayerbotAI::CombatOrderRestore()
+{
+    QueryResult* result = CharacterDatabase.PQuery("SELECT combat_order,primary_target,secondary_target,pname,sname,combat_delay,auto_follow FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetGUIDLow());
+
+    if (!result)
+    {
+        sLog.outString();
+        sLog.outString(">> [CombatOrderRestore()] Loaded `playerbot_saved_data`, found no match for guid %u.", m_bot->GetGUIDLow());
+        TellMaster("I have no orders");
+        return;
+    }
+
+    Field* fields = result->Fetch();
+    CombatOrderType combatOrders = (CombatOrderType)fields[0].GetUInt32();
+    ObjectGuid PrimtargetGUID = ObjectGuid(fields[1].GetUInt64());
+    ObjectGuid SectargetGUID = ObjectGuid(fields[2].GetUInt64());
+    std::string pname = fields[3].GetString();
+    std::string sname = fields[4].GetString();
+    m_DelayAttack = fields[5].GetUInt8();
+    gPrimtarget = ObjectAccessor::GetUnit(*m_bot->GetMap()->GetWorldObject(PrimtargetGUID), PrimtargetGUID);
+    gSectarget = ObjectAccessor::GetUnit(*m_bot->GetMap()->GetWorldObject(SectargetGUID), SectargetGUID);
+    delete result;
+
+    //Unit* target = nullptr;
+    //ObjectGuid NoTargetGUID = m_bot->GetObjectGuid();
+    //target = ObjectAccessor::GetUnit(*m_bot, NoTargetGUID);
+
+    if (combatOrders & ORDERS_PRIMARY) SetCombatOrder(combatOrders, gPrimtarget);
+    if (combatOrders & ORDERS_SECONDARY) SetCombatOrder(combatOrders, gSectarget);
+}
+
+void PlayerbotAI::SetCombatOrderByStr(std::string str, Unit *target)
+{
+    CombatOrderType co;
+    if (str == "tank")              co = ORDERS_TANK;
+    else if (str == "assist")       co = ORDERS_ASSIST;
+    else if (str == "heal")         co = ORDERS_HEAL;
+    else if (str == "protect")      co = ORDERS_PROTECT;
+    else if (str == "passive")      co = ORDERS_PASSIVE;
+    else if (str == "pull")         co = ORDERS_TEMP_WAIT_TANKAGGRO;
+    else if (str == "nodispel")     co = ORDERS_NODISPEL;
+    else if (str == "resistfrost")  co = ORDERS_RESIST_FROST;
+    else if (str == "resistnature") co = ORDERS_RESIST_NATURE;
+    else if (str == "resistfire")   co = ORDERS_RESIST_FIRE;
+    else if (str == "resistshadow") co = ORDERS_RESIST_SHADOW;
+    else                            co = ORDERS_RESET;
+
+    SetCombatOrder(co, target);
+}
+
+void PlayerbotAI::SetCombatOrder(CombatOrderType co, Unit* target)
+{
+    uint32 gTempTarget;
+    std::string gname;
+    if (target)
+    {
+        gTempTarget = target->GetGUIDLow();
+        gname = target->GetName();
+    }
+
+    // reset m_combatOrder after ORDERS_PASSIVE
+    if (m_combatOrder == ORDERS_PASSIVE)
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+    }
+
+    switch(co)
+    {
+        case ORDERS_ASSIST: // 2(10)
+            {
+                if (!target)
+                {
+                    TellMaster("The assist command requires a target.");
+                    return;
+                }
+                else m_targetAssist = target;
+                break;
+            }
+        case ORDERS_PROTECT: // 10(10000)
+            {
+                if (!target)
+                {
+                    TellMaster("The protect command requires a target.");
+                    return;
+                }
+                else m_targetProtect = target;
+                break;
+            }
+        case ORDERS_PASSIVE: // 20(100000)
+            {
+                m_combatOrder = ORDERS_PASSIVE;
+                m_targetAssist = 0;
+                m_targetProtect = 0;
+                return;
+            }
+        case ORDERS_RESET: // FFFF(11111111)
+            {
+                m_combatOrder = ORDERS_NONE;
+                m_targetAssist = 0;
+                m_targetProtect = 0;
+                m_DelayAttackInit = CurrentTime();
+                m_DelayAttack = 0;
+                CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = 0, primary_target = 0, secondary_target = 0, pname = '',sname = '', combat_delay = 0 WHERE guid = '%u'", m_bot->GetGUIDLow());
+                TellMaster("Orders are cleaned!");
+                return;
+            }
+        default:
+            break;
+    }
+
+    // Do your magic
+    if ((co & ORDERS_PRIMARY))
+    {
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_SECONDARY) | (uint32) co);
+        if (target)
+            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u', primary_target = '%u', pname = '%s' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), gTempTarget, gname.c_str(), m_bot->GetGUIDLow());
+    }
+    else
+    {
+        m_combatOrder = (CombatOrderType)((uint32)m_combatOrder | (uint32)co);
+        if (target)
+            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u', secondary_target = '%u', sname = '%s' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), gTempTarget, gname.c_str(), m_bot->GetGUIDLow());
+    }
+}
+
+void PlayerbotAI::ClearCombatOrder(CombatOrderType co)
+{
+     m_combatOrder = (CombatOrderType) ((uint32) m_combatOrder & (uint32) ~co);
+
+     switch (co)
+     {
+     case ORDERS_NONE:
+     case ORDERS_TANK:
+     case ORDERS_ASSIST:
+     case ORDERS_HEAL:
+     case ORDERS_PASSIVE:
+     case ORDERS_PRIMARY:
+     case ORDERS_RESET:
+     case ORDERS_SECONDARY:
+         SetCombatOrder(ORDERS_RESET);
+         return;
+
+     default:
+         return;
+     }
+ }
+
+void PlayerbotAI::SetMovementOrder(MovementOrderType mo, Unit *followTarget)
+{
+    m_movementOrder = mo;
+    m_followTarget = followTarget;
+    MovementReset();
+}
+
+void PlayerbotAI::MovementReset()
+{
+    // stop moving...
+    MovementClear();
+
+    if (m_movementOrder == MOVEMENT_FOLLOW)
+    {
+        if (!m_followTarget)
+            return;
+
+        WorldObject* distTarget = m_followTarget;   // target to distance check
+
+        // don't follow while in combat
+        if (m_bot->isInCombat())
+            return;
+
+        Player* pTarget;                            // target is player
+        if (m_followTarget->GetTypeId() == TYPEID_PLAYER)
+            pTarget = ((Player*) m_followTarget);
+
+        if (pTarget)
+        {
+            // check player for follow situations
+            if (pTarget->IsBeingTeleported() || pTarget->IsTaxiFlying())
+                return;
+
+            // use player's corpse as distance check target
+            if (pTarget->GetCorpse())
+                distTarget = pTarget->GetCorpse();
+        }
+
+        // is bot too far from the follow target
+        if (!m_bot->IsWithinDistInMap(distTarget, 50))
+        {
+            DoTeleport(*m_followTarget);
+            return;
+        }
+
+        if (m_bot->isAlive())
+        {
+            float angle = rand_float(0, M_PI_F);
+            float dist = rand_float(m_mgr->m_confFollowDistance[0], m_mgr->m_confFollowDistance[1]);
+            m_bot->GetMotionMaster()->MoveFollow(m_followTarget, dist, angle);
+        }
+    }
+}
+
+void PlayerbotAI::MovementClear()
+{
+    // stop...
+    m_bot->clearUnitState(UNIT_STAT_FOLLOW);
+    m_bot->GetMotionMaster()->Initialize();
+
+    // stand up...
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+void PlayerbotAI::PlaySound(uint32 soundid)
+{
+    WorldPacket data(SMSG_PLAY_SOUND, 4);
+    data << soundid;
+    GetMaster()->GetSession()->SendPacket(&data);
+}
+
+// PlaySound data from SoundEntries.dbc
+void PlayerbotAI::Announce(AnnounceFlags msg)
+{
+    switch (m_bot->getRace())
+    {
+        case RACE_HUMAN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1908) : PlaySound(2032); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1875) : PlaySound(1999); break;
+                default: break;
+            }
+            break;
+        case RACE_ORC:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2319) : PlaySound(2374); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2284) : PlaySound(2341); break;
+                default: break;
+            }
+            break;
+        case RACE_DWARF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1630) : PlaySound(1686); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1581) : PlaySound(1654); break;
+                default: break;
+            }
+            break;
+        case RACE_NIGHTELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2151) : PlaySound(2262); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2118) : PlaySound(2229); break;
+                default: break;
+            }
+            break;
+        case RACE_UNDEAD:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2096) : PlaySound(2207); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2054) : PlaySound(2173); break;
+                default: break;
+            }
+            break;
+        case RACE_TAUREN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2463) : PlaySound(2462); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2396) : PlaySound(2397); break;
+                default: break;
+            }
+            break;
+        case RACE_GNOME:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1743) : PlaySound(1798); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1708) : PlaySound(1709); break;
+                default: break;
+            }
+            break;
+        case RACE_TROLL:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1853) : PlaySound(1963); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1820) : PlaySound(1930); break;
+                default: break;
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+bool PlayerbotAI::IsMoving()
+{
+    return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
+}
+
+// some possible things to use in AI
+// GetRandomContactPoint
+// GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// hasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 /*p_time*/)
+{
+    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+        return;
+
+    if (CurrentTime() < m_ignoreAIUpdatesUntilTime)
+        return;
+
+    // default updates occur every two seconds
+    SetIgnoreUpdateTime(2);
+
+    if (!m_bot->isAlive())
+    {
+        if (m_botState == BOTSTATE_DEAD)
+        {
+            // become ghost
+            if (m_bot->GetCorpse()) {
+                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s already has a corpse...", m_bot->GetName());
+                SetState(BOTSTATE_DEADRELEASED);
+                return;
+            }
+            m_bot->SetBotDeathTimer();
+            m_bot->BuildPlayerRepop();
+            // relocate ghost
+            WorldLocation loc;
+            Corpse *corpse = m_bot->GetCorpse();
+            corpse->GetPosition(loc);
+            m_bot->TeleportTo(loc.mapid, loc.coord_x, loc.coord_y, loc.coord_z, m_bot->GetOrientation());
+            // set state to released
+            SetState(BOTSTATE_DEADRELEASED);
+
+            return;
+        }
+
+        if (m_botState == BOTSTATE_DEADRELEASED)
+        {
+            // get bot's corpse
+            Corpse *corpse = m_bot->GetCorpse();
+            if (!corpse)
+                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s has no corpse!", m_bot->GetName());
+                return;
+            // teleport ghost from graveyard to corpse
+            // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - Teleport %s to corpse...", m_bot->GetName());
+            DoTeleport(*corpse);
+            // check if we are allowed to resurrect now
+            time_t resurrect_time = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
+            if (resurrect_time > CurrentTime())
+            {
+                SetIgnoreUpdateTime( resurrect_time );
+                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-CurrentTime() );
+                return;
+            }
+            // resurrect now
+            // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - Reviving %s to corpse...", m_bot->GetName() );
+
+            SetIgnoreUpdateTime(6);
+
+            PlayerbotChatHandler ch(GetMaster());
+            if (!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return;
+            }
+            // set back to normal
+            SetState(BOTSTATE_NORMAL);
+
+            return;
+        }
+
+        // if (m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED)
+        // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s died and is not in correct state...", m_bot->GetName() );
+        // clear loot list on death
+        m_lootTargets.clear();
+        m_lootCurrent = ObjectGuid();
+        // clear combat orders
+        m_bot->SetSelectionGuid(ObjectGuid());
+        m_bot->GetMotionMaster()->Clear(true);
+        // set state to dead
+        SetState(BOTSTATE_DEAD);
+        // wait 30sec
+        SetIgnoreUpdateTime(30);
+
+        return;
+    }
+
+    // bot still alive
+    if (!m_findNPC.empty())
+        findNearbyCreature();
+
+    // if we are casting a spell then interrupt it
+    // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+    Spell* const pSpell = GetCurrentSpell();
+    if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat()))
+    {
+        // DEBUG_LOG("spell (%s) is being interrupted",pSpell->m_spellInfo->SpellName[0]);
+        InterruptCurrentCastingSpell();
+        return;
+    }
+
+    // direct cast command from master
+    if (m_spellIdCommand != 0)
+    {
+        Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+        if (pTarget)
+            CastSpell(m_spellIdCommand, *pTarget);
+        m_spellIdCommand = 0;
+        m_targetGuidCommand = ObjectGuid();
+
+        return;
+    }
+
+    //if master is unmounted, unmount the bot
+    if (!GetMaster()->IsMounted() && m_bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+
+        return;
+    }
+
+    // handle combat (either self/master/group in combat, or combat state and valid target)
+    if (IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) ||  m_ScenarioType == SCENARIO_PVP_DUEL)
+    {
+        //check if the bot is Mounted
+        if (!m_bot->IsMounted())
+        {
+            if (!pSpell || !pSpell->IsChannelActive())
+            {
+                // DEBUG_LOG("m_DelayAttackInit (%li) + m_DelayAttack (%u) > time(%li)", m_DelayAttackInit, m_DelayAttack, CurrentTime());
+                if (m_DelayAttackInit + m_DelayAttack > CurrentTime())
+                    return SetIgnoreUpdateTime(1); // short bursts of delay
+
+                return DoNextCombatManeuver();
+            }
+            else // channelling a spell
+                return SetIgnoreUpdateTime(0);  // It's better to update AI more frequently during combat
+        }
+
+        return;
+    }
+
+    // bot was in combat recently - loot now
+    if (m_botState == BOTSTATE_COMBAT)
+    {
+        if (GetCombatOrder() & ORDERS_TEMP)
+        {
+            if (GetCombatOrder() & ORDERS_TEMP_WAIT_TANKAGGRO)
+                TellMaster("I was still waiting for the tank to gain aggro, but that doesn't make sense anymore...");
+            if (GetCombatOrder() & ORDERS_TEMP_WAIT_OOC)
+                TellMaster("I was still waiting OOC but I just got out of combat...");
+            ClearCombatOrder(ORDERS_TEMP);
+        }
+        SetState(BOTSTATE_LOOTING);
+        m_attackerInfo.clear();
+        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+            m_lootTargets.unique();
+        else
+            m_lootTargets.clear();
+
+    }
+
+    if (m_botState == BOTSTATE_LOOTING)
+        return DoLoot();
+
+    if (m_botState == BOTSTATE_FLYING)
+    {
+        /* std::ostringstream out;
+        out << "Taxi: " << m_bot->GetName() << m_ignoreAIUpdatesUntilTime;
+        TellMaster(out.str().c_str()); */
+        DoFlight();
+        SetState(BOTSTATE_NORMAL);
+        SetIgnoreUpdateTime(0);
+
+        return;
+    }
+
+    // if commanded to follow master and not already following master then follow master
+    if (!m_bot->isInCombat() && !IsMoving())
+        return MovementReset();
+
+    // do class specific non combat actions
+    if (GetClassAI() && !m_bot->IsMounted() && !IsRegenerating())
+    {
+        GetClassAI()->DoNonCombatActions();
+
+        // have we been told to collect GOs
+        if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+        {
+            findNearbyGO();
+            // start looting if have targets
+            if (!m_lootTargets.empty())
+                SetState(BOTSTATE_LOOTING);
+        }
+
+        return;
+    }
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0)
+        return nullptr;
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string& text) const
+{
+    SendWhisper(text, *GetMaster());
+}
+
+void PlayerbotAI::TellMaster(const char *fmt, ...) const
+{
+    char temp_buf[1024];
+    va_list ap;
+    va_start(ap, fmt);
+    (void) vsnprintf(temp_buf, 1024, fmt, ap);
+    va_end(ap);
+    std::string str = temp_buf;
+    TellMaster(str);
+}
+
+void PlayerbotAI::SendWhisper(const std::string& text, Player& player) const
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    ChatHandler::BuildChatPacket(data, CHAT_MSG_WHISPER, text.c_str(),
+        LANG_UNIVERSAL, m_bot->GetChatTag(), m_bot->GetObjectGuid(),
+        m_bot->GetName(), player.GetObjectGuid());
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
+{
+    return player.GetSession()->GetAccountId() == GetMaster()->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::In_Range(Unit* Target, uint32 spellId)
+{
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    SpellRangeEntry const* TempRange = GetSpellRangeStore()->LookupEntry(pSpellInfo->rangeIndex);
+
+    //Spell has invalid range store so we can't use it
+    if (!TempRange)
+        return false;
+
+    if (TempRange->minRange == (TempRange->maxRange == 0.0f))
+        return true;
+
+    //Unit is out of range of this spell
+    if (!m_bot->IsInRange(Target, TempRange->minRange, TempRange->maxRange))
+        return false;
+
+    return true;
+}
+
+bool PlayerbotAI::CheckBotCast(const SpellEntry *sInfo )
+{
+    if (!sInfo)
+        return false;
+
+    // check DoLoot() spells before casting
+    Spell* tmp_spell = new Spell(m_bot, sInfo, false);
+    if (tmp_spell)
+    {
+        if (m_lootCurrent.IsCreature())
+        {
+            if (Creature* obj = m_bot->GetMap()->GetCreature(m_lootCurrent))
+                tmp_spell->m_targets.setUnitTarget(obj);
+        }
+        else if (m_lootCurrent.IsGameObject())
+        {
+            if (GameObject* obj = m_bot->GetMap()->GetGameObject(m_lootCurrent))
+                tmp_spell->m_targets.setGOTarget(obj);
+        }
+
+        SpellCastResult res = tmp_spell->CheckCast(false);
+        // DEBUG_LOG("CheckBotCast SpellCastResult(%u)",res);
+        switch(res)
+        {
+            case SPELL_CAST_OK:
+                return true;
+            case SPELL_FAILED_TRY_AGAIN:
+                return true;
+            default:
+                return false;
+        }
+    }
+    return false;
+}
+
+bool PlayerbotAI::CastSpell(const char* args)
+{
+    uint32 spellId = getSpellId(args);
+    return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
+{
+    ObjectGuid oldSel = m_bot->GetSelectionGuid();
+    m_bot->SetSelectionGuid(target.GetObjectGuid());
+    bool rv = CastSpell(spellId);
+    m_bot->SetSelectionGuid(oldSel);
+    return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId)
+{
+    // some AIs don't check if the bot doesn't have spell before using it
+    // so just return false when this happens
+    if (spellId == 0)
+        return false;
+
+    // check spell cooldown
+    if (m_bot->HasSpellCooldown(spellId))
+        return false;
+
+    // see Creature.cpp 1738 for reference
+    // don't allow bot to cast damage spells on friends
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("missing spell entry in CastSpell for spellid %u.", spellId);
+        return false;
+    }
+
+    // Power check (stolen from: CreatureAI.cpp - CreatureAI::CanCastSpell)
+    if (m_bot->GetPower((Powers)pSpellInfo->powerType) < Spell::CalculatePowerCost(pSpellInfo, m_bot))
+        return false;
+
+    // set target
+    ObjectGuid targetGUID = m_bot->GetSelectionGuid();
+    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
+
+    if (!pTarget)
+        pTarget = m_bot;
+
+    if (IsPositiveSpell(spellId))
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        m_bot->SetInFront(pTarget);
+    }
+
+    float CastTime = 0.0f;
+
+    // stop movement to prevent cancel spell casting
+    SpellCastTimesEntry const * castTimeEntry = sSpellCastTimesStore.LookupEntry(pSpellInfo->CastingTimeIndex);
+    // stop movement to prevent cancel spell casting
+    if (castTimeEntry && castTimeEntry->CastTime)
+    {
+        CastTime = (castTimeEntry->CastTime / 1000);
+        DEBUG_LOG ("[PlayerbotAI]: CastSpell - Bot movement reset for casting %s (%u)", pSpellInfo->SpellName[0], spellId);
+        MovementClear();
+    }
+
+    uint16 target_type = TARGET_FLAG_UNIT;
+
+    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK)
+        target_type = TARGET_FLAG_OBJECT;
+
+    m_CurrentlyCastingSpellId = spellId;
+
+    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effect[0] == SPELL_EFFECT_SKINNING)
+    {
+        if (m_lootCurrent)
+        {
+            if (!CheckBotCast(pSpellInfo))
+                return false;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_CAST_SPELL, 4+2+8);
+            *packet << spellId;
+            *packet << target_type;
+            *packet << m_lootCurrent.WriteAsPacked();
+            m_bot->GetSession()->QueuePacket(packet);       // queue the packet to get around race condition
+
+      /*      if (target_type == TARGET_FLAG_OBJECT)
+            {
+                WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_USE, 8);
+                *packetgouse << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packetgouse);  // queue the packet to get around race condition
+
+                GameObject *obj = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+                if (!obj)
+                    return false;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    m_bot->PrepareQuestMenu(m_lootCurrent);
+                    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.m_qId;
+                        if (!AddQuest(questID, obj))
+                            TellMaster("Couldn't take quest");
+                    }
+                    m_lootCurrent = ObjectGuid();
+                    m_bot->GetMotionMaster()->Clear(false);
+                    m_bot->GetMotionMaster()->MoveIdle();
+                }
+            } */
+            return true;
+        }
+        else
+            return false;
+    }
+    else
+    {
+        // Check spell range
+        if (!In_Range(pTarget, spellId))
+            return false;
+
+        // Check line of sight
+        if (!m_bot->IsWithinLOSInMap(pTarget))
+            return false;
+
+        if (IsAutoRepeatRangedSpell(pSpellInfo))
+            m_bot->CastSpell(pTarget, pSpellInfo, true);       // cast triggered spell
+        else
+            m_bot->CastSpell(pTarget, pSpellInfo, false);      // uni-cast spell
+    }
+
+    SetIgnoreUpdateTime(CastTime + 1);
+
+    return true;
+}
+
+bool PlayerbotAI::CastPetSpell(uint32 spellId, Unit* target)
+{
+    if (spellId == 0)
+        return false;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return false;
+
+    if (pet->HasSpellCooldown(spellId))
+        return false;
+
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastPetSpell()");
+        return false;
+    }
+
+    // set target
+    Unit* pTarget;
+    if (!target)
+    {
+        ObjectGuid targetGUID = m_bot->GetSelectionGuid();
+        pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
+    }
+    else
+        pTarget = target;
+
+    if (IsPositiveSpell(spellId))
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        if (!pet->isInFrontInMap(pTarget, 10)) // distance probably should be calculated
+            pet->SetFacingTo(pet->GetAngle(pTarget));
+    }
+
+    pet->CastSpell(pTarget, pSpellInfo, false);
+
+    Spell* const pSpell = pet->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell)
+        return false;
+
+    return true;
+}
+
+// Perform sanity checks and cast spell
+bool PlayerbotAI::Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player *))
+{
+    if (spellId == 0)
+        return false;
+
+    SpellEntry const * spellProto = sSpellStore.LookupEntry(spellId);
+
+    if (!spellProto)
+        return false;
+
+    if (!target)
+        return false;
+
+    // Select appropriate spell rank for target's level
+    spellProto = sSpellMgr.SelectAuraRankForLevel(spellProto, target->getLevel());
+    if (!spellProto)
+        return false;
+
+    // Check if spell will boost one of already existent auras
+    bool willBenefitFromSpell = false;
+    for (uint8 i = 0; i < MAX_EFFECT_INDEX; ++i)
+    {
+        if (spellProto->EffectApplyAuraName[i] == SPELL_AURA_NONE)
+            break;
+
+        bool sameOrBetterAuraFound = false;
+        int32 bonus = m_bot->CalculateSpellDamage(target, spellProto, SpellEffectIndex(i));
+        Unit::AuraList const& auras = target->GetAurasByType(AuraType(spellProto->EffectApplyAuraName[i]));
+        for (Unit::AuraList::const_iterator it = auras.begin(); it != auras.end(); ++it)
+            if ((*it)->GetModifier()->m_miscvalue == spellProto->EffectMiscValue[i] && (*it)->GetModifier()->m_amount >= bonus)
+            {
+                sameOrBetterAuraFound = true;
+                break;
+            }
+        willBenefitFromSpell = willBenefitFromSpell || !sameOrBetterAuraFound;
+    }
+
+    if (!willBenefitFromSpell)
+        return false;
+
+    // Druids may need to shapeshift before casting
+    if (beforeCast)
+        (*beforeCast)(m_bot);
+
+    return CastSpell(spellProto->Id, *target);
+}
+
+// Can be used for personal buffs like Mage Armor and Inner Fire
+bool PlayerbotAI::SelfBuff(uint32 spellId)
+{
+    if (spellId == 0)
+        return false;
+
+    if (m_bot->HasAura(spellId))
+        return false;
+
+    return CastSpell(spellId, *m_bot);
+}
+
+// Checks if spell is single per target per caster and will make any effect on target
+bool PlayerbotAI::CanReceiveSpecificSpell(uint8 spec, Unit* target) const
+{
+    if (IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific(spec), SpellSpecific(spec)))
+    {
+        Unit::SpellAuraHolderMap holders = target->GetSpellAuraHolderMap();
+        Unit::SpellAuraHolderMap::iterator it;
+        for (it = holders.begin(); it != holders.end(); ++it)
+            if ((*it).second->GetCasterGuid() == m_bot->GetObjectGuid() && GetSpellSpecific((*it).second->GetId()) == SpellSpecific(spec))
+                return false;
+    }
+    return true;
+}
+
+Item* PlayerbotAI::FindItem(uint32 ItemId)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // DEBUG_LOG ("[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                DEBUG_LOG ("[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindItemInBank(uint32 ItemId)
+{
+    // list out items in bank item slots
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        // sLog.outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot);
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in bank bag slots
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog.outDebug("[%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindKeyForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 25 && m_bot->HasItemCount(SILVER_SKELETON_KEY, 1))
+        return FindItem(SILVER_SKELETON_KEY);
+    if (reqSkillValue <= 125 && m_bot->HasItemCount(GOLDEN_SKELETON_KEY, 1))
+        return FindItem(GOLDEN_SKELETON_KEY);
+    if (reqSkillValue <= 200 && m_bot->HasItemCount(TRUESILVER_SKELETON_KEY, 1))
+        return FindItem(TRUESILVER_SKELETON_KEY);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(ARCANITE_SKELETON_KEY, 1))
+        return FindItem(ARCANITE_SKELETON_KEY);
+
+    return nullptr;
+}
+
+Item* PlayerbotAI::FindBombForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 150 && m_bot->HasItemCount(SMALL_SEAFORIUM_CHARGE, 1))
+        return FindItem(SMALL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 250 && m_bot->HasItemCount(LARGE_SEAFORIUM_CHARGE, 1))
+        return FindItem(LARGE_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(POWERFUL_SEAFORIUM_CHARGE, 1))
+        return FindItem(POWERFUL_SEAFORIUM_CHARGE);
+
+    return nullptr;
+}
+
+bool PlayerbotAI::PickPocket(Unit* pTarget)
+{
+    if(!pTarget)
+        return false;
+
+    ObjectGuid markGuid = pTarget->GetObjectGuid();
+    Creature *c = m_bot->GetMap()->GetCreature(markGuid);
+    if(c)
+    {
+        Loot*& loot = c->loot;
+        if (!loot)
+            loot = new Loot(m_bot, c, LOOT_PICKPOCKETING);
+        else
+        {
+            if (loot->GetLootType() != LOOT_PICKPOCKETING)
+            {
+                delete loot;
+                loot = new Loot(m_bot, c, LOOT_PICKPOCKETING);
+            }
+        }
+
+        if (loot->GetGoldAmount())
+        {
+            m_bot->ModifyMoney(loot->GetGoldAmount());
+
+            if (m_mgr->m_confDebugWhisper)
+            {
+                std::ostringstream out;
+
+                // calculate how much money bot loots
+                uint32 copper = loot->GetGoldAmount();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                out << "|r|cff009900" << m_bot->GetName() << " loots: " << "|h|cffffffff[|r|cff00ff00" << gold
+                    << "|r|cfffffc00g|r|cff00ff00" << silver
+                    << "|r|cffcdcdcds|r|cff00ff00" << copper
+                    << "|r|cff993300c"
+                    << "|h|cffffffff]";
+
+                TellMaster(out.str().c_str());
+            }
+
+            // send the money to the bot and remove it from the creature
+            loot->SendGold(m_bot);
+        }
+
+        if (!loot->AutoStore(m_bot, false, NULL_BAG, NULL_SLOT))
+            sLog.outDebug("PLAYERBOT Debug: Failed to get loot from pickpocketed NPC");
+
+        // release the loot whatever happened
+        loot->Release(m_bot);
+    }
+    return false; // ensures that the rogue only pick pockets target once
+}
+
+bool PlayerbotAI::HasSpellReagents(uint32 spellId)
+{
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    if (m_bot->CanNoReagentCast(pSpellInfo))
+        return true;
+
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+
+        if (!m_bot->HasItemCount(itemid, count))
+            return false;
+    }
+
+    return true;
+}
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractQuestIds(const std::string& text, std::list<uint32>& questIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hquest:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            questIds.push_back(id);
+    }
+}
+
+// Build an hlink for Weapon skills in Aqua
+void PlayerbotAI::MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid)
+{
+    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    out << "|cff00ffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << " : " << m_bot->GetSkillValue(skillid) << " /" << m_bot->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+// Build an hlink for spells in White
+void PlayerbotAI::MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out)
+{
+    int    loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
+}
+
+// Builds a hlink for an item, but since its
+// only a ItemPrototype, we cant fill in everything
+void PlayerbotAI::MakeItemLink(const ItemPrototype *item, std::ostringstream &out)
+{
+    // Color
+    out << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << item->ItemId << ":";
+
+    // Permanent enchantment, gems, 4 unknowns, and reporter_level
+    // ->new items wont have enchantments or gems so..
+    out << "0:0:0:0:0:0:0:0:0";
+
+    // Name
+    std::string name = item->Name1;
+    ItemLocalization(name, item->ItemId);
+    out << "|h[" << name << "]|h|r";
+}
+
+// Builds a hlink for an item, includes everything
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
+void PlayerbotAI::MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemPrototype *proto = item->GetProto();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << proto->ItemId << ":";
+
+    // Permanent enchantment
+    out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    // Gems
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    out << g1 << ":" << g2 << ":" << g3 << ":";
+
+    // Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
+    // Other stuff, don't know what it is
+    out << "0:0:0:0:";
+
+    // Reporter Level
+    out << "0";
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+void PlayerbotAI::extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htitle:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            auctionIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractSpellId(const std::string& text, uint32 &spellId) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+
+    int i = text.find("Hspell:", pos);
+    if (i == -1)
+        return;
+
+    // DEBUG_LOG("[PlayerbotAI]: extractSpellId - first pos %u i %u",pos,i);
+    pos = i + 7;     // start of window in text 16 + 7 = 23
+    int endPos = text.find('|', pos);
+    if (endPos == -1)
+        return;
+
+    // DEBUG_LOG("[PlayerbotAI]: extractSpellId - second endpos : %u pos : %u",endPos,pos);
+    std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+    spellId = atol(idC.c_str());
+    pos = endPos;     // end
+}
+
+void PlayerbotAI::extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hspell:", pos);
+        if (i == -1)
+            break;
+
+        // DEBUG_LOG("[PlayerbotAI]: extractSpellIdList - first pos %u i %u",pos,i);
+        pos = i + 7;     // start of window in text 16 + 7 = 23
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+
+        // DEBUG_LOG("[PlayerbotAI]: extractSpellIdList - second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+        uint32 spellId = atol(idC.c_str());
+        pos = endPos;     // end
+
+        if (spellId)
+            m_spellsToLearn.push_back(spellId);
+    }
+}
+
+void PlayerbotAI::extractTalentIds(const std::string &text, std::list<talentPair> &talentIds) const
+{
+    // Link format:
+    // |color|Htalent:talent_id:rank|h[name]|h|r
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htalent:", pos);
+        if (i == -1)
+            break;
+        pos = i + 8;
+        // DEBUG_LOG("extractTalentIds first pos %u i %u",pos,i);
+        // extract talent_id
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        // DEBUG_LOG("extractTalentId second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos + 1;
+        // extract rank
+        endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        // DEBUG_LOG("extractTalentId third endpos : %u pos : %u",endPos,pos);
+        std::string rankC = text.substr(pos, endPos - pos);
+        uint32 rank = atol(rankC.c_str());
+        pos = endPos + 1;
+
+        // DEBUG_LOG("extractTalentId second id : %u  rank : %u",id,rank);
+
+        if (id)
+            talentIds.push_back(std::pair<uint32, uint32>(id, rank));
+    }
+}
+
+void PlayerbotAI::extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const
+{
+
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        std::string guidC = text.substr(pos, endPos - pos);     // get string within window i.e guid 22 - 18 =  4
+        uint32 guid = atol(guidC.c_str());     // convert ascii to long int
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        ObjectGuid lootCurrent = ObjectGuid(HIGHGUID_GAMEOBJECT, entry, guid);
+
+        if (guid)
+            m_lootTargets.push_back(lootCurrent);
+    }
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const
+{
+    // if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; itemIdSearchList.size() > 0 && slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    // look for items in main bag
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetObjectGuid()))
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    // for all for items in other bags
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (!pBag)
+            continue;
+
+        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item* const pItem = m_bot->GetItemByPos(bag, slot);
+            if (!pItem)
+                continue;
+
+            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if (pItem->GetProto()->ItemId != *it)
+                    continue;
+
+                if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetObjectGuid()))
+                    continue;
+
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyGO()
+{
+    if (m_collectObjects.empty())
+        return;
+
+    std::list<GameObject*> tempTargetGOList;
+    float radius = 20.0f;
+
+    for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); itr++)
+    {
+        uint32 entry = *(itr);
+        GameObjectInfo const * gInfo = ObjectMgr::GetGameObjectInfo(entry);
+
+        uint32 lootid = gInfo->GetLootId();
+
+        if(gInfo->GetLootId() > 0)
+        {
+            QueryResult *result;
+            result = WorldDatabase.PQuery("SELECT item FROM gameobject_loot_template WHERE entry = '%u'",lootid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 Item = fields[0].GetUInt32();
+                if (!IsInQuestItemList(Item))    // quest item needed
+                {
+                    m_collectObjects.remove(entry); // remove gameobject from collect list
+                    delete result;
+                    return;
+                }
+                delete result;
+            }
+        }
+
+        // search for GOs with entry, within range of m_bot
+        MaNGOS::GameObjectEntryInPosRangeCheck go_check(*m_bot, entry, m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), radius);
+        MaNGOS::GameObjectListSearcher<MaNGOS::GameObjectEntryInPosRangeCheck> checker(tempTargetGOList, go_check);
+        Cell::VisitGridObjects(m_bot, checker, radius);
+
+        // no objects found, continue to next entry
+        if (tempTargetGOList.empty())
+            continue;
+
+        // add any objects found to our lootTargets
+        for (std::list<GameObject*>::iterator iter = tempTargetGOList.begin(); iter != tempTargetGOList.end(); iter++)
+        {
+            GameObject* go = (*iter);
+            if (go->isSpawned())
+                m_lootTargets.push_back(go->GetObjectGuid());
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyCreature()
+{
+    std::list<Creature*> creatureList;
+    float radius = 2.5;
+
+    CellPair pair(MaNGOS::ComputeCellPair(m_bot->GetPositionX(), m_bot->GetPositionY()));
+    Cell cell(pair);
+
+    MaNGOS::AnyUnitInObjectRangeCheck go_check(m_bot, radius);
+    MaNGOS::CreatureListSearcher<MaNGOS::AnyUnitInObjectRangeCheck> go_search(creatureList, go_check);
+    TypeContainerVisitor<MaNGOS::CreatureListSearcher<MaNGOS::AnyUnitInObjectRangeCheck>, GridTypeMapContainer> go_visit(go_search);
+
+    // Get Creatures
+    cell.Visit(pair, go_visit, *(m_bot->GetMap()), *(m_bot), radius);
+
+    // if (!creatureList.empty())
+    //    TellMaster("Found %i Creatures.", creatureList.size());
+
+    for (std::list<Creature*>::iterator iter = creatureList.begin(); iter != creatureList.end(); iter++)
+    {
+        Creature* currCreature = *iter;
+
+        for (std::list<enum NPCFlags>::iterator itr = m_findNPC.begin(); itr != m_findNPC.end(); itr++)
+        {
+            uint32 npcflags = currCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+            if (!(*itr & npcflags))
+                continue;
+
+            WorldObject *wo = m_bot->GetMap()->GetWorldObject(currCreature->GetObjectGuid());
+
+            if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectBoundingRadius())
+            {
+                float x, y, z;
+                wo->GetContactPoint(m_bot, x, y, z, wo->GetObjectBoundingRadius());
+                m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z, false);
+                // give time to move to point before trying again
+                SetIgnoreUpdateTime(1);
+            }
+
+            if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+            {
+
+                // DEBUG_LOG("%s is interacting with (%s)",m_bot->GetName(),currCreature->GetCreatureInfo()->Name);
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(currCreature->GetCreatureInfo()->GossipMenuId);
+
+                // prepares quest menu when true
+                bool canSeeQuests = currCreature->GetCreatureInfo()->GossipMenuId == m_bot->GetDefaultGossipMenuForSource(wo);
+
+                // if canSeeQuests (the default, top level menu) and no menu options exist for this, use options from default options
+                if (pMenuItemBounds.first == pMenuItemBounds.second && canSeeQuests)
+                    pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(0);
+
+                for (GossipMenuItemsMap::const_iterator it = pMenuItemBounds.first; it != pMenuItemBounds.second; it++)
+                {
+                    if (!(it->second.npc_option_npcflag & npcflags))
+                        continue;
+
+                    DEBUG_LOG("GOSSIP_OPTION_ (%u)",it->second.option_id);
+
+                    switch (it->second.option_id)
+                    {
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // Manage banking actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); )
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // withdraw items
+                                        case WITHDRAW:
+                                        {
+                                            // TellMaster("Withdraw items");
+                                            if (!Withdraw(ait->second))
+                                                DEBUG_LOG("Withdraw: Couldn't withdraw (%u)", ait->second);
+                                            break;
+                                        }
+                                        // deposit items
+                                        case DEPOSIT:
+                                        {
+                                            // TellMaster("Deposit items");
+                                            if (!Deposit(ait->second))
+                                                DEBUG_LOG("Deposit: Couldn't deposit (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                    ait = m_tasks.erase(ait);
+                                }
+                            BankBalance();
+                            break;
+                        }
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        case GOSSIP_OPTION_GOSSIP:
+                        case GOSSIP_OPTION_INNKEEPER:
+                        case GOSSIP_OPTION_TRAINER:
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        case GOSSIP_OPTION_VENDOR:
+                        {
+                            // Manage questgiver, trainer, innkeeper & vendor actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); )
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // take new quests
+                                        case TAKE:
+                                        {
+                                            // TellMaster("Accepting quest");
+                                            if (!AddQuest(ait->second, wo))
+                                                DEBUG_LOG("AddQuest: Couldn't add quest (%u)", ait->second);
+                                            break;
+                                        }
+                                        // list npc quests
+                                        case LIST:
+                                        {
+                                            // TellMaster("Show available npc quests");
+                                            ListQuests(wo);
+                                            break;
+                                        }
+                                        // end quests
+                                        case END:
+                                        {
+                                            // TellMaster("Turn in available quests");
+                                            TurnInQuests(wo);
+                                            break;
+                                        }
+                                        // sell items
+                                        case SELL:
+                                        {
+                                            // TellMaster("Selling items");
+                                            Sell(ait->second);
+                                            break;
+                                        }
+                                        // repair items
+                                        case REPAIR:
+                                        {
+                                            // TellMaster("Repairing items");
+                                            Repair(ait->second, currCreature);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                    ait = m_tasks.erase(ait);
+                                }
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // Manage auctioneer actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); )
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // add new auction item
+                                        case ADD:
+                                        {
+                                            // TellMaster("Creating auction");
+                                            AddAuction(ait->second, currCreature);
+                                            break;
+                                        }
+                                        // cancel active auction
+                                        case REMOVE:
+                                        {
+                                            // TellMaster("Cancelling auction");
+                                            if (!RemoveAuction(ait->second))
+                                                DEBUG_LOG("RemoveAuction: Couldn't remove auction (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                    ait = m_tasks.erase(ait);
+                                }
+                            ListAuctions();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+                }
+            }
+            itr = m_findNPC.erase(itr); // all done lets go home
+            m_bot->GetMotionMaster()->Clear(false);
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+// Playerbot wrapper to know if a target is elite or not
+// This is used by the AI to switch from one action to another
+// if creature is dangerous (elite)
+bool PlayerbotAI::IsElite(Unit* pTarget) const
+{
+    if (!pTarget)
+        return false;
+
+    if (Creature * pCreature = (Creature*) pTarget)
+    {
+        return (pCreature->IsElite() || pCreature->IsWorldBoss());
+    }
+
+    return false;
+}
+
+// Check if bot target has one of the following auras: Sap, Polymorph, Shackle Undead, Banish, Seduction, Freezing Trap, Hibernate
+// This is used by the AI to prevent bots from attacking crowd control targets
+
+static const uint32 uAurasIds[21] =
+{
+    118, 12824, 12825, 12826,   // polymorph
+    28272, 28271,               // polymorph pig, turtle
+    9484, 9485, 10955,          // shackle
+    6358,                       // seduction
+    710, 18647,                 // banish
+    6770, 2070, 11297,          // sap
+    3355, 14308, 14309,         // freezing trap (effect auras IDs, not spell IDs)
+    2637, 18657, 18658          // hibernate
+};
+
+bool PlayerbotAI::IsNeutralized(Unit* pTarget)
+{
+    if (!pTarget)
+        return false;
+
+    for (uint8 i = 0; i < countof(uAurasIds); ++i)
+    {
+        if (pTarget->HasAura(uAurasIds[i], EFFECT_INDEX_0))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::CanStore()
+{
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemPrototype const* pBagProto = pBag->GetProto();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+    }
+    return totalfree;
+}
+
+// use item on self
+void PlayerbotAI::UseItem(Item *item)
+{
+    UseItem(item, TARGET_FLAG_SELF, ObjectGuid());
+}
+
+// use item on equipped item
+void PlayerbotAI::UseItem(Item *item, uint8 targetInventorySlot)
+{
+    if (targetInventorySlot >= EQUIPMENT_SLOT_END)
+        return;
+
+    Item* const targetItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, targetInventorySlot);
+    if (!targetItem)
+        return;
+
+    UseItem(item, TARGET_FLAG_ITEM, targetItem->GetObjectGuid());
+}
+
+// use item on unit
+void PlayerbotAI::UseItem(Item *item, Unit *target)
+{
+    if (!target)
+        return;
+
+    UseItem(item, TARGET_FLAG_UNIT, target->GetObjectGuid());
+}
+
+// generic item use method
+void PlayerbotAI::UseItem(Item *item, uint16 targetFlag, ObjectGuid targetGUID)
+{
+    if (!item)
+        return;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 spell_count = 1;
+    ObjectGuid item_guid = item->GetObjectGuid();
+
+    if (uint32 questid = item->GetProto()->StartQuest)
+    {
+        std::ostringstream report;
+
+        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            m_bot->GetMotionMaster()->Clear(true);
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8 + 4 + 4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            report << "|cffffff00Quest taken |r" << qInfo->GetTitle();
+            TellMaster(report.str());
+        }
+        return;
+    }
+
+    uint32 spellId = 0;
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (item->GetProto()->Spells[i].SpellId > 0)
+        {
+            spellId = item->GetProto()->Spells[i].SpellId;
+            break;
+        }
+    }
+
+    SpellEntry const * spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+    {
+        TellMaster("Can't find spell entry for spell %u on item %u", spellId, item->GetEntry());
+        return;
+    }
+
+    SpellCastTimesEntry const * castingTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
+    if (!castingTimeEntry)
+    {
+        TellMaster("Can't find casting time entry for spell %u with index %u", spellId, spellInfo->CastingTimeIndex);
+        return;
+    }
+    // stop movement to prevent cancel spell casting
+    else if (castingTimeEntry && castingTimeEntry->CastTime)
+    {
+        DEBUG_LOG ("[PlayerbotAI]: UseItem - Bot movement reset for casting %s (%u)", spellInfo->SpellName[0], spellId);
+        MovementClear();
+    }
+
+    m_CurrentlyCastingSpellId = spellId;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 13);
+    *packet << bagIndex;
+    *packet << slot;
+    *packet << spell_count;
+    *packet << targetFlag;
+
+    if (targetFlag & (TARGET_FLAG_UNIT | TARGET_FLAG_ITEM | TARGET_FLAG_OBJECT))
+        *packet << targetGUID.WriteAsPacked();
+
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item* src_Item)
+{
+    uint8 src_bagIndex = src_Item->GetBagSlot();
+    uint8 src_slot = src_Item->GetSlot();
+
+    DEBUG_LOG("PlayerbotAI::EquipItem: %s in srcbag = %u, srcslot = %u", src_Item->GetProto()->Name1, src_bagIndex, src_slot);
+
+    uint16 dest;
+    InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, src_Item, !src_Item->IsBag());
+    if (msg != EQUIP_ERR_OK)
+    {
+        m_bot->SendEquipError(msg, src_Item, nullptr);
+        return;
+    }
+
+    uint16 src = src_Item->GetPos();
+    if (dest == src)                                        // prevent equip in same slot, only at cheat
+        return;
+
+    Item *dest_Item = m_bot->GetItemByPos(dest);
+    if (!dest_Item)                                          // empty slot, simple case
+    {
+        m_bot->RemoveItem(src_bagIndex, src_slot, true);
+        m_bot->EquipItem(dest, src_Item, true);
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+    else                                                    // have currently equipped item, not simple case
+    {
+        uint8 dest_bagIndex = dest_Item->GetBagSlot();
+        uint8 dest_slot = dest_Item->GetSlot();
+
+        msg = m_bot->CanUnequipItem(dest, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, nullptr);
+            return;
+        }
+
+        // check dest->src move possibility
+        ItemPosCountVec sSrc;
+        if (m_bot->IsInventoryPos(src))
+        {
+            msg = m_bot->CanStoreItem(src_bagIndex, src_slot, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(src_bagIndex, NULL_SLOT, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dest_Item, true);
+        }
+
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, src_Item);
+            return;
+        }
+
+        // now do moves, remove...
+        m_bot->RemoveItem(dest_bagIndex, dest_slot, false);
+        m_bot->RemoveItem(src_bagIndex, src_slot, false);
+
+        // add to dest
+        m_bot->EquipItem(dest, src_Item, true);
+
+        // add to src
+        if (m_bot->IsInventoryPos(src))
+            m_bot->StoreItem(sSrc, dest_Item, true);
+
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    DEBUG_LOG ("[PlayerbotAI]: TradeItem - slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+               slot,
+               (m_bot->GetTrader() ? 1 : 0),
+               (item.IsInTrade() ? 1 : 0),
+               (item.CanBeTraded() ? 1 : 0)
+               );
+
+    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED))
+        return false;
+
+    int8 tradeSlot = -1;
+
+    TradeData* pTrade = m_bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == nullptr)
+        tradeSlot = slot;
+    else
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == nullptr)
+            {
+                tradeSlot = i;
+                // reserve trade slot to allow multiple items to be traded
+                pTrade->SetItem(TradeSlots(i), const_cast<Item*>(&item));
+            }
+        }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::DoTeleport(WorldObject& /*obj*/)
+{
+    SetIgnoreUpdateTime(6);
+    PlayerbotChatHandler ch(GetMaster());
+    if (!ch.teleport(*m_bot))
+    {
+        ch.sysmessage(".. could not be teleported ..");
+        // DEBUG_LOG ("[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+        return false;
+    }
+    return true;
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    SetIgnoreUpdateTime(6);
+    m_bot->GetMotionMaster()->Clear(true);
+    if (m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8+4+4);
+        p << m_bot->GetObjectGuid();
+        p << (uint32) 0; // supposed to be flags? not used currently
+        p << (uint32) CurrentTime(); // time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAckOpcode(p);
+    }
+    else if (m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+// Localization support
+void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const *pItemInfo = sObjectMgr.GetItemLocale(itemID);
+    if (pItemInfo)
+        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if (Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+}
+
+void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const *pQuestInfo = sObjectMgr.GetQuestLocale(questID);
+    if (pQuestInfo)
+        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if (Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+}
+
+void PlayerbotAI::CreatureLocalization(std::string& creatureName, const uint32 entry) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const *pCreatureInfo = sObjectMgr.GetCreatureLocale(entry);
+    if (pCreatureInfo)
+        if (pCreatureInfo->Name.size() > loc && !pCreatureInfo->Name[loc].empty())
+        {
+            const std::string title = pCreatureInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                creatureName = title.c_str();
+        }
+}
+
+void PlayerbotAI::GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const *pGameObjectInfo = sObjectMgr.GetGameObjectLocale(entry);
+    if (pGameObjectInfo)
+        if (pGameObjectInfo->Name.size() > loc && !pGameObjectInfo->Name[loc].empty())
+        {
+            const std::string title = pGameObjectInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                gameobjectName = title.c_str();
+        }
+}
+
+// Helper function for automatically selling poor quality items to the vendor
+void PlayerbotAI::_doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold)
+{
+    if (!item)
+        return;
+
+    if (item->CanBeTraded() && item->GetProto()->Quality == ITEM_QUALITY_POOR)
+    {
+        uint32 cost = item->GetCount() * item->GetProto()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(item);
+
+        ++TotalSold;
+        TotalCost += cost;
+
+        report << "Sold ";
+        MakeItemLink(item, report, true);
+        report << " for ";
+
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << "|r|cfffffc00g|r|cff00ff00";
+        if (silver > 0)
+            report << silver << "|r|cffc0c0c0s|r|cff00ff00";
+        report << cost << "|r|cff95524Cc|r|cff00ff00\n";
+    }
+    else if (item->GetProto()->SellPrice > 0)
+        MakeItemLink(item, canSell, true);
+}
+
+bool PlayerbotAI::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, nullptr);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->StoreItem(dest, pItem, true);
+
+        report << "Withdrawn ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+bool PlayerbotAI::Deposit(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, nullptr);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->BankItem(dest, pItem, true);
+
+        report << "Deposited ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+void PlayerbotAI::BankBalance()
+{
+    std::ostringstream report;
+
+    report << "In my bank\n ";
+    report << "My item slots: ";
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            MakeItemLink(item, report, true);
+    }
+    TellMaster(report.str());
+
+    // and each of my bank bags
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            goods << "\nMy ";
+            const ItemPrototype* const pBagProto = pBag->GetProto();
+            std::string bagName = pBagProto->Name1;
+            ItemLocalization(bagName, pBagProto->ItemId);
+            goods << bagName << " slot: ";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    MakeItemLink(item, goods, true);
+            }
+            TellMaster(goods.str());
+        }
+    }
+}
+
+void PlayerbotAI::Repair(const uint32 itemid, Creature* rCreature)
+{
+    Item* rItem = FindItem(itemid); // if item equipped or in bags
+    uint8 IsInGuild = (m_bot->GetGuildId() != 0) ? uint8(1) : uint8(0);
+    ObjectGuid itemGuid = (rItem) ? rItem->GetObjectGuid() : ObjectGuid();
+
+    WorldPacket* const packet = new WorldPacket(CMSG_REPAIR_ITEM, 8 + 8 + 1);
+    *packet << rCreature->GetObjectGuid();  // repair npc guid
+    *packet << itemGuid; // if item specified then repair this, else repair all
+    *packet << IsInGuild;  // guildbank yes=1 no=0
+    m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+}
+
+bool PlayerbotAI::RemoveAuction(const uint32 auctionid)
+{
+    QueryResult *result = CharacterDatabase.PQuery(
+        "SELECT houseid,itemguid,item_template,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auction WHERE id = '%u'", auctionid);
+
+    AuctionEntry *auction;
+
+    if (result)
+    {
+        Field *fields = result->Fetch();
+
+        auction = new AuctionEntry;
+        auction->Id = auctionid;
+        uint32 houseid  = fields[0].GetUInt32();
+        auction->itemGuidLow = fields[1].GetUInt32();
+        auction->itemTemplate = fields[2].GetUInt32();
+        auction->owner = fields[3].GetUInt32();
+        auction->buyout = fields[4].GetUInt32();
+        auction->expireTime = fields[5].GetUInt32();
+        auction->bidder = fields[6].GetUInt32();
+        auction->bid = fields[7].GetUInt32();
+        auction->startbid = fields[8].GetUInt32();
+        auction->deposit = fields[9].GetUInt32();
+        auction->auctionHouseEntry = nullptr;                  // init later
+
+        // check if sold item exists for guid
+        // and item_template in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
+        Item* pItem = sAuctionMgr.GetAItem(auction->itemGuidLow);
+        if (!pItem)
+        {
+            auction->DeleteFromDB();
+            sLog.outError("Auction %u has not a existing item : %u, deleted", auction->Id, auction->itemGuidLow);
+            delete auction;
+            delete result;
+            return false;
+        }
+
+        auction->auctionHouseEntry = sAuctionHouseStore.LookupEntry(houseid);
+
+        // Attempt send item back to owner
+        std::ostringstream msgAuctionCanceledOwner;
+        msgAuctionCanceledOwner << auction->itemTemplate << ":0:" << AUCTION_CANCELED << ":0:0";
+
+        // item will deleted or added to received mail list
+        MailDraft(msgAuctionCanceledOwner.str(), "")    // TODO: fix body
+        .AddItem(pItem)
+        .SendMailTo(MailReceiver(ObjectGuid(HIGHGUID_PLAYER, auction->owner)), auction, MAIL_CHECK_MASK_COPIED);
+
+        if (sAuctionMgr.RemoveAItem(auction->itemGuidLow))
+            m_bot->GetSession()->SendAuctionCommandResult(auction, AUCTION_REMOVED, AUCTION_OK);
+
+        auction->DeleteFromDB();
+
+        delete auction;
+        delete result;
+    }
+    return true;
+}
+
+void PlayerbotAI::ListQuests(WorldObject * questgiver)
+{
+    if (!questgiver)
+        return;
+
+    // list all bot quests this NPC has
+    m_bot->PrepareQuestMenu(questgiver->GetObjectGuid());
+    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+    std::ostringstream out;
+    for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+        uint32 questID = qItem.m_qId;
+        Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+
+        std::string questTitle  = pQuest->GetTitle();
+        QuestLocalization(questTitle, questID);
+
+        if (m_bot->SatisfyQuestStatus(pQuest, false))
+        {
+            if (gQuestFetch != 1)
+            {
+                out << "|cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+            else
+            {
+                if (!AddQuest(questID, questgiver))
+                    continue;
+            }
+        }
+    }
+    if (!out.str().empty())
+        TellMaster(out.str());
+}
+
+bool PlayerbotAI::AddQuest(const uint32 entry, WorldObject * questgiver)
+{
+    std::ostringstream out;
+
+    Quest const* qInfo = sObjectMgr.GetQuestTemplate(entry);
+    if (!qInfo)
+    {
+        ChatHandler(GetMaster()).PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        return false;
+    }
+
+    if (m_bot->GetQuestStatus(entry) == QUEST_STATUS_COMPLETE)
+    {
+        TellMaster("I already completed that quest.");
+        return false;
+    }
+    else if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        if (!m_bot->SatisfyQuestStatus(qInfo, false))
+            TellMaster("I already have that quest.");
+        else
+            TellMaster("I can't take that quest.");
+        return false;
+    }
+    else if (!m_bot->SatisfyQuestLog(false))
+    {
+        TellMaster("My quest log is full.");
+        return false;
+    }
+    else if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, questgiver);
+
+        std::string questTitle  = qInfo->GetTitle();
+        QuestLocalization(questTitle, entry);
+
+        out << "|cffffff00Quest taken " << "|cff808080|Hquest:" << entry << ':' << qInfo->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+        if (m_bot->CanCompleteQuest(entry))
+            m_bot->CompleteQuest(entry);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->ReqItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->ReqCreatureOrGOCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        TellMaster(out.str());
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::ListAuctions()
+{
+    std::ostringstream report;
+
+    QueryResult *result = CharacterDatabase.PQuery(
+        "SELECT id,itemguid,item_template,time,buyguid,lastbid FROM auction WHERE itemowner = '%u'", m_bot->GetObjectGuid().GetCounter());
+    if (result)
+    {
+        report << "My active auctions are: \n";
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 Id = fields[0].GetUInt32();
+            uint32 itemGuidLow = fields[1].GetUInt32();
+            uint32 itemTemplate = fields[2].GetUInt32();
+            time_t expireTime = fields[3].GetUInt32();
+            uint32 bidder = fields[4].GetUInt32();
+            uint32 bid = fields[5].GetUInt32();
+
+            time_t remtime = expireTime - CurrentTime();
+
+            tm* aTm = gmtime(&remtime);
+
+            if (expireTime > CurrentTime())
+            {
+                Item* aItem = sAuctionMgr.GetAItem(itemGuidLow);
+                if (aItem)
+                {
+                    // Name
+                    uint32 count = aItem->GetCount();
+                    std::string name = aItem->GetProto()->Name1;
+                    ItemLocalization(name, itemTemplate);
+                    report << "\n|cffffffff|Htitle:" << Id << "|h[" << name;
+                    if (count > 1)
+                        report << "|cff00ff00x" << count << "|cffffffff" << "]|h|r";
+                    else
+                        report << "]|h|r";
+                }
+
+                if (bidder)
+                {
+                    ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, bidder);
+                    std::string bidder_name;
+                    if (sObjectMgr.GetPlayerNameByGUID(guid, bidder_name))
+                        report << " " << bidder_name << ": ";
+
+                    uint32 gold = uint32(bid / 10000);
+                    bid -= (gold * 10000);
+                    uint32 silver = uint32(bid / 100);
+                    bid -= (silver * 100);
+
+                    if (gold > 0)
+                        report << gold << "|r|cfffffc00g|r|cff00ff00";
+                    if (silver > 0)
+                        report << silver << "|r|cffc0c0c0s|r|cff00ff00";
+                    report << bid << "|r|cff95524Cc|r|cff00ff00";
+                }
+                if(aItem)
+                    report << " ends: " << aTm->tm_hour << "|cff0070dd|hH|h|r " << aTm->tm_min << "|cff0070dd|hmin|h|r";
+            }
+        } while (result->NextRow());
+
+        delete result;
+        TellMaster(report.str().c_str());
+    }
+}
+
+void PlayerbotAI::AddAuction(const uint32 itemid, Creature* aCreature)
+{
+    Item* aItem = FindItem(itemid);
+    if (aItem)
+    {
+        std::ostringstream out;
+        srand(CurrentTime());
+        uint32 duration[3] = { 720, 1440, 2880 };  // 720 = 12hrs, 1440 = 24hrs, 2880 = 48hrs
+        uint32 etime = duration[rand() % 3];
+
+        uint32 min = urand(aItem->GetProto()->SellPrice * aItem->GetCount(), aItem->GetProto()->BuyPrice * aItem->GetCount()) * (aItem->GetProto()->Quality + 1);
+        uint32 max = urand(aItem->GetProto()->SellPrice * aItem->GetCount(), aItem->GetProto()->BuyPrice * aItem->GetCount()) * (aItem->GetProto()->Quality + 1);
+
+        out << "Auctioning ";
+        MakeItemLink(aItem, out, true);
+        out << " with " << aCreature->GetCreatureInfo()->Name;
+        TellMaster(out.str().c_str());
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUCTION_SELL_ITEM, 8 + 4 + 8 + 4 + 4 + 4 + 4);
+        *packet << aCreature->GetObjectGuid();     // auctioneer guid
+        *packet << uint32(1);                      // const 1
+        *packet << aItem->GetObjectGuid();         // item guid
+        *packet << aItem->GetCount();      // stacksize
+        *packet << uint32((min < max) ? min : max);  // starting bid
+        *packet << uint32((max > min) ? max : min);  // buyout
+        *packet << uint32(etime);  // auction duration
+
+        m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+    }
+}
+
+void PlayerbotAI::Sell(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        uint32 cost = pItem->GetCount() * pItem->GetProto()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(pItem);
+
+        report << "Sold ";
+        MakeItemLink(pItem, report, true);
+        report << " for ";
+
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << "|r|cfffffc00g|r|cff00ff00";
+        if (silver > 0)
+            report << silver << "|r|cffc0c0c0s|r|cff00ff00";
+        report << cost << "|r|cff95524Cc|r|cff00ff00";
+
+        TellMaster(report.str());
+    }
+}
+
+void PlayerbotAI::SellGarbage(bool bListNonTrash, bool bDetailTrashSold, bool bVerbose)
+{
+    uint32 SoldCost = 0;
+    uint32 SoldQuantity = 0;
+    std::ostringstream report, goods;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+    }
+
+    // and each of our other packs
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            // Very nice, but who cares what bag it's in?
+            //const ItemPrototype* const pBagProto = pBag->GetProto();
+            //std::string bagName = pBagProto->Name1;
+            //ItemLocalization(bagName, pBagProto->ItemId);
+            //goods << "\nIn my " << bagName << ":";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+            }
+        }
+    }
+
+    if (!bDetailTrashSold)
+        report.str(""); // clear ostringstream
+
+    if (SoldCost > 0)
+    {
+        if (bDetailTrashSold)
+            report << "Sold total " << SoldQuantity << " item(s) for ";
+        else
+            report << "Sold " << SoldQuantity << " trash item(s) for ";
+        uint32 gold = uint32(SoldCost / 10000);
+        SoldCost -= (gold * 10000);
+        uint32 silver = uint32(SoldCost / 100);
+        SoldCost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << "|r|cfffffc00g|r|cff00ff00";
+        if (silver > 0)
+            report << silver << "|r|cffc0c0c0s|r|cff00ff00";
+        report << SoldCost << "|r|cff95524Cc|r|cff00ff00";
+
+        if (bVerbose)
+            TellMaster(report.str());
+    }
+
+    // For all bags, non-gray sellable items
+    if (bVerbose)
+    {
+        if (bListNonTrash && goods.str().size() > 0)
+        {
+            if (SoldQuantity)
+                TellMaster("I could also sell: %s", goods.str().c_str());
+            else
+                TellMaster("I could sell: %s", goods.str().c_str());
+        }
+        else if (SoldQuantity == 0 && goods.str().size() == 0)
+        {
+            TellMaster("No items to sell, trash or otherwise.");
+        }
+    }
+}
+
+void PlayerbotAI::GetTaxi(ObjectGuid guid, BotTaxiNode& nodes)
+{
+    // DEBUG_LOG("[PlayerbotAI]: GetTaxi - %s node[0] %d node[1] %d", m_bot->GetName(), nodes[0], nodes[1]);
+
+    Creature *unit = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!unit)
+    {
+        DEBUG_LOG("[PlayerbotAI]: GetTaxi - %s not found or you can't interact with it.", guid.GetString().c_str());
+        return;
+    }
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[0]) ? 0 : 1)
+        return;
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[nodes.size() - 1]) ? 0 : 1)
+        return;
+
+    if (m_bot->GetPlayerbotAI()->GetMovementOrder() != MOVEMENT_STAY)
+    {
+        m_taxiNodes = nodes;
+        m_taxiMaster = guid;
+        SetState(BOTSTATE_FLYING);
+    }
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
+{
+    // prevent bot task spam
+    m_tasks.unique();
+    m_findNPC.unique();
+
+    DEBUG_LOG("bot chat(%s)",text.c_str());
+
+    // ignore any messages from Addons
+    if (text.empty()                                   ||
+        text.find("X-Perl")      != std::wstring::npos ||
+        text.find("HealBot")     != std::wstring::npos ||
+        text.find("HealComm")    != std::wstring::npos ||   // "HealComm    99990094"
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA")        != std::wstring::npos ||
+        text.find("GathX")       == 0)                      // Gatherer
+        return;
+
+    // if message is not from a player in the masters account auto reply and ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {
+        // only tell the player once instead of endlessly nagging them
+        if (m_ignorePlayersChat.find(fromPlayer.GetObjectGuid()) == m_ignorePlayersChat.end())
+        {
+            std::string msg = "I can't talk to you. Please speak to my master ";
+            msg += GetMaster()->GetName();
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+            m_ignorePlayersChat.insert(fromPlayer.GetObjectGuid());
+        }
+        return;
+    }
+
+    // Passed along to ExtractCommand, if (sub)command is found "input" will only contain the rest of the string (or "")
+    std::string input = text.c_str();
+
+    // if in the middle of a trade, and player asks for an item/money
+    // WARNING: This makes it so you can't use any other commands during a trade!
+    if (m_bot->GetTrader() && m_bot->GetTrader()->GetObjectGuid() == fromPlayer.GetObjectGuid())
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else if (!strncmp(text.c_str(), "nt ", 3))
+        {
+            if (itemIds.size() > 1)
+                SendWhisper("There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer);
+            else
+            {
+                std::list<Item*> itemList;
+                findItemsInEquip(itemIds, itemList);
+                findItemsInInv(itemIds, itemList);
+                if (itemList.size() > 0)
+                    TradeItem((**itemList.begin()), TRADE_SLOT_NONTRADED);
+                else
+                    SendWhisper("I do not have this item equipped or in my bags!", fromPlayer);
+            }
+        }
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+    // Handle general commands
+    else if (ExtractCommand("help", input))
+        _HandleCommandHelp(input, fromPlayer);
+
+    else if (ExtractCommand("reset", input))
+        _HandleCommandReset(input, fromPlayer);
+    else if (ExtractCommand("report", input))
+        _HandleCommandReport(input, fromPlayer);
+    else if (ExtractCommand("orders", input))
+        _HandleCommandOrders(input, fromPlayer);
+    else if (ExtractCommand("follow", input) || ExtractCommand("come", input))
+        _HandleCommandFollow(input, fromPlayer);
+    else if (ExtractCommand("stay", input) || ExtractCommand("stop", input))
+        _HandleCommandStay(input, fromPlayer);
+    else if (ExtractCommand("attack", input))
+        _HandleCommandAttack(input, fromPlayer);
+    else if (ExtractCommand("pull", input))
+        _HandleCommandPull(input, fromPlayer);
+
+    else if (ExtractCommand("neutralize", input) || ExtractCommand("neutral", input))
+        _HandleCommandNeutralize(input, fromPlayer);
+
+    else if (ExtractCommand("cast", input, true)) // true -> "cast" OR "c"
+        _HandleCommandCast(input, fromPlayer);
+
+    else if (ExtractCommand("sell", input))
+        _HandleCommandSell(input, fromPlayer);
+
+    else if (ExtractCommand("repair", input))
+        _HandleCommandRepair(input, fromPlayer);
+
+    else if (ExtractCommand("auction", input))
+        _HandleCommandAuction(input, fromPlayer);
+
+    else if (ExtractCommand("bank", input))
+        _HandleCommandBank(input, fromPlayer);
+
+    else if (ExtractCommand("use", input, true)) // true -> "use" OR "u"
+        _HandleCommandUse(input, fromPlayer);
+
+    else if (ExtractCommand("equip", input, true)) // true -> "equip" OR "e"
+        _HandleCommandEquip(input, fromPlayer);
+
+    // find project: 20:50 02/12/10 rev.4 item in world and wait until ordered to follow
+    else if (ExtractCommand("find", input, true)) // true -> "find" OR "f"
+        _HandleCommandFind(input, fromPlayer);
+
+    // get project: 20:50 02/12/10 rev.4 compact edition, handles multiple linked gameobject & improves visuals
+    else if (ExtractCommand("get", input, true)) // true -> "get" OR "g"
+        _HandleCommandGet(input, fromPlayer);
+
+    // Handle all collection related commands here
+    else if (ExtractCommand("collect", input))
+        _HandleCommandCollect(input, fromPlayer);
+
+    else if (ExtractCommand("quest", input))
+        _HandleCommandQuest(input, fromPlayer);
+
+    else if (ExtractCommand("pet", input))
+        _HandleCommandPet(input, fromPlayer);
+
+    else if (ExtractCommand("spells", input))
+        _HandleCommandSpells(input, fromPlayer);
+
+    // survey project: 20:50 02/12/10 rev.4 compact edition
+    else if (ExtractCommand("survey", input))
+        _HandleCommandSurvey(input, fromPlayer);
+
+    // Handle class & professions training:
+    else if (ExtractCommand("skill", input))
+        _HandleCommandSkill(input, fromPlayer);
+
+    // stats project: 11:30 15/12/10 rev.2 display bot statistics
+    else if (ExtractCommand("stats", input))
+        _HandleCommandStats(input, fromPlayer);
+
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            ObjectGuid questRewarderGUID = m_bot->GetSelectionGuid();
+            Object* const pNpc = (WorldObject *) m_bot->GetObjectByTypeMask(questRewarderGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.m_qId;
+                Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    !m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemPrototype const * const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+            }
+
+        }
+        else
+        {
+            // TODO: make this only in response to direct whispers (chatting in party chat can in fact be between humans)
+            std::string msg = "What? For a list of commands, ask for 'help'.";
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}
+
+/**
+* ExtractCommand looks for a command in a text string
+* sLookingFor       - string you're looking for (e.g. "help")
+* text              - string which may or may not start with sLookingFor
+* bUseShort         - does this command accept the shorthand command? If true, "help" would ALSO look for "h"
+*
+* returns true if the string has been found
+* returns false if the string has not been found
+*/
+bool PlayerbotAI::ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort)
+{
+    // ("help" + " ") < "help X"  AND  text's start (as big as sLookingFor) == sLookingFor
+    // Recommend AGAINST adapting this for non-space situations (thinking MangosZero)
+    // - unknown would risk being (short for "use") 'u' + "nknown"
+    if (sLookingFor.size() + 1 < text.size() && text.at(sLookingFor.size()) == ' '
+        && 0 == text.substr(0, sLookingFor.size()).compare(sLookingFor))
+    {
+        text = text.substr(sLookingFor.size()+1);
+        return true;
+    }
+
+    if (0 == text.compare(sLookingFor))
+    {
+        text = "";
+        return true;
+    }
+
+    if (bUseShort)
+    {
+        if (text.size() > 1 && sLookingFor.at(0) == text.at(0) && text.at(1) == ' ')
+        {
+            text = text.substr(2);
+            return true;
+        }
+        else if(text.size() == 1 && sLookingFor.at(0) == text.at(0))
+        {
+            text = "";
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotAI::_HandleCommandReset(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("reset does not have a subcommand.", fromPlayer);
+        return;
+    }
+    SetState(BOTSTATE_NORMAL);
+    MovementReset();
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+    UpdateAttackerInfo();
+    m_lootTargets.clear();
+    m_lootCurrent = ObjectGuid();
+    m_targetCombat = 0;
+}
+
+void PlayerbotAI::_HandleCommandReport(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("report cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SendQuestNeedList();
+}
+
+void PlayerbotAI::_HandleCommandOrders(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("delay", text))
+    {
+        uint32 gdelay;
+        sscanf(text.c_str(), "%d", &gdelay);
+        if (gdelay <= 10)
+        {
+            m_DelayAttack = gdelay;
+            TellMaster("Combat delay is now '%u' ", m_DelayAttack);
+            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_delay = '%u' WHERE guid = '%u'", m_DelayAttack, m_bot->GetGUIDLow());
+            return;
+        }
+        else
+            SendWhisper("Invalid delay. choose a number between 0 and 10", fromPlayer);
+        return;
+    }
+    else if (ExtractCommand("resume", text))
+        CombatOrderRestore();
+    else if (ExtractCommand("resume", text))
+        CombatOrderRestore();
+    else if (ExtractCommand("combat", text, true))
+    {
+        Unit *target = nullptr;
+
+        QueryResult *resultlvl = CharacterDatabase.PQuery("SELECT guid FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetObjectGuid().GetCounter());
+        if (!resultlvl)
+            CharacterDatabase.DirectPExecute("INSERT INTO playerbot_saved_data (guid,combat_order,primary_target,secondary_target,pname,sname,combat_delay) VALUES ('%u',0,0,0,'','',0)", m_bot->GetObjectGuid().GetCounter());
+        else
+            delete resultlvl;
+
+        size_t protect = text.find("protect");
+        size_t assist = text.find("assist");
+
+
+        if (text == "")
+        {
+            SendWhisper("|cffff0000Syntax error:|cffffffff orders combat <botName> <reset | tank | heal | passive><assist | protect [targetPlayer]>", fromPlayer);
+            return;
+        }
+
+        if (ExtractCommand("protect", text) || ExtractCommand("assist", text))
+        {
+            ObjectGuid targetGUID = fromPlayer.GetSelectionGuid();
+            if (text == "" && !targetGUID)
+            {
+                SendWhisper("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!", fromPlayer);
+                return;
+            }
+
+            if (text != "")
+            {
+                ObjectGuid targ_guid = sObjectMgr.GetPlayerGuidByName(text.c_str());
+                targetGUID.Set(targ_guid.GetRawValue());
+            }
+            target = ObjectAccessor::GetUnit(fromPlayer, targetGUID);
+            if (!target)
+                return SendWhisper("|cffff0000Invalid target for combat order protect or assist!", fromPlayer);
+
+            if (protect != std::string::npos)
+                SetCombatOrder(ORDERS_PROTECT, target);
+            else if (assist != std::string::npos)
+                SetCombatOrder(ORDERS_ASSIST, target);
+        }
+        else
+            SetCombatOrderByStr(text, target);
+    }
+    else if (text != "")
+    {
+        SendWhisper("See help for details on using 'orders'.", fromPlayer);
+        return;
+    }
+    SendOrders(*GetMaster());
+}
+
+void PlayerbotAI::_HandleCommandFollow(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("follow cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
+}
+
+void PlayerbotAI::_HandleCommandStay(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("stay cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SetMovementOrder(MOVEMENT_STAY);
+}
+
+void PlayerbotAI::_HandleCommandAttack(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("attack cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    ObjectGuid attackOnGuid = fromPlayer.GetSelectionGuid();
+    if (attackOnGuid)
+    {
+        if (Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid))
+        {
+            if (!m_bot->IsFriendlyTo(thingToAttack))
+            {
+                if (!m_bot->IsWithinLOSInMap(thingToAttack))
+                    DoTeleport(*m_followTarget);
+                if (m_bot->IsWithinLOSInMap(thingToAttack))
+                    Attack(thingToAttack);
+            }
+        }
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandPull(std::string &text, Player &fromPlayer)
+{
+    bool bReadyCheck = false;
+
+    if (!m_bot) return;
+
+    if (ExtractCommand("test", text)) // switch to automatic follow distance
+    {
+        if (CanPull(fromPlayer))
+            SendWhisper("Looks like I am capable of pulling. Ask me 'pull ready' with a target for a more precise check.", fromPlayer);
+        return;
+    }
+    if (ExtractCommand("ready", text)) // switch to automatic follow distance
+    {
+        bReadyCheck = true;
+    }
+    else if (text != "")
+    {
+        SendWhisper("See 'help pull' for details on using the pull command.", fromPlayer);
+        return;
+    }
+
+    // This function also takes care of error reporting
+    if (!CanPull(fromPlayer))
+        return;
+
+    // Check for valid target
+    m_bot->SetSelectionGuid(fromPlayer.GetSelectionGuid());
+    ObjectGuid attackOnGuid = m_bot->GetSelectionGuid();
+    if (!attackOnGuid)
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        return;
+    }
+
+    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid);
+    if (!thingToAttack)
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        return;
+    }
+
+    if (m_bot->IsFriendlyTo(thingToAttack))
+    {
+        SendWhisper("Where I come from we don't attack our friends.", fromPlayer);
+        return;
+    }
+    // TODO: Okay, this one should actually be fixable. InMap should return, but LOS (Line of Sight) should result in moving, well, into LoS.
+    if (!m_bot->IsWithinLOSInMap(thingToAttack))
+    {
+        SendWhisper("I can't see that target!", fromPlayer);
+        return;
+    }
+    GetCombatTarget(thingToAttack);
+    if (!GetCurrentTarget())
+    {
+        SendWhisper("Failed to set target, cause unknown.", fromPlayer);
+        return;
+    }
+    if (bReadyCheck)
+    {
+        SendWhisper("All checks have been passed and I am ready to pull! ... Are you sure you wouldn't like a smaller target?", fromPlayer);
+        return;
+    }
+
+    // All healers which have it available will cast any applicable HoT (Heal over Time) spell on the tank
+    GroupHoTOnTank();
+
+    /* Technically the tank should wait a bit if/until the HoT has been applied
+       but the above function immediately casts it rather than wait for an UpdateAI tick
+
+       There is no need to take into account that GroupHoTOnTank() may fail due to global cooldown. Either you're prepared for a difficult
+       pull in which case it won't fail due to global cooldown, or you're chaining easy pulls in which case you don't care.
+       */
+    /* So have the group wait for the tank to take action (and aggro) - this way it will be easy to see if tank has aggro or not without having to
+       worry about tank not being the first to have UpdateAI() called
+       */
+
+    // Need to have a group and a tank, both checked in "CanPull()" call above
+    //if (!(GetGroupTank()->GetPlayerbotAI()->GetClassAI()->Pull()))
+    // I've been told to pull and a check was done above whether I'm actually a tank, so *I* will try to pull:
+    if (!CastPull())
+    {
+        SendWhisper("I did my best but I can't actually pull. How odd.", fromPlayer);
+        return;
+    }
+
+    // Sets Combat Orders to PULL
+    SetGroupCombatOrder(ORDERS_TEMP_WAIT_TANKAGGRO);
+
+    SetGroupIgnoreUpdateTime(2);
+
+    // Set all group members (save this tank) to wait 10 seconds. They will wait until the tank says so, until any non-tank gains aggro or 10 seconds - whichever is shortest
+    if (m_bot->GetGroup()) // one last sanity check, should be unnecessary
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->GetPlayerbotAI() || groupMember == m_bot)
+                continue;
+            groupMember->GetPlayerbotAI()->GetClassAI()->SetWait(10);
+        }
+    }
+
+    //(4a) if tank, deactivate any attack (such as 'shoot (bow/gun)' for warriors), wait until in melee range, attack
+    //(4b) if dps, wait until the target is in melee range of the tank +2seconds or until tank no longer holds aggro
+    //(4c) if healer, do healing checks
+    //(5) when target is in melee range of tank, wait 2 seconds (healers continue to do group heal checks, all do self-heal checks), then return to normal functioning
+}
+
+void PlayerbotAI::_HandleCommandNeutralize(std::string &text, Player &fromPlayer)
+{
+    if (!m_bot) return;
+
+    if (text != "")
+    {
+        SendWhisper("See 'help neutralize' for details on using the neutralize command.", fromPlayer);
+        return;
+    }
+
+    // Check for valid target
+    m_bot->SetSelectionGuid(fromPlayer.GetSelectionGuid());
+    ObjectGuid selectOnGuid = m_bot->GetSelectionGuid();
+    if (!selectOnGuid)
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        return;
+    }
+
+    Unit* thingToNeutralize = ObjectAccessor::GetUnit(*m_bot, selectOnGuid);
+    if (!thingToNeutralize)
+    {
+        SendWhisper("No valid target is selected.", fromPlayer);
+        return;
+    }
+
+    if (m_bot->IsFriendlyTo(thingToNeutralize))
+    {
+        SendWhisper("I can't neutralize that target: this is a friend to me.", fromPlayer);
+        return;
+    }
+
+    if (!m_bot->IsWithinLOSInMap(thingToNeutralize))
+    {
+        SendWhisper("I can't see that target!", fromPlayer);
+        return;
+    }
+
+    if (IsNeutralized(thingToNeutralize))
+    {
+        SendWhisper("Target is already neutralized.", fromPlayer);
+        return;
+    }
+
+    m_targetGuidCommand = selectOnGuid;
+
+    // All checks passed: call the Neutralize function of each bot class
+    // to define what spellid to use if available and if creature type is correct
+    // m_spellIdCommand will be defined there and UpdateAI will then handle the cast
+    if (!CastNeutralize())
+    {
+        SendWhisper("Something went wrong: I can't neutralize that target.", fromPlayer);
+        return;
+    }
+}
+
+void PlayerbotAI::_HandleCommandCast(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("cast must be used with a single spell link (shift + click the spell).", fromPlayer);
+        return;
+    }
+
+    std::string spellStr = text;
+    uint32 spellId = (uint32) atol(spellStr.c_str());
+
+    // try and get spell ID by name
+    if (spellId == 0)
+    {
+        spellId = getSpellId(spellStr.c_str(), true);
+
+        // try link if text NOT (spellid OR spellname)
+        if (spellId == 0)
+            extractSpellId(text, spellId);
+    }
+
+    if (m_bot->HasAura(spellId))
+    {
+        m_bot->RemoveAurasByCasterSpell(spellId, m_bot->GetObjectGuid());
+        return;
+    }
+
+    ObjectGuid castOnGuid = fromPlayer.GetSelectionGuid();
+    if (spellId != 0 && castOnGuid && m_bot->HasSpell(spellId))
+    {
+        m_spellIdCommand = spellId;
+        m_targetGuidCommand = castOnGuid;
+     }
+}
+
+// _HandleCommandSell: Handle selling items
+// sell [Item Link][Item Link] .. -- Sells bot(s) items from inventory
+void PlayerbotAI::_HandleCommandSell(std::string &text, Player &fromPlayer)
+{
+
+    if (text == "")
+    {
+        SendWhisper("sell must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+/*    enum NPCFlags VENDOR_MASK = (enum NPCFlags) (UNIT_NPC_FLAG_VENDOR
+                                                    | UNIT_NPC_FLAG_VENDOR_AMMO
+                                                    | UNIT_NPC_FLAG_VENDOR_FOOD
+                                                    | UNIT_NPC_FLAG_VENDOR_POISON
+                                                    | UNIT_NPC_FLAG_VENDOR_REAGENT);
+*/
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        m_tasks.push_back(std::pair<enum TaskFlags,uint32>(SELL, *it));
+    m_findNPC.push_back(UNIT_NPC_FLAG_VENDOR);
+}
+
+
+// _HandleCommandRepair: Handle repair items
+// repair  all                      -- repair all bot(s) items
+// repair [Item Link][Item Link] .. -- repair select bot(s) items
+void PlayerbotAI::_HandleCommandRepair(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("all", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'repair all'", fromPlayer);
+            return;
+        }
+        m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REPAIR, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+        return;
+    }
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); it++)
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REPAIR, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+    }
+}
+
+
+// _HandleCommandAuction: Handle auctions:
+// auction                                        -- Lists bot(s) active auctions.
+// auction add [Item Link][Item Link] ..          -- Create bot(s) active auction.
+// auction remove [Auction Link][Auction Link] .. -- Cancel bot(s) active auction. ([Auction Link] from auction)
+void PlayerbotAI::_HandleCommandAuction(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER); // list all bot auctions
+    }
+    else if (ExtractCommand("add",text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(ADD, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else if (ExtractCommand("remove",text))
+    {
+        std::list<uint32> auctionIds;
+        extractAuctionIds(text, auctionIds);
+        for (std::list<uint32>::iterator it = auctionIds.begin(); it != auctionIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REMOVE, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else
+    {
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+    }
+}
+
+// _HandleCommandBank: Handle bank:
+// bank                                        -- Lists bot(s) bank balance.
+// bank deposit [Item Link][Item Link] ..      -- Deposit item(s) in bank.
+// bank withdraw [Item Link][Item Link] ..     -- Withdraw item(s) from bank. ([Item Link] from bank)
+void PlayerbotAI::_HandleCommandBank(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER); // list all bot balance
+    }
+    else if (ExtractCommand("deposit", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(DEPOSIT, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else if (ExtractCommand("withdraw", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(WITHDRAW, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else
+    {
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandUse(std::string &text, Player &fromPlayer)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+    // set target
+    Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelectionGuid());
+
+    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+     {
+        if (unit)
+            UseItem(*it, unit);
+        else
+            UseItem(*it);
+     }
+}
+
+void PlayerbotAI::_HandleCommandEquip(std::string &text, Player& /*fromPlayer*/)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        EquipItem(*it);
+    SendNotEquipList(*m_bot);
+}
+
+void PlayerbotAI::_HandleCommandFind(std::string &text, Player& /*fromPlayer*/)
+{
+    extractGOinfo(text, m_lootTargets);
+
+    m_lootCurrent = m_lootTargets.front();
+    m_lootTargets.pop_front();
+
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+    if (!go)
+    {
+         m_lootTargets.clear();
+         m_lootCurrent = ObjectGuid();
+         return;
+     }
+
+    SetMovementOrder(MOVEMENT_STAY);
+    m_bot->GetMotionMaster()->MovePoint(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
+    m_lootTargets.clear();
+    m_lootCurrent = ObjectGuid();
+}
+
+void PlayerbotAI::_HandleCommandGet(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        extractGOinfo(text, m_lootTargets);
+        SetState(BOTSTATE_LOOTING);
+        return;
+    }
+
+    // get a selected lootable corpse
+    ObjectGuid getOnGuid = fromPlayer.GetSelectionGuid();
+    if (getOnGuid)
+    {
+        Creature *c = m_bot->GetMap()->GetCreature(getOnGuid);
+        if (!c)
+            return;
+
+        uint32 skillId = 0;
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
+
+        if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) ||
+            (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && m_bot->HasSkill(skillId)))
+        {
+            m_lootTargets.push_back(getOnGuid);
+            SetState(BOTSTATE_LOOTING);
+        }
+        else
+            SendWhisper("Target is not lootable by me.", fromPlayer);
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandCollect(std::string &text, Player &fromPlayer)
+{
+    while (text.size() > 0)
+    {
+        if (ExtractCommand("all", text))
+        {
+            SetCollectFlag(COLLECT_FLAG_COMBAT);
+            SetCollectFlag(COLLECT_FLAG_LOOT);
+            SetCollectFlag(COLLECT_FLAG_QUEST);
+            SetCollectFlag(COLLECT_FLAG_PROFESSION);
+            SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+            if (m_bot->HasSkill(SKILL_SKINNING))
+                SetCollectFlag(COLLECT_FLAG_SKIN);
+        }
+        if (ExtractCommand("combat", text))
+            SetCollectFlag(COLLECT_FLAG_COMBAT);
+        else if (ExtractCommand("loot", text))
+            SetCollectFlag(COLLECT_FLAG_LOOT);
+        else if (ExtractCommand("quest", text))
+            SetCollectFlag(COLLECT_FLAG_QUEST);
+        else if (ExtractCommand("profession", text) || ExtractCommand("skill", text))
+            SetCollectFlag(COLLECT_FLAG_PROFESSION);
+        else if (ExtractCommand("skin", text) && m_bot->HasSkill(SKILL_SKINNING)) // removes skin even if bot does not have skill
+            SetCollectFlag(COLLECT_FLAG_SKIN);
+        else if (ExtractCommand("objects", text) || ExtractCommand("nearby", text))
+        {
+            SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+                m_collectObjects.clear();
+        }
+        else if (ExtractCommand("none", text) || ExtractCommand("nothing", text))
+        {
+            m_collectionFlags = 0;
+            m_collectObjects.clear();
+            break;  // because none is an exclusive choice
+        }
+        else
+        {
+            std::string collout = "";
+            if (m_bot->HasSkill(SKILL_SKINNING))
+                collout += ", skin";
+            // TODO: perhaps change the command syntax, this way may be lacking in ease of use
+            SendWhisper("Collect <collectable(s)>: none, combat, loot, quest, profession, objects" + collout, fromPlayer);
+            break;
+        }
+    }
+
+    std::string collset = "";
+    if (HasCollectFlag(COLLECT_FLAG_LOOT))
+        collset += ", all loot";
+    if (HasCollectFlag(COLLECT_FLAG_PROFESSION))
+        collset += ", profession";
+    if (HasCollectFlag(COLLECT_FLAG_QUEST))
+        collset += ", quest";
+    if (HasCollectFlag(COLLECT_FLAG_SKIN))
+        collset += ", skin";
+    if (collset.length() > 1)
+    {
+        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+            collset += " items after combat";
+        else
+            collset += " items";
+    }
+
+    if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+    {
+        if (collset.length() > 1)
+            collset += " and ";
+        else
+            collset += " ";    // padding for substr
+        collset += "nearby objects (";
+        if (!m_collectObjects.empty())
+        {
+            std::string strobjects = "";
+            for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
+            {
+                uint32 objectentry = *(itr);
+                GameObjectInfo const * gInfo = ObjectMgr::GetGameObjectInfo(objectentry);
+                strobjects += ", ";
+                strobjects += gInfo->name;
+            }
+            collset += strobjects.substr(2);
+        }
+        else
+            collset += "use survey and get to set";
+        collset += ")";
+    }
+
+    if (collset.length() > 1)
+        SendWhisper("I'm collecting " + collset.substr(2), fromPlayer);
+    else
+        SendWhisper("I'm collecting nothing.", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandQuest(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream msg;
+
+    if (ExtractCommand("add", text, true)) // true -> "quest add" OR "quest a"
+    {
+        std::list<uint32> questIds;
+        extractQuestIds(text, questIds);
+        for (std::list<uint32>::iterator it = questIds.begin(); it != questIds.end(); it++)
+        {
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(TAKE, *it));
+            DEBUG_LOG(" questid (%u)",*it);
+        }
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("drop", text, true)) // true -> "quest drop" OR "quest d"
+    {
+        fromPlayer.SetSelectionGuid(m_bot->GetObjectGuid());
+        PlayerbotChatHandler ch(GetMaster());
+        int8 linkStart = text.find("|");
+        if (text.find("|") != std::string::npos)
+            if (!ch.dropQuest((char *) text.substr(linkStart).c_str()))
+                ch.sysmessage("ERROR: could not drop quest");
+            else
+            {
+                SetQuestNeedItems();
+                SetQuestNeedCreatures();
+            }
+    }
+    else if (ExtractCommand("fetch", text, true)) // true -> "quest fetch"
+    {
+        gQuestFetch = 1;
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("list", text, true)) // true -> "quest list" OR "quest l"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("end", text, true)) // true -> "quest end" OR "quest e"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(END, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else
+    {
+        bool hasIncompleteQuests = false;
+        std::ostringstream incomout;
+        incomout << "my incomplete quests are:";
+        bool hasCompleteQuests = false;
+        std::ostringstream comout;
+        comout << "my complete quests are:";
+        for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+        {
+            if (uint32 questId = m_bot->GetQuestSlotQuestId(slot))
+            {
+                Quest const* pQuest = sObjectMgr.GetQuestTemplate(questId);
+
+                std::string questTitle  = pQuest->GetTitle();
+                m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questId);
+
+                if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+                {
+                    hasCompleteQuests = true;
+                    comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                }
+                else
+                {
+                    Item* qitem = FindItem(pQuest->GetSrcItemId());
+                    if (qitem)
+                        incomout << " use " << "|cffffffff|Hitem:" << qitem->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << qitem->GetProto()->Name1 << "]|h|r" << " on ";
+                    hasIncompleteQuests = true;
+                    incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
+                }
+            }
+        }
+        if (hasCompleteQuests)
+            SendWhisper(comout.str(), fromPlayer);
+        if (hasIncompleteQuests)
+            SendWhisper(incomout.str(), fromPlayer);
+        if (!hasCompleteQuests && !hasIncompleteQuests)
+            SendWhisper("I have no quests.", fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandPet(std::string &text, Player &fromPlayer)
+{
+    Pet * pet = m_bot->GetPet();
+    if (!pet)
+     {
+        SendWhisper("I have no pet.", fromPlayer);
+        return;
+    }
+
+    if (ExtractCommand("react", text))
+    {
+        if (ExtractCommand("aggressive", text, true))
+            pet->GetCharmInfo()->SetReactState(REACT_AGGRESSIVE);
+        else if (ExtractCommand("defensive", text, true))
+            pet->GetCharmInfo()->SetReactState(REACT_DEFENSIVE);
+        else if (ExtractCommand("passive", text, true))
+            pet->GetCharmInfo()->SetReactState(REACT_PASSIVE);
+        else
+            _HandleCommandHelp("pet react", fromPlayer);
+    }
+    else if (ExtractCommand("state", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet state' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        std::string state;
+        switch (pet->GetCharmInfo()->GetReactState())
+        {
+            case REACT_AGGRESSIVE:
+                SendWhisper("My pet is aggressive.", fromPlayer);
+                break;
+            case REACT_DEFENSIVE:
+                SendWhisper("My pet is defensive.", fromPlayer);
+                break;
+            case REACT_PASSIVE:
+                SendWhisper("My pet is passive.", fromPlayer);
+        }
+    }
+    else if (ExtractCommand("cast", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet cast", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            if (pet->HasAura(spellId))
+            {
+                pet->RemoveAurasByCasterSpell(spellId, pet->GetObjectGuid());
+                return;
+            }
+
+            ObjectGuid castOnGuid = fromPlayer.GetSelectionGuid();
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, castOnGuid);
+            CastPetSpell(spellId, pTarget);
+        }
+    }
+    else if (ExtractCommand("toggle", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet toggle", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            PetSpellMap::iterator itr = pet->m_spells.find(spellId);
+            if (itr != pet->m_spells.end())
+            {
+                if (itr->second.active == ACT_ENABLED)
+                {
+                    pet->ToggleAutocast(spellId, false);
+                    if (pet->HasAura(spellId))
+                        pet->RemoveAurasByCasterSpell(spellId, pet->GetObjectGuid());
+                }
+                else
+                    pet->ToggleAutocast(spellId, true);
+            }
+        }
+    }
+    else if (ExtractCommand("spells", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet spells' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
+                continue;
+
+            const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            std::string color;
+            switch (itr->second.active)
+            {
+                case ACT_ENABLED:
+                    color = "cff35d22d"; // Some flavor of green
+                    break;
+                default:
+                    color = "cffffffff";
+            }
+
+            if (IsPositiveSpell(spellId))
+                posOut << " |" << color << "|Hspell:" << spellId << "|h["
+                        << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |" << color << "|Hspell:" << spellId << "|h["
+                        << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my pet's non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("and here's my pet's attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+}
+
+void PlayerbotAI::_HandleCommandSpells(std::string& /*text*/, Player &fromPlayer)
+{
+    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    typedef std::map<std::string, uint32> spellMap;
+    spellMap posSpells, negSpells;
+    std::string spellName;
+
+    uint32 ignoredSpells[] = {1843, 5019, 2479, 6603, 3365, 8386, 21651, 21652, 6233, 6246, 6247,
+                                61437, 22810, 22027, 45927, 7266, 7267, 6477, 6478, 7355, 68398};
+    uint32 ignoredSpellsCount = sizeof(ignoredSpells) / sizeof(uint32);
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+            continue;
+
+        const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        spellName = pSpellInfo->SpellName[loc];
+
+        SkillLineAbilityMapBounds const bounds = sSpellMgr.GetSkillLineAbilityMapBounds(spellId);
+
+        bool isProfessionOrRidingSpell = false;
+        for (SkillLineAbilityMap::const_iterator skillIter = bounds.first; skillIter != bounds.second; ++skillIter)
+        {
+            if (IsProfessionOrRidingSkill(skillIter->second->skillId) && skillIter->first == spellId) {
+                isProfessionOrRidingSpell = true;
+                break;
+            }
+        }
+        if (isProfessionOrRidingSpell)
+            continue;
+
+        bool isIgnoredSpell = false;
+        for (uint8 i = 0; i < ignoredSpellsCount; ++i)
+         {
+            if (spellId == ignoredSpells[i]) {
+                isIgnoredSpell = true;
+                break;
+            }
+        }
+        if (isIgnoredSpell)
+            continue;
+
+        if (IsPositiveSpell(spellId)) {
+            if (posSpells.find(spellName) == posSpells.end())
+                posSpells[spellName] = spellId;
+            else if (posSpells[spellName] < spellId)
+                posSpells[spellName] = spellId;
+        }
+        else
+        {
+            if (negSpells.find(spellName) == negSpells.end())
+                negSpells[spellName] = spellId;
+            else if (negSpells[spellName] < spellId)
+                negSpells[spellName] = spellId;
+        }
+    }
+
+    for (spellMap::const_iterator iter = posSpells.begin(); iter != posSpells.end(); ++iter)
+    {
+        posOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    for (spellMap::const_iterator iter = negSpells.begin(); iter != negSpells.end(); ++iter)
+    {
+        negOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    ChatHandler ch(&fromPlayer);
+    SendWhisper("here's my non-attack spells:", fromPlayer);
+    ch.SendSysMessage(posOut.str().c_str());
+    SendWhisper("and here's my attack spells:", fromPlayer);
+    ch.SendSysMessage(negOut.str().c_str());
+}
+
+void PlayerbotAI::_HandleCommandSurvey(std::string& /*text*/, Player &fromPlayer)
+{
+    uint32 count = 0;
+    std::ostringstream detectout;
+    QueryResult *result;
+    GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr.GetActiveEventList();
+    std::ostringstream eventFilter;
+    eventFilter << " AND (event IS NULL ";
+    bool initString = true;
+
+    for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+    {
+        if (initString)
+        {
+            eventFilter <<  "OR event IN (" << *itr;
+            initString = false;
+        }
+        else
+            eventFilter << "," << *itr;
+    }
+
+    if (!initString)
+        eventFilter << "))";
+    else
+        eventFilter << ")";
+
+    result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
+                                    "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
+                                    "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
+                                    m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(), eventFilter.str().c_str());
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint32 entry = fields[1].GetUInt32();
+
+            GameObject *go = m_bot->GetMap()->GetGameObject(ObjectGuid(HIGHGUID_GAMEOBJECT, entry, guid));
+            if (!go)
+                continue;
+
+            if (!go->isSpawned())
+                continue;
+
+            detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+            ++count;
+        } while (result->NextRow());
+
+        delete result;
+    }
+    SendWhisper(detectout.str().c_str(), fromPlayer);
+}
+
+// _HandleCommandSkill: Handle class & professions training:
+// skill                           -- Lists bot(s) Primary profession skills & weapon skills
+// skill learn                     -- List available class or profession (Primary or Secondary) skills, spells & abilities from selected trainer.
+// skill learn [HLINK][HLINK] ..   -- Learn selected skill and spells, from selected trainer ([HLINK] from skill learn).
+// skill unlearn [HLINK][HLINK] .. -- Unlearn selected primary profession skill(s) and all associated spells ([HLINK] from skill)
+void PlayerbotAI::_HandleCommandSkill(std::string &text, Player &fromPlayer)
+{
+    uint32 rank[8] = {0, 75, 150, 225, 300, 375, 450, 525};
+
+    std::ostringstream msg;
+
+    if (ExtractCommand("learn", text))
+    {
+        uint32 totalCost = 0;
+
+        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelectionGuid());
+        if (!unit)
+        {
+            SendWhisper("Please select the trainer!", fromPlayer);
+            return;
+        }
+
+        if (!unit->isTrainer())
+        {
+            SendWhisper("This is not a trainer!", fromPlayer);
+            return;
+        }
+
+        Creature *creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetSelectionGuid());
+        if (!creature)
+            return;
+
+        if (!creature->IsTrainerOf(m_bot, false))
+        {
+            SendWhisper("This trainer can not teach me anything!", fromPlayer);
+            return;
+        }
+
+        // check present spell in trainer spell list
+        TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+        TrainerSpellData const* tSpells = creature->GetTrainerTemplateSpells();
+        if (!cSpells && !tSpells)
+        {
+            SendWhisper("No spells can be learnt from this trainer", fromPlayer);
+            return;
+        }
+
+        // reputation discount
+        float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+
+        // Handle: Learning class or profession (primary or secondary) skill & spell(s) for selected trainer, skill learn [HLINK][HLINK][HLINK].. ([HLINK] from skill train)
+        if (text.size() > 0)
+        {
+            msg << "I have learned the following spells:\r";
+            uint32 totalSpellLearnt = 0;
+            bool visuals = true;
+            m_spellsToLearn.clear();
+            extractSpellIdList(text, m_spellsToLearn);
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); it++)
+            {
+                uint32 spellId = *it;
+
+                if (!spellId)
+                    break;
+
+                TrainerSpell const* trainer_spell = cSpells->Find(spellId);
+                if (!trainer_spell)
+                    trainer_spell = tSpells->Find(spellId);
+
+                if (!trainer_spell)
+                    continue;
+
+                TrainerSpellState state = m_bot->GetTrainerSpellState(trainer_spell, trainer_spell->reqLevel);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                // apply reputation discount
+                uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
+                // check money requirement
+                if (m_bot->GetMoney() < cost)
+                {
+                    Announce(CANT_AFFORD);
+                    continue;
+                }
+
+                m_bot->ModifyMoney(-int32(cost));
+                // learn explicitly or cast explicitly
+                if (trainer_spell->IsCastable())
+                    m_bot->CastSpell(m_bot, trainer_spell->spell, true);
+                else
+                    m_bot->learnSpell(spellId, false);
+                ++totalSpellLearnt;
+                totalCost += cost;
+                const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+
+                if (visuals)
+                {
+                    visuals = false;
+                    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
+                    data << ObjectGuid(fromPlayer.GetSelectionGuid());
+                    data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
+                    GetMaster()->GetSession()->SendPacket(&data);
+/*
+                    data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
+                    data << m_bot->GetObjectGuid();
+                    data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
+                    GetMaster()->GetSession()->SendPacket(&data);
+*/                 }
+/*
+                WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
+                data << ObjectGuid(fromPlayer.GetSelectionGuid());
+                data << uint32(spellId);                                // should be same as in packet from client
+                GetMaster()->GetSession()->SendPacket(&data);
+*/
+                MakeSpellLink(pSpellInfo, msg);
+                uint32 gold = uint32(cost / 10000);
+                cost -= (gold * 10000);
+                uint32 silver = uint32(cost / 100);
+                cost -= (silver * 100);
+                msg << " ";
+                if (gold > 0)
+                    msg << gold <<  "|r|cfffffc00g|r|cff00ff00";
+                if (silver > 0)
+                    msg << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+                msg << cost <<  "|r|cff95524Cc|r|cff00ff00\r";
+            }
+            ReloadAI();
+            uint32 gold = uint32(totalCost / 10000);
+            totalCost -= (gold * 10000);
+            uint32 silver = uint32(totalCost / 100);
+            totalCost -= (silver * 100);
+            msg << "Total of " << totalSpellLearnt << " spell";
+            if (totalSpellLearnt != 1) msg << "s";
+            msg << " learnt, ";
+            if (gold > 0)
+                msg << gold <<  "|r|cfffffc00g|r|cff00ff00";
+            if (silver > 0)
+                msg << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+            msg << totalCost <<  "|r|cff95524Cc|r|cff00ff00 spent.";
+        }
+        // Handle: List class or profession skills, spells & abilities for selected trainer
+        else
+        {
+            msg << "The spells I can learn and their cost:\r";
+
+            TrainerSpellData const* trainer_spells = cSpells;
+            if (!trainer_spells)
+                trainer_spells = tSpells;
+
+            for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+            {
+                TrainerSpell const* tSpell = &itr->second;
+
+                if (!tSpell)
+                    break;
+
+                uint32 reqLevel = 0;
+                if (!tSpell->learnedSpell && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell, &reqLevel))
+                    continue;
+
+                if  (sSpellMgr.IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell) && m_bot->HasSpell(tSpell->learnedSpell))
+                    continue;
+
+                reqLevel = tSpell->isProvidedReqLevel ? tSpell->reqLevel : std::max(reqLevel, tSpell->reqLevel);
+
+                TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell,reqLevel);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                uint32 spellId = tSpell->spell;
+                const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+                uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+                totalCost += cost;
+
+                uint32 gold = uint32(cost / 10000);
+                cost -= (gold * 10000);
+                uint32 silver = uint32(cost / 100);
+                cost -= (silver * 100);
+                MakeSpellLink(pSpellInfo, msg);
+                msg << " ";
+                if (gold > 0)
+                    msg << gold <<  "|r|cfffffc00g|r|cff00ff00";
+                if (silver > 0)
+                    msg << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+                msg << cost <<  "|r|cff95524Cc|r|cff00ff00\r";
+            }
+            int32 moneyDiff = m_bot->GetMoney() - totalCost;
+            if (moneyDiff >= 0)
+            {
+                // calculate how much money bot has
+                uint32 gold = uint32(moneyDiff / 10000);
+                moneyDiff -= (gold * 10000);
+                uint32 silver = uint32(moneyDiff / 100);
+                moneyDiff -= (silver * 100);
+                msg << " ";
+                if (gold > 0)
+                    msg << gold <<  "|r|cfffffc00g|r|cff00ff00";
+                if (silver > 0)
+                    msg << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+                msg << moneyDiff <<  "|r|cff95524Cc|r|cff00ff00 left.";
+            }
+            else
+            {
+                Announce(CANT_AFFORD);
+                moneyDiff *= -1;
+                uint32 gold = uint32(moneyDiff / 10000);
+                moneyDiff -= (gold * 10000);
+                uint32 silver = uint32(moneyDiff / 100);
+                moneyDiff -= (silver * 100);
+                msg << "I need ";
+                if (gold > 0)
+                    msg << " " << gold <<  "|r|cfffffc00g|r|cff00ff00";
+                if (silver > 0)
+                    msg << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+                msg << moneyDiff <<  "|r|cff95524Cc|r|cff00ff00 more to learn all the spells!";
+            }
+        }
+    }
+    // Handle: Unlearning selected primary profession skill(s) and all associated spells, skill unlearn [HLINK][HLINK].. ([HLINK] from skill)
+    else if (ExtractCommand("unlearn", text))
+    {
+        m_spellsToLearn.clear();
+        extractSpellIdList(text, m_spellsToLearn);
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (sSpellMgr.IsPrimaryProfessionSpell(*it))
+            {
+                SpellLearnSkillNode const* spellLearnSkill = sSpellMgr.GetSpellLearnSkill(*it);
+                uint32 prev_spell = sSpellMgr.GetPrevSpellInChain(*it);
+                if (!prev_spell)                                    // first rank, remove skill
+                    GetPlayer()->SetSkill(spellLearnSkill->skill, 0, 0);
+                else
+                {
+                    // search prev. skill setting by spell ranks chain
+                    SpellLearnSkillNode const* prevSkill = sSpellMgr.GetSpellLearnSkill(prev_spell);
+                    while (!prevSkill && prev_spell)
+                    {
+                        prev_spell = sSpellMgr.GetPrevSpellInChain(prev_spell);
+                        prevSkill = sSpellMgr.GetSpellLearnSkill(sSpellMgr.GetFirstSpellInChain(prev_spell));
+                    }
+                    if (!prevSkill)                                 // not found prev skill setting, remove skill
+                        GetPlayer()->SetSkill(spellLearnSkill->skill, 0, 0);
+                }
+            }
+        }
+    }
+    // Handle: Lists bot(s) primary profession skills & weapon skills.
+    else
+    {
+        m_spellsToLearn.clear();
+        m_bot->skill(m_spellsToLearn);
+        msg << "My Primary Professions: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (IsPrimaryProfessionSkill(*it))
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    // has skill
+                    if (skillLine->skillId == *it && skillLine->learnOnGetSkill == 0)
+                    {
+                        SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                        if (!spellInfo)
+                            continue;
+
+                        if (m_bot->GetSkillValue(*it) <= rank[sSpellMgr.GetSpellRank(skillLine->spellId)] && m_bot->HasSpell(skillLine->spellId))
+                        {
+                            // DEBUG_LOG ("[PlayerbotAI]: HandleCommand - skill (%u)(%u)(%u):",skillLine->spellId, rank[sSpellMgr.GetSpellRank(skillLine->spellId)], m_bot->GetSkillValue(*it));
+                            MakeSpellLink(spellInfo, msg);
+                            break;
+                         }
+                    }
+                }
+        }
+
+        msg << "\nMy Weapon skills: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+            // has weapon skill
+            if (SkillLine->categoryId == SKILL_CATEGORY_WEAPON)
+            {
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                    if (!spellInfo)
+                        continue;
+
+                    if (skillLine->skillId == *it && spellInfo->Effect[0] == SPELL_EFFECT_WEAPON)
+                        MakeWeaponSkillLink(spellInfo,msg,*it);
+                }
+            }
+        }
+    }
+    SendWhisper(msg.str(), fromPlayer);
+    m_spellsToLearn.clear();
+    m_bot->GetPlayerbotAI()->GetClassAI();
+}
+
+void PlayerbotAI::_HandleCommandStats(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("'stats' does not have subcommands", fromPlayer);
+        return;
+    }
+
+    std::ostringstream out;
+
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemPrototype const* pBagProto = pBag->GetProto();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+
+    }
+
+    // estimate how much item damage the bot has
+    uint32 copper = EstRepairAll();
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+
+    out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff] has |cff00ff00";
+    out << totalfree << " |h|cffffffff bag slots,|h" << " |cff00ff00";
+    if (gold > 0)
+        out << "|r|cff00ff00" << gold <<  "|r|cfffffc00g|r|cff00ff00";
+    if (silver > 0)
+        out << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+    out << copper <<  "|r|cff95524Cc|r|cff00ff00";
+
+    // calculate how much money bot has
+    copper = m_bot->GetMoney();
+    gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    silver = uint32(copper / 100);
+    copper -= (silver * 100);
+
+    out << "|h|cffffffff item damage & has " << "|r|cff00ff00";
+    if (gold > 0)
+        out << gold <<  "|r|cfffffc00g|r|cff00ff00";
+    if (silver > 0)
+        out << silver <<  "|r|cffc0c0c0s|r|cff00ff00";
+    out << copper <<  "|r|cff95524Cc|r|cff00ff00";
+    ChatHandler ch(&fromPlayer);
+    ch.SendSysMessage(out.str().c_str());
+}
+
+/*    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            ObjectGuid questRewarderGUID = m_bot->GetSelectionGuid();
+            Object* const pNpc = (WorldObject *) m_bot->GetObjectByTypeMask(questRewarderGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.m_qId;
+                Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    !m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemPrototype const * const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+            }
+        }
+        else
+        {
+            std::ostringstream msg;
+            msg << "What? |cff339900attack auction |cffffffff| |cffFFB6C1(|cff1E90FFa|cffFFB6C1)|cff1E90FFdd |cffFFB6C1[Item link] |cffffffff| |cffFFB6C1(|cff1E90FFr|cffFFB6C1)|cff1E90FFemove |cffFFB6C1[Auction link]\r"
+                << "|cff339900bank |cffffffff| |cffFFB6C1(|cff1E90FFd|cffFFB6C1)|cff1E90FFeposit |cffffffff| |cffFFB6C1(|cff1E90FFw|cffFFB6C1)|cff1E90FFithdraw |cffFFB6C1[Item link] |cffFFB6C1(|cffff4500c|cffFFB6C1)|cff339900ast |cffFFB6C1[Spell link] |cff339900collect |cffffffff<|cffffff00all none combat loot objects profession quest|cffffffff> "
+                << "|cffFFB6C1(|cffff4500e|cffFFB6C1)|cff339900quip |cffFFB6C1[Item link] |cffFFB6C1(|cffff4500f|cffFFB6C1)|cff339900ind |cffFFB6C1[GO link] |cff339900follow |cffFFB6C1(|cffff4500g|cffFFB6C1)|cff339900et |cffffffff<|cffa52a2aTARGET |cffffffff| |cffFFB6C1[GO link] |cff339900orders "
+                << "|cff339900pet |cff1E90FFspells |cffffffff| <|cff1E90FFcast |cffffffff| |cff1E90FFtoggle|cffffffff> |cffFFB6C1[Spell link] |cffffffff| |cff1E90FFstate |cffffffff| |cff1E90FFreact |cffffffff<|cffFFB6C1(|cffffff00a|cffFFB6C1)|cffffff00ggresive |cffffffff| |cffFFB6C1(|cffffff00d|cffFFB6C1)|cffffff00efensive |cffffffff| |cffFFB6C1(|cffffff00p|cffFFB6C1)|cffffff00assive|cffffffff> "
+                << "|cff339900quest |cffFFB6C1(|cff1E90FFa|cffFFB6C1) |cff1E90FFdd |cffffffff| |cffFFB6C1(|cff1E90FFd|cffFFB6C1)|cff1E90FFrop |cffffffff| |cffFFB6C1(|cff1E90FFe|cffFFB6C1)|cff1E90FFnd |cffffffff| |cffFFB6C1(|cff1E90FFl|cffFFB6C1)|cff1E90FFist\r|cff339900repair |cffFFB6C1[Item Link] |cff339900report |cff339900reset |cffFFB6C1(|cffff4500s|cffFFB6C1)|cff339900ell |cffFFB6C1[Item link] "
+                << "|cff339900skill |cffffffff| |cffFFB6C1(|cff1E90FFt|cffFFB6C1)|cff1E90FFrain |cffa52a2aTARGET |cffffffff| |cffFFB6C1(|cff1E90FFl|cffFFB6C1)|cff1E90FFearn |cffFFB6C1[Training link] |cffffffff| |cffFFB6C1(|cff1E90FFu|cffFFB6C1)|cff1E90FFnlearn |cffFFB6C1[Profession link] |cff339900spells stats stay survey use |cffffffff<|cffa52a2aTARGET|cffffffff> |cffFFB6C1[Item link]";
+            TellMaster(msg.str());
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}*/
+
+void PlayerbotAI::_HandleCommandHelp(std::string &text, Player &fromPlayer)
+{
+    // "help help"? Seriously?
+    if (ExtractCommand("help", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("help", "Lists all the things you can order me to do... But it's up to me whether to follow your orders... Or not."), fromPlayer);
+        return;
+    }
+
+    bool bMainHelp = (text == "") ? true : false;
+    const std::string sInvalidSubcommand = "That's not a valid subcommand.";
+    std::string msg = "";
+    // All of these must contain the 'bMainHelp' clause -> help lists all major commands
+    // Further indented 'ExtractCommand("subcommand")' conditionals make sure these aren't printed for basic "help"
+    if (bMainHelp || ExtractCommand("attack", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("attack", "Attack the selected target. Which would, of course, require a valid target.", HL_TARGET), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("pull", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("pull", "Pull the target in a coordinated party/raid manner.", HL_TARGET), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("pull test", "I'll tell you if I could pull at all. Can be used anywhere."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("pull ready", "I'll tell you if I'm ready to pull *right now*. To be used on location with valid target."), fromPlayer);
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("neutralize", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("neutralize|neutral", "The bot will try to put its master's target out of combat with crowd control abilities like polymorph, banish, hibernate, shackles and the like.", HL_TARGET), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("follow", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("follow", "I will follow you - this also revives me if dead and teleports me if I'm far away."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stay", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("stay", "I will stay put until told otherwise."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("assist", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("assist", "I will assist the character listed, attacking as they attack.", HL_NAME), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("spells", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("spells", "I will list all the spells I know."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("cast", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("cast", "I will cast the spell or ability listed.", HL_SPELL), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("use", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("use", "I will use the linked item.", HL_ITEM), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("equip", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("equip", "I will equip the linked item(s).", HL_ITEM, true), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("reset", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("reset", "I will reset all my states, orders, loot list, talent spec, ... Hey, that's kind of like memory loss."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("report", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("report", "This will give you a full report of all the items, creatures or gameobjects needed to finish my quests."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stats", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("stats", "This will inform you of my wealth, free bag slots and estimated equipment repair costs."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("survey", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("survey", "Lists all available game objects near me."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("find", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("find", "I will find said game object, walk right up to it, and wait.", HL_GAMEOBJECT), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("get", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("get", "I will get said game object and return to your side.", HL_GAMEOBJECT), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("quest", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("quest", "Lists my current quests."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("quest add", "Adds this quest to my quest log.", HL_QUEST), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("quest drop", "Removes this quest from my quest log.", HL_QUEST), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("quest end", "Turns in my completed quests."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("quest list", "Lists the quests offered to me by this target."), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if(ExtractCommand("drop", text, true)) {}
+            else if(ExtractCommand("end", text, true)) {}
+            else if (ExtractCommand("list", text, true)) {}
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("orders", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("orders", "Shows you my orders. Free will is overrated, right?"), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("orders combat <tank | heal | assist | protect | reset> [targetPlayer]", "Sets general orders I should follow. Assist and Protect require a target."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("orders delay <0-10>", "Activates a delay before I start fighting."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("orders resume", "Resume combat orders to what they were before logout."), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("combat", text, true))
+            {
+                SendWhisper(_HandleCommandHelpHelper("orders combat tank", "Order me to tank. Best used on paladins, warriors or druids."), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("orders combat heal", "Order me to heal. Best used on shamans, priests, druids or paladins."), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("orders combat assist", "Assist the linked target focusing our killing power.", HL_TARGET), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("orders combat protect", "Protect the listed target, attempting to keep aggro away from the target.", HL_TARGET), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("orders combat reset", "Resets my combat orders as though you'd never given me any at all."), fromPlayer);
+
+                if (ExtractCommand("tank", text, true)) {}
+                else if (ExtractCommand("heal", text, true)) {}
+                else if (ExtractCommand("assist", text, true)) {}
+                else if (ExtractCommand("protect", text, true)) {}
+                else if (ExtractCommand("reset", text, true)) {}
+
+                else if (text != "") SendWhisper(sInvalidSubcommand.c_str(), fromPlayer);
+            }
+            else if (ExtractCommand("delay", text, true)) {}
+            else if (ExtractCommand("resume", text, true)) {}
+
+            else if (text != "") SendWhisper(sInvalidSubcommand.c_str(), fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("pet", text))
+    {
+        if (bMainHelp)
+            SendWhisper(_HandleCommandHelpHelper("pet", "Helps command my pet. Must always be used with a subcommand."), fromPlayer);
+        else if (text == "") // not "help" AND "help pet"
+            SendWhisper(_HandleCommandHelpHelper("pet", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as..."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("pet spells", "Shows you the spells my pet knows."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("pet cast", "Has my pet cast this spell. May require a treat. Or at least ask nicely.", HL_SPELL), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("pet toggle", "Toggles autocast for this spell.", HL_SPELL), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("pet state", "Shows my pet's aggro mode."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("pet react", "Sets my pet's aggro mode.", HL_PETAGGRO), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("spells", text)) {}
+            else if(ExtractCommand("cast", text)) {}
+            else if(ExtractCommand("toggle", text)) {}
+            else if (ExtractCommand("state", text)) {}
+            else if (ExtractCommand("react", text))
+            {
+                SendWhisper(_HandleCommandHelpHelper("pet react", "has three modes."), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("aggressive", "sets it so my precious attacks everything in sight.", HL_NONE, false, true), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("defensive", "sets it so it automatically attacks anything that attacks me, or anything I attack.", HL_NONE, false, true), fromPlayer);
+                SendWhisper(_HandleCommandHelpHelper("passive", "makes it so my pet won't attack anything unless directly told to.", HL_NONE, false, true), fromPlayer);
+
+                // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+                if (ExtractCommand("aggressive", text, true)) {}
+                else if (ExtractCommand("defensive", text, true)) {}
+                else if (ExtractCommand("passive", text, true)) {}
+                if (text != "")
+                    SendWhisper(sInvalidSubcommand, fromPlayer);
+            }
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("collect", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("collect", "Tells you what my current collect status is. Also lists possible options."), fromPlayer);
+        SendWhisper(_HandleCommandHelpHelper("collect", "Sets what I collect. Obviously the 'none' option should be used alone, but all the others can be mixed.", HL_OPTION, true), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("sell", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("sell", "Adds this to my 'for sale' list.", HL_ITEM), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("auction", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("auction", "Lists all my active auctions. With pretty little links and such. Hi hi hi... I'm gonna be sooo rich!"), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("auction add", "Adds the item to my 'auction off later' list. I have a lot of lists, you see...", HL_ITEM), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("auction remove", "Adds the item to my 'Don't auction after all' list. Hope it hasn't sold by then!", HL_AUCTION), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if(ExtractCommand("remove", text, true)) {}
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("repair", text))
+    {
+        if (!bMainHelp && text == "")
+            SendWhisper(_HandleCommandHelpHelper("repair", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as..."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("repair", "Has me find an armorer and repair the items you listed.", HL_ITEM), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("repair all", "Has me find an armorer and repair all my items, be they equipped or just taking up bagspace."), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("all", text)) {}
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("bank", text))
+    {
+        SendWhisper(_HandleCommandHelpHelper("bank", "Gives you my bank balance. I thought that was private."), fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("bank deposit", "Deposits the listed items in my bank.", HL_ITEM, true), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("bank withdraw", "Withdraw the listed items from my bank.", HL_ITEM, true), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("deposit", text)) {}
+            else if (ExtractCommand("withdraw", text)) {}
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("skill", text))
+    {
+        msg = _HandleCommandHelpHelper("skill", "Lists my primary professions.");
+        SendWhisper(msg, fromPlayer);
+
+        if (!bMainHelp)
+        {
+            SendWhisper(_HandleCommandHelpHelper("skill train", "Lists the things this trainer can teach me. If you've targeted a trainer, that is."), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("skill learn", "Have me learn this skill from the selected trainer.", HL_SKILL), fromPlayer);
+            SendWhisper(_HandleCommandHelpHelper("skill unlearn", "Unlearn the linked (primary) profession and everything that goes with it.", HL_PROFESSION), fromPlayer);
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("train", text)) {}
+            else if (ExtractCommand("learn", text)) {}
+            else if (ExtractCommand("unlearn", text)) {}
+
+            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
+            return;
+        }
+    }
+
+    if (bMainHelp)
+        SendWhisper(_HandleCommandHelpHelper("help", "Gives you this listing of main commands... But then, you know that already don't you."), fromPlayer);
+
+    if(text != "")
+        SendWhisper("Either that is not a valid command, or someone forgot to add it to my help journal. I mean seriously, they can't expect me to remember *all* this stuff, can they?", fromPlayer);
+}
+
+std::string PlayerbotAI::_HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink, bool bReqLinkMultiples, bool bCommandShort)
+{
+    if (sCommand == "")
+    {
+        DEBUG_LOG("[PlayerbotAI] _HandleCommandHelpHelper called with an empty sCommand. Ignoring call.");
+        return "";
+    }
+
+    std::ostringstream oss;
+    oss << "'|cffffffff";
+    if (bCommandShort)
+        oss << "(" << sCommand.at(0) << ")" << sCommand.substr(1);
+    else
+        oss << sCommand;
+
+    if (reqLink != HL_NONE)
+    {
+        if (reqLink == HL_PROFESSION)
+        {
+            oss << " [PROFESSION]";
+            if (bReqLinkMultiples)
+                oss << " [PROFESSION] ..";
+        }
+        else if (reqLink == HL_ITEM)
+        {
+            oss << " [ITEM]";
+            if (bReqLinkMultiples)
+                oss << " [ITEM] ..";
+        }
+         else if (reqLink == HL_TALENT)
+        {
+            oss << " [TALENT]";
+            if (bReqLinkMultiples)
+                oss << " [TALENT] ..";
+        }
+        else if (reqLink == HL_SKILL)
+        {
+            oss << " [SKILL]";
+            if (bReqLinkMultiples)
+                oss << " [SKILL] ..";
+        }
+        else if (reqLink == HL_OPTION)
+        {
+            oss << " <OPTION>";
+            if (bReqLinkMultiples)
+                oss << " <OPTION> ..";
+        }
+        else if (reqLink == HL_PETAGGRO)
+        {
+            oss << " <(a)ggressive | (d)efensive | (p)assive>";
+            if (bReqLinkMultiples)
+                DEBUG_LOG("[PlayerbotAI] _HandleCommandHelpHelper: sCommand \"pet\" with bReqLinkMultiples \"true\". ... Why? Bug, surely.");
+        }
+        else if (reqLink == HL_QUEST)
+        {
+            oss << " [QUEST]";
+            if (bReqLinkMultiples)
+                oss << " [QUEST] ..";
+        }
+        else if (reqLink == HL_GAMEOBJECT)
+        {
+            oss << " [GAMEOBJECT]";
+            if (bReqLinkMultiples)
+                oss << " [GAMEOBJECT] ..";
+        }
+        else if (reqLink == HL_SPELL)
+        {
+            oss << " <Id# | (part of) name | [SPELL]>";
+            if (bReqLinkMultiples)
+                oss << " <Id# | (part of) name | [SPELL]> ..";
+        }
+        else if (reqLink == HL_TARGET)
+        {
+            oss << " (TARGET)";
+            if (bReqLinkMultiples)
+                oss << " (TARGET) ..";
+        }
+        else if (reqLink == HL_NAME)
+        {
+            oss << " <NAME>";
+            if (bReqLinkMultiples)
+                oss << " <NAME> ..";
+        }
+        else if (reqLink == HL_AUCTION)
+        {
+            oss << " [AUCTION]";
+            if (bReqLinkMultiples)
+                oss << " [AUCTION] ..";
+        }
+        else
+        {
+            oss << " {unknown}";
+            if (bReqLinkMultiples)
+                oss << " {unknown} ..";
+            DEBUG_LOG("[PlayerbotAI]: _HandleCommandHelpHelper - Uncaught case");
+        }
+    }
+
+    oss << "|r': " << sExplain;
+
+    return oss.str();
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotAI.h portalclassic/src/game/playerbot/PlayerbotAI.h
--- mangos-classic/src/game/playerbot/PlayerbotAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,621 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+#include "../QuestDef.h"
+#include "../GameEventMgr.h"
+#include "../ObjectGuid.h"
+#include "../Unit.h"
+
+class WorldPacket;
+class WorldObject;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+class PlayerbotMgr;
+
+#define BOTLOOT_DISTANCE 75.0f
+
+enum RacialTraits
+{
+    BERSERKING_ALL                 = 26297,
+    BLOOD_FURY_ALL                 = 20572,
+    ESCAPE_ARTIST_ALL              = 20589,
+    PERCEPTION_ALL                 = 20600,
+    SHADOWMELD_ALL                 = 20580,
+    STONEFORM_ALL                  = 20594,
+    WAR_STOMP_ALL                  = 20549,
+    WILL_OF_THE_FORSAKEN_ALL       = 7744
+};
+
+enum ProfessionSpells
+{
+    ALCHEMY_1                      = 2259,
+    BLACKSMITHING_1                = 2018,
+    COOKING_1                      = 2550,
+    ENCHANTING_1                   = 7411,
+    ENGINEERING_1                  = 4036,
+    FIRST_AID_1                    = 3273,
+    FISHING_1                      = 7620,
+    HERB_GATHERING_1               = 2366,
+    MINING_1                       = 2575,
+    SKINNING_1                     = 8613,
+    TAILORING_1                    = 3908
+};
+
+enum NotableItems
+{
+    // Skeleton Keys
+    SILVER_SKELETON_KEY            = 15869,
+    GOLDEN_SKELETON_KEY            = 15870,
+    TRUESILVER_SKELETON_KEY        = 15871,
+    ARCANITE_SKELETON_KEY          = 15872,
+    // Lock Charges
+    SMALL_SEAFORIUM_CHARGE         = 4367,
+    LARGE_SEAFORIUM_CHARGE         = 4398,
+    POWERFUL_SEAFORIUM_CHARGE      = 18594
+};
+
+enum MainSpec
+{
+    MAGE_SPEC_FIRE              = 41,
+    MAGE_SPEC_FROST             = 61,
+    MAGE_SPEC_ARCANE            = 81,
+    WARRIOR_SPEC_ARMS           = 161,
+    WARRIOR_SPEC_PROTECTION     = 163,
+    WARRIOR_SPEC_FURY           = 164,
+    ROGUE_SPEC_COMBAT           = 181,
+    ROGUE_SPEC_ASSASSINATION    = 182,
+    ROGUE_SPEC_SUBTELTY         = 183,
+    PRIEST_SPEC_DISCIPLINE      = 201,
+    PRIEST_SPEC_HOLY            = 202,
+    PRIEST_SPEC_SHADOW          = 203,
+    SHAMAN_SPEC_ELEMENTAL       = 261,
+    SHAMAN_SPEC_RESTORATION     = 262,
+    SHAMAN_SPEC_ENHANCEMENT     = 263,
+    DRUID_SPEC_FERAL            = 281,
+    DRUID_SPEC_RESTORATION      = 282,
+    DRUID_SPEC_BALANCE          = 283,
+    WARLOCK_SPEC_DESTRUCTION    = 301,
+    WARLOCK_SPEC_AFFLICTION     = 302,
+    WARLOCK_SPEC_DEMONOLOGY     = 303,
+    HUNTER_SPEC_BEASTMASTERY    = 361,
+    HUNTER_SPEC_SURVIVAL        = 362,
+    HUNTER_SPEC_MARKSMANSHIP    = 363,
+    PALADIN_SPEC_RETRIBUTION    = 381,
+    PALADIN_SPEC_HOLY           = 382,
+    PALADIN_SPEC_PROTECTION     = 383
+};
+
+enum CombatManeuverReturns
+{
+    // TODO: RETURN_NO_ACTION_UNKNOWN is not part of ANY_OK or ANY_ERROR. It's also bad form and should be eliminated ASAP.
+    RETURN_NO_ACTION_OK                 = 0x01, // No action taken during this combat maneuver, as intended (just wait, etc...)
+    RETURN_NO_ACTION_UNKNOWN            = 0x02, // No action taken during this combat maneuver, unknown reason
+    RETURN_NO_ACTION_ERROR              = 0x04, // No action taken due to error
+    RETURN_NO_ACTION_INVALIDTARGET      = 0x08, // No action taken - invalid target
+    RETURN_FINISHED_FIRST_MOVES         = 0x10, // Last action of first-combat-maneuver finished, continue onto next-combat-maneuver
+    RETURN_CONTINUE                     = 0x20, // Continue first moves; normal return value for next-combat-maneuver
+    RETURN_NO_ACTION_INSUFFICIENT_POWER = 0x40, // No action taken due to insufficient power (rage, focus, mana, runes)
+    RETURN_ANY_OK                       = 0x31, // All the OK values bitwise OR'ed
+    RETURN_ANY_ACTION                   = 0x30, // All returns that result in action (which should also be 'OK')
+    RETURN_ANY_ERROR                    = 0x4C  // All the ERROR values bitwise OR'ed
+};
+
+class MANGOS_DLL_SPEC PlayerbotAI
+{
+public:
+    enum ScenarioType
+    {
+        SCENARIO_PVE,
+        SCENARIO_PVE_ELITE, // group (5 members max) when an elite is near - most likely instance (can happen in open world)
+        SCENARIO_PVE_RAID,
+        SCENARIO_PVP_DUEL,
+        SCENARIO_PVP_BG,    // You'll probably want to expand this to suit goal? (capture the flag, assault, domination, ...)
+        SCENARIO_PVP_ARENA,
+        SCENARIO_PVP_OPENWORLD
+    };
+
+    enum CombatStyle
+    {
+        COMBAT_MELEE                = 0x01,             // class melee attacker
+        COMBAT_RANGED               = 0x02              // class is ranged attacker
+    };
+
+    // masters orders that should be obeyed by the AI during the updteAI routine
+    // the master will auto set the target of the bot
+    enum CombatOrderType
+    {
+        ORDERS_NONE                 = 0x0000,   // no special orders given
+        ORDERS_TANK                 = 0x0001,   // bind attackers by gaining threat
+        ORDERS_ASSIST               = 0x0002,   // assist someone (dps type)
+        ORDERS_HEAL                 = 0x0004,   // concentrate on healing (no attacks, only self defense)
+        ORDERS_NODISPEL             = 0x0008,   // Dont dispel anything
+        ORDERS_PROTECT              = 0x0010,   // combinable state: check if protectee is attacked
+        ORDERS_PASSIVE              = 0x0020,   // bots do nothing
+        ORDERS_TEMP_WAIT_TANKAGGRO  = 0x0040,   // Wait on tank to build aggro - expect healing to continue, disable setting when tank loses focus
+        ORDERS_TEMP_WAIT_OOC        = 0x0080,   // Wait but only while OOC - wait only - combat will resume healing, dps, tanking, ...
+        ORDERS_RESIST_FIRE          = 0x0100,   // resist fire
+        ORDERS_RESIST_NATURE        = 0x0200,   // resist nature
+        ORDERS_RESIST_FROST         = 0x0400,   // resist frost
+        ORDERS_RESIST_SHADOW        = 0x0800,   // resist shadow
+
+        // Cumulative orders
+        ORDERS_PRIMARY              = 0x0007,
+        ORDERS_SECONDARY            = 0x0F78,
+        ORDERS_RESIST               = 0x0F00,
+        ORDERS_TEMP                 = 0x00C0,   // All orders NOT to be saved, turned off by bots (or logoff, reset, ...)
+        ORDERS_RESET                = 0xFFFF
+    };
+
+    enum CombatTargetType
+    {
+        TARGET_NORMAL               = 0x00,
+        TARGET_THREATEN             = 0x01
+    };
+
+    enum BotState
+    {
+        BOTSTATE_NORMAL,            // normal AI routines are processed
+        BOTSTATE_COMBAT,            // bot is in combat
+        BOTSTATE_DEAD,              // we are dead and wait for becoming ghost
+        BOTSTATE_DEADRELEASED,      // we released as ghost and wait to revive
+        BOTSTATE_LOOTING,           // looting mode, used just after combat
+        BOTSTATE_FLYING,             // bot is flying
+        BOTSTATE_DELAYED            // bot delay action
+    };
+
+    enum CollectionFlags
+    {
+        COLLECT_FLAG_NOTHING    = 0x00,     // skip looting of anything
+        COLLECT_FLAG_COMBAT     = 0x01,     // loot after combat
+        COLLECT_FLAG_QUEST      = 0x02,     // quest and needed items
+        COLLECT_FLAG_PROFESSION = 0x04,     // items related to skills
+        COLLECT_FLAG_LOOT       = 0x08,     // all loot on corpses
+        COLLECT_FLAG_SKIN       = 0x10,     // skin creatures if available
+        COLLECT_FLAG_NEAROBJECT = 0x20      // collect specified nearby object
+    };
+
+    enum MovementOrderType
+    {
+        MOVEMENT_NONE               = 0x00,
+        MOVEMENT_FOLLOW             = 0x01,
+        MOVEMENT_STAY               = 0x02
+    };
+
+    enum TaskFlags
+    {
+        NONE                        = 0x00,  // do nothing
+        SELL                        = 0x01,  // sell items
+        REPAIR                      = 0x02,  // repair items
+        ADD                         = 0x03,  // add auction
+        REMOVE                      = 0x04,  // remove auction
+        RESET                       = 0x05,  // reset all talents
+        WITHDRAW                    = 0x06,  // withdraw item from bank
+        DEPOSIT                     = 0x07,  // deposit item in bank
+        LIST                        = 0x08,  // list quests
+        END                         = 0x09,  // turn in quests
+        TAKE                        = 0x0A   // take quest
+    };
+
+    enum AnnounceFlags
+    {
+        NOTHING                     = 0x00,
+        INVENTORY_FULL              = 0x01,
+        CANT_AFFORD                 = 0x02
+    };
+
+    typedef std::pair<enum TaskFlags, uint32> taskPair;
+    typedef std::list<taskPair> BotTaskList;
+    typedef std::list<enum NPCFlags> BotNPCList;
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::pair<uint32,uint32> talentPair;
+    typedef std::list<ObjectGuid> BotObjectList;
+    typedef std::list<uint32> BotEntryList;
+    typedef std::vector<uint32> BotTaxiNode;
+    typedef std::set<ObjectGuid> BotObjectSet;
+
+    // attacker query used in PlayerbotAI::FindAttacker()
+    enum ATTACKERINFOTYPE
+    {
+        AIT_NONE                    = 0x00,
+        AIT_LOWESTTHREAT            = 0x01,
+        AIT_HIGHESTTHREAT           = 0x02,
+        AIT_VICTIMSELF              = 0x04,
+        AIT_VICTIMNOTSELF           = 0x08      // could/should use victim param in FindAttackers
+    };
+    struct AttackerInfo
+    {
+        Unit*    attacker;            // reference to the attacker
+        Unit*    victim;              // combatant's current victim
+        float threat;                 // own threat on this combatant
+        float threat2;                // highest threat not caused by bot
+        uint32 count;                 // number of units attacking
+        uint32 source;                // 1=bot, 2=master, 3=group
+    };
+    typedef std::map<ObjectGuid, AttackerInfo> AttackerInfoList;
+    typedef std::map<uint32, float> SpellRanges;
+
+    enum HELPERLINKABLES
+    {
+        HL_NONE,
+        HL_PROFESSION,
+        HL_ITEM,
+        HL_TALENT,
+        HL_SKILL,
+        HL_OPTION,
+        HL_PETAGGRO,
+        HL_QUEST,
+        HL_GAMEOBJECT,
+        HL_SPELL,
+        HL_TARGET,
+        HL_NAME,
+        HL_AUCTION
+    };
+
+public:
+    PlayerbotAI(PlayerbotMgr * const mgr, Player * const bot);
+    virtual ~PlayerbotAI();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called from ChatHandler.cpp when there is an incoming message to the bot
+    // from a whisper or from the party channel
+    void HandleCommand(const std::string& text, Player& fromPlayer);
+
+    // This is called by WorldSession.cpp
+    // It provides a view of packets normally sent to the client.
+    // Since there is no client at the other end, the packets are dropped of course.
+    // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+    // This is called by WorldSession.cpp
+    // when it detects that a bot is being teleported. It acknowledges to the server to complete the
+    // teleportation
+    void HandleTeleportAck();
+
+    // Returns what kind of situation we are in so the ai can react accordingly
+    ScenarioType GetScenarioType() { return m_ScenarioType; }
+    CombatStyle GetCombatStyle() { return m_combatStyle; }
+    void SetCombatStyle(CombatStyle cs) { m_combatStyle = cs; }
+
+    PlayerbotClassAI* GetClassAI() { return m_classAI; }
+    PlayerbotMgr* GetManager() { return m_mgr; }
+    void ReloadAI();
+
+    // finds spell ID for matching substring args
+    // in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char* args, bool master = false) const;
+    uint32 getPetSpellId(const char* args) const;
+    // Initialize spell using rank 1 spell id
+    uint32 initSpell(uint32 spellId);
+    uint32 initPetSpell(uint32 spellIconId);
+
+    // extract quest ids from links
+    void extractQuestIds(const std::string& text, std::list<uint32>& questIds) const;
+
+    // extract auction ids from links
+    void extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const;
+
+    // extracts talent ids to list
+    void extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const;
+
+    // extracts item ids from links
+    void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+    // extract spellid from links
+    void extractSpellId(const std::string& text, uint32 &spellId) const;
+
+    // extract spellids from links to list
+    void extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const;
+
+    // extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string& text) const;
+
+    // extracts gameobject info from link
+    void extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const;
+
+    // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds nearby game objects that are specified in m_collectObjects then adds them to the m_lootTargets list
+    void findNearbyGO();
+    // finds nearby creatures, whose UNIT_NPC_FLAGS match the flags specified in item list m_itemIds
+    void findNearbyCreature();
+    bool IsElite(Unit* pTarget) const;
+    // Used by bots to check if their target is neutralized (polymorph, shackle or the like). Useful to avoid breaking crowd control
+    bool IsNeutralized(Unit* pTarget);
+
+    void MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out);
+    void MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid);
+
+    // currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player& player) const;
+
+    // get current casting spell (will return NULL if no spell!)
+    Spell* GetCurrentSpell() const;
+    uint32 GetCurrentSpellId() { return m_CurrentlyCastingSpellId; }
+
+    bool HasAura(uint32 spellId, const Unit& player) const;
+    bool HasAura(const char* spellName, const Unit& player) const;
+    bool HasAura(const char* spellName) const;
+
+    bool CanReceiveSpecificSpell(uint8 spec, Unit* target) const;
+
+    bool PickPocket(Unit* pTarget);
+    bool HasTool(uint32 TC);
+    bool HasSpellReagents(uint32 spellId);
+
+    uint8 GetHealthPercent(const Unit& target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit& target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit& target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit& target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit& target) const;
+    uint8 GetEnergyAmount() const;
+
+    Item* FindFood() const;
+    Item* FindDrink() const;
+    Item* FindBandage() const;
+    Item* FindPoison() const;
+    Item* FindMount(uint32 matchingRidingSkill) const;
+    Item* FindItem(uint32 ItemId);
+    Item* FindItemInBank(uint32 ItemId);
+    Item* FindKeyForLockValue(uint32 reqSkillValue);
+    Item* FindBombForLockValue(uint32 reqSkillValue);
+    Item* FindConsumable(uint32 displayId) const;
+    bool  FindAmmo() const;
+    uint8 _findItemSlot(Item* target);
+    bool CanStore();
+
+    // ******* Actions ****************************************
+    // Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string& text) const;
+    void TellMaster(const char *fmt, ...) const;
+    void SendWhisper(const std::string& text, Player& player) const;
+    bool CastSpell(const char* args);
+    bool CastSpell(uint32 spellId);
+    bool CastSpell(uint32 spellId, Unit& target);
+    bool CheckBotCast(const SpellEntry *sInfo );
+    bool CastPetSpell(uint32 spellId, Unit* target = nullptr);
+    bool Buff(uint32 spellId, Unit * target, void (*beforeCast)(Player *) = nullptr);
+    bool SelfBuff(uint32 spellId);
+    bool In_Range(Unit* Target, uint32 spellId);
+    bool In_Reach(Unit* Target, uint32 spellId);
+    bool CanReachWithSpellAttack(Unit* target);
+
+    void UseItem(Item *item, uint16 targetFlag, ObjectGuid targetGUID);
+    void UseItem(Item *item, uint8 targetInventorySlot);
+    void UseItem(Item *item, Unit *target);
+    void UseItem(Item *item);
+
+    void PlaySound(uint32 soundid);
+    void Announce(AnnounceFlags msg);
+
+    void EquipItem(Item* src_Item);
+    //void Stay();
+    //bool Follow(Player& player);
+    void SendNotEquipList(Player& player);
+
+    uint8  m_DelayAttack;
+    time_t m_DelayAttackInit;
+    Unit *gPrimtarget;
+    Unit *gSectarget;
+    uint32 gQuestFetch;
+    void BotDataRestore();
+    void CombatOrderRestore();
+    void InterruptCurrentCastingSpell();
+    void Attack(Unit* forcedTarget = nullptr);
+    void GetCombatTarget(Unit* forcedTarget = 0);
+    void GetDuelTarget(Unit* forcedTarget);
+    Unit* GetCurrentTarget() { return m_targetCombat; };
+    void DoNextCombatManeuver();
+    void DoCombatMovement();
+    void SetIgnoreUpdateTime(uint8 t = 0) { m_ignoreAIUpdatesUntilTime = time(nullptr) + t; };
+    time_t CurrentTime() { return time(nullptr); };
+
+    Player* GetPlayerBot() const { return m_bot; }
+    Player* GetPlayer() const { return m_bot; }
+    Player* GetMaster() const;
+
+    BotState GetState() { return m_botState; };
+    void SetState(BotState state);
+    void SetQuestNeedItems();
+    void SetQuestNeedCreatures();
+    void SendQuestNeedList();
+    bool IsInQuestItemList(uint32 itemid) { return m_needItemList.find(itemid) != m_needItemList.end(); };
+    bool IsInQuestCreatureList(uint32 id) { return m_needCreatureOrGOList.find(id) != m_needCreatureOrGOList.end(); };
+    bool IsItemUseful(uint32 itemid);
+    void SendOrders(Player& player);
+    bool DoTeleport(WorldObject &obj);
+    void DoLoot();
+    void DoFlight();
+    void GetTaxi(ObjectGuid guid, BotTaxiNode& nodes);
+
+    bool HasCollectFlag(uint8 flag) { return m_collectionFlags & flag; }
+    void SetCollectFlag(uint8 flag)
+    {
+        if (HasCollectFlag(flag)) m_collectionFlags &= ~flag;
+        else m_collectionFlags |= flag;
+    }
+
+    uint32 EstRepairAll();
+    uint32 EstRepair(uint16 pos);
+
+    void AcceptQuest(Quest const *qInfo, Player *pGiver);
+    void TurnInQuests(WorldObject *questgiver);
+    void ListQuests(WorldObject* questgiver);
+    bool AddQuest(const uint32 entry, WorldObject* questgiver);
+
+    bool IsInCombat();
+    bool IsRegenerating();
+    bool IsGroupInCombat();
+    Player* GetGroupTank(); // TODO: didn't want to pollute non-playerbot code but this should really go in group.cpp
+    void SetGroupCombatOrder(CombatOrderType co);
+    void ClearGroupCombatOrder(CombatOrderType co);
+    void SetGroupIgnoreUpdateTime(uint8 t);
+    bool GroupHoTOnTank();
+    bool CanPull(Player &fromPlayer);
+    bool CastPull();
+    bool GroupTankHoldsAggro();
+    bool CastNeutralize();
+    void UpdateAttackerInfo();
+    Unit* FindAttacker(ATTACKERINFOTYPE ait = AIT_NONE, Unit *victim = 0);
+    uint32 GetAttackerCount() { return m_attackerInfo.size(); };
+    void SetCombatOrderByStr(std::string str, Unit *target = 0);
+    void SetCombatOrder(CombatOrderType co, Unit *target = 0);
+    void ClearCombatOrder(CombatOrderType co);
+    CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
+    bool IsTank() { return (m_combatOrder & ORDERS_TANK) ? true : false; }
+    bool IsHealer() { return (m_combatOrder & ORDERS_HEAL) ? true : false; }
+    bool IsDPS() { return (m_combatOrder & ORDERS_ASSIST) ? true : false; }
+    bool Impulse() { srand ( time(nullptr) ); return(((rand() % 100) > 50) ? true : false); }
+    void SetMovementOrder(MovementOrderType mo, Unit *followTarget = 0);
+    MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
+    void MovementReset();
+    void MovementClear();
+    bool IsMoving();
+
+    void SetInFront(const Unit* obj);
+
+    void ItemLocalization(std::string& itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string& questTitle, const uint32 questID) const;
+    void CreatureLocalization(std::string& creatureName, const uint32 entry) const;
+    void GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const;
+
+    uint8 GetFreeBagSpace() const;
+    void SellGarbage(bool listNonTrash = true, bool bDetailTrashSold = false, bool verbose = true);
+    void Sell(const uint32 itemid);
+    void AddAuction(const uint32 itemid, Creature* aCreature);
+    void ListAuctions();
+    bool RemoveAuction(const uint32 auctionid);
+    void Repair(const uint32 itemid, Creature* rCreature);
+    bool Talent(Creature* tCreature);
+    void InspectUpdate();
+    bool Withdraw(const uint32 itemid);
+    bool Deposit(const uint32 itemid);
+    void BankBalance();
+
+private:
+    bool ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort = false);
+    // outsource commands for code clarity
+    void _HandleCommandReset(std::string &text, Player &fromPlayer);
+    void _HandleCommandReport(std::string &text, Player &fromPlayer);
+    void _HandleCommandOrders(std::string &text, Player &fromPlayer);
+    void _HandleCommandFollow(std::string &text, Player &fromPlayer);
+    void _HandleCommandStay(std::string &text, Player &fromPlayer);
+    void _HandleCommandAttack(std::string &text, Player &fromPlayer);
+    void _HandleCommandPull(std::string &text, Player &fromPlayer);
+    void _HandleCommandNeutralize(std::string &text, Player &fromPlayer);
+    void _HandleCommandCast(std::string &text, Player &fromPlayer);
+    void _HandleCommandSell(std::string &text, Player &fromPlayer);
+    void _HandleCommandRepair(std::string &text, Player &fromPlayer);
+    void _HandleCommandAuction(std::string &text, Player &fromPlayer);
+    void _HandleCommandBank(std::string &text, Player &fromPlayer);
+    void _HandleCommandUse(std::string &text, Player &fromPlayer);
+    void _HandleCommandEquip(std::string &text, Player &fromPlayer);
+    void _HandleCommandFind(std::string &text, Player &fromPlayer);
+    void _HandleCommandGet(std::string &text, Player &fromPlayer);
+    void _HandleCommandCollect(std::string &text, Player &fromPlayer);
+    void _HandleCommandQuest(std::string &text, Player &fromPlayer);
+    void _HandleCommandPet(std::string &text, Player &fromPlayer);
+    void _HandleCommandSpells(std::string &text, Player &fromPlayer);
+    void _HandleCommandSurvey(std::string &text, Player &fromPlayer);
+    void _HandleCommandSkill(std::string &text, Player &fromPlayer);
+    void _HandleCommandStats(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(const char* szText, Player &fromPlayer) { std::string text = szText; _HandleCommandHelp(text, fromPlayer); }
+    std::string _HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink = HL_NONE, bool bReqLinkMultiples = false, bool bCommandShort = false);
+
+    // ****** Closed Actions ********************************
+    // These actions may only be called at special times.
+    // Trade methods are only applicable when the trade window is open
+    // and are only called from within HandleCommand.
+    bool TradeItem(const Item& item, int8 slot = -1);
+    bool TradeCopper(uint32 copper);
+
+    // Helper routines not needed by class AIs.
+    void UpdateAttackersForTarget(Unit *victim);
+
+    void _doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold);
+    void MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemLink(const ItemPrototype *item, std::ostringstream &out);
+
+    // it is safe to keep these back reference pointers because m_bot
+    // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    PlayerbotMgr* const m_mgr;
+    Player* const m_bot;
+    PlayerbotClassAI* m_classAI;
+
+    // ignores AI updates until time specified
+    // no need to waste CPU cycles during casting etc
+    time_t m_ignoreAIUpdatesUntilTime;
+
+    CombatStyle m_combatStyle;
+    CombatOrderType m_combatOrder;
+    MovementOrderType m_movementOrder;
+
+    ScenarioType m_ScenarioType;
+
+    // defines the state of behaviour of the bot
+    BotState m_botState;
+
+    // list of items, creatures or gameobjects needed to fullfill quests
+    BotNeedItem m_needItemList;
+    BotNeedItem m_needCreatureOrGOList;
+
+    // list of creatures we recently attacked and want to loot
+    BotNPCList m_findNPC;               // list of NPCs
+    BotTaskList m_tasks;                // list of tasks
+    BotObjectList m_lootTargets;        // list of targets
+    BotEntryList m_spellsToLearn;       // list of spells
+    ObjectGuid m_lootCurrent;           // current remains of interest
+    ObjectGuid m_lootPrev;              // previous loot
+    BotEntryList m_collectObjects;      // object entries searched for in findNearbyGO
+    BotTaxiNode m_taxiNodes;            // flight node chain;
+
+    uint8 m_collectionFlags;            // what the bot should look for to loot
+    bool m_inventory_full;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    uint32 m_CurrentlyCastingSpellId;
+    //bool m_IsFollowingMaster;
+
+    // if master commands bot to do something, store here until updateAI
+    // can do it
+    uint32 m_spellIdCommand;
+    ObjectGuid m_targetGuidCommand;
+    ObjectGuid m_taxiMaster;
+
+    BotObjectSet m_ignorePlayersChat;  // list of players that the bot will not respond to
+
+    AttackerInfoList m_attackerInfo;
+
+    bool m_targetChanged;
+    CombatTargetType m_targetType;
+
+    Unit* m_targetCombat;       // current combat target
+    Unit* m_targetAssist;       // get new target by checking attacker list of assisted player
+    Unit* m_targetProtect;      // check
+
+    Unit *m_followTarget;       // whom to follow in non combat situation?
+
+    uint32 FISHING,
+           HERB_GATHERING,
+           MINING,
+           SKINNING;
+
+    SpellRanges m_spellRangeMap;
+
+    float m_destX, m_destY, m_destZ; // latest coordinates for chase and point movement types
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotClassAI.cpp portalclassic/src/game/playerbot/PlayerbotClassAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotClassAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotClassAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,391 @@
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai)
+{
+    m_master = master;
+    m_bot = bot;
+    m_ai = ai;
+
+    m_MinHealthPercentTank   = 80;
+    m_MinHealthPercentHealer = 60;
+    m_MinHealthPercentDPS    = 30;
+    m_MinHealthPercentMaster = m_MinHealthPercentDPS;
+
+    ClearWait();
+}
+PlayerbotClassAI::~PlayerbotClassAI() {}
+
+CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuver(Unit *) { return RETURN_NO_ACTION_OK; }
+CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuver(Unit *) { return RETURN_NO_ACTION_OK; }
+
+CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuverPVE(Unit *) { return RETURN_NO_ACTION_OK; }
+CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuverPVE(Unit *) { return RETURN_NO_ACTION_OK; }
+CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuverPVP(Unit *) { return RETURN_NO_ACTION_OK; }
+CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuverPVP(Unit *) { return RETURN_NO_ACTION_OK; }
+
+void PlayerbotClassAI::DoNonCombatActions()
+{
+    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::DoNonCombatActions() rather than class specific function");
+}
+
+bool PlayerbotClassAI::EatDrinkBandage(bool bMana, unsigned char foodPercent, unsigned char drinkPercent, unsigned char bandagePercent)
+{
+    Item* drinkItem = nullptr;
+    Item* foodItem = nullptr;
+    if (bMana && m_ai->GetManaPercent() < drinkPercent)
+        drinkItem = m_ai->FindDrink();
+    if (m_ai->GetHealthPercent() < foodPercent)
+        foodItem = m_ai->FindFood();
+    if (drinkItem || foodItem)
+    {
+        if (drinkItem)
+        {
+            m_ai->TellMaster("I could use a drink.");
+            m_ai->UseItem(drinkItem);
+        }
+        if (foodItem)
+        {
+            m_ai->TellMaster("I could use some food.");
+            m_ai->UseItem(foodItem);
+        }
+        return true;
+    }
+
+    if (m_ai->GetHealthPercent() < bandagePercent && !m_bot->HasAura(RECENTLY_BANDAGED))
+    {
+        Item* bandageItem = m_ai->FindBandage();
+        if (bandageItem)
+        {
+            m_ai->TellMaster("I could use first aid.");
+            m_ai->UseItem(bandageItem);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool PlayerbotClassAI::CanPull()
+{
+    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::CanPull() rather than class specific function");
+    return false;
+}
+
+bool PlayerbotClassAI::CastHoTOnTank()
+{
+    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::CastHoTOnTank() rather than class specific function");
+    return false;
+}
+
+CombatManeuverReturns PlayerbotClassAI::HealPlayer(Player* target) {
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (!target) return RETURN_NO_ACTION_INVALIDTARGET;
+    if (target->IsInDuel()) return RETURN_NO_ACTION_INVALIDTARGET;
+
+    return RETURN_NO_ACTION_OK;
+}
+
+// Please note that job_type JOB_MANAONLY is a cumulative restriction. JOB_TANK | JOB_HEAL means both; JOB_TANK | JOB_MANAONLY means tanks with powertype MANA (paladins, druids)
+CombatManeuverReturns PlayerbotClassAI::Buff(bool (*BuffHelper)(PlayerbotAI*, uint32, Unit*), uint32 spellId, uint32 type, bool bMustBeOOC)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return RETURN_NO_ACTION_ERROR;
+    if (bMustBeOOC && m_bot->isInCombat()) return RETURN_NO_ACTION_ERROR;
+
+    if (spellId == 0) return RETURN_NO_ACTION_OK;
+
+    // First, fill the list of targets
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->isAlive() || groupMember->IsInDuel())
+                continue;
+            JOB_TYPE job = GetTargetJob(groupMember);
+            if (job & type && (!(job & JOB_MANAONLY) || groupMember->getClass() == CLASS_DRUID || groupMember->GetPowerType() == POWER_MANA))
+            {
+                if (BuffHelper(m_ai, spellId, groupMember))
+                    return RETURN_CONTINUE;
+            }
+        }
+    }
+    else
+    {
+        if (m_master && !m_master->IsInDuel()
+            && (!(GetTargetJob(m_master) & JOB_MANAONLY) || m_master->getClass() == CLASS_DRUID || m_master->GetPowerType() == POWER_MANA))
+            if (BuffHelper(m_ai, spellId, m_master))
+                return RETURN_CONTINUE;
+        // Do not check job or power type - any buff you have is always useful to self
+        if (BuffHelper(m_ai, spellId, m_bot))
+            return RETURN_CONTINUE;
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+/**
+ * GetHealTarget()
+ * return Unit* Returns unit to be healed. First checks 'critical' Healer(s), next Tank(s), next Master (if different from:), next DPS.
+ * If none of the healths are low enough (or multiple valid targets) against these checks, the lowest health is healed. Having a target
+ * returned does not guarantee it's worth healing, merely that the target does not have 100% health.
+ *
+ * return NULL If NULL is returned, no healing is required. At all.
+ *
+ * Will need extensive re-write for co-operation amongst multiple healers. As it stands, multiple healers would all pick the same 'ideal'
+ * healing target.
+ */
+Player* PlayerbotClassAI::GetHealTarget(JOB_TYPE type)
+{
+    if (!m_ai)  return nullptr;
+    if (!m_bot) return nullptr;
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return nullptr;
+
+    // define seperately for sorting purposes - DO NOT CHANGE ORDER!
+    std::vector<heal_priority> targets;
+
+    // First, fill the list of targets
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || !groupMember->isAlive() || groupMember->IsInDuel())
+                continue;
+            JOB_TYPE job = GetTargetJob(groupMember);
+            if (job & type)
+                targets.push_back( heal_priority(groupMember, (groupMember->GetHealth() * 100 / groupMember->GetMaxHealth()), job) );
+        }
+    }
+    else
+    {
+        targets.push_back( heal_priority(m_bot, m_bot->GetHealthPercent(), GetTargetJob(m_bot)) );
+        if (m_master && !m_master->IsInDuel())
+            targets.push_back( heal_priority(m_master, (m_master->GetHealth() * 100 / m_master->GetMaxHealth()), GetTargetJob(m_master)) );
+    }
+
+    // Sorts according to type: Healers first, tanks next, then master followed by DPS, thanks to the order of the TYPE enum
+    std::sort(targets.begin(), targets.end());
+
+    uint8 uCount = 0,i = 0;
+    // x is used as 'target found' variable; i is used as the targets iterator throughout all 4 types.
+    int16 x = -1;
+
+    // Try to find a healer in need of healing (if multiple, the lowest health one)
+    while (true)
+    {
+        // This works because we sorted it above
+        if ( (uCount + i) >= targets.size() || !(targets.at(uCount).type & JOB_HEAL)) break;
+        uCount++;
+    }
+
+    // We have uCount healers in the targets, check if any qualify for priority healing
+    for (; uCount > 0; uCount--, i++)
+    {
+        if (targets.at(i).hp <= m_MinHealthPercentHealer)
+            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
+                x = i;
+    }
+    if (x > -1) return targets.at(x).p;
+
+    // Try to find a tank in need of healing (if multiple, the lowest health one)
+    while (true)
+    {
+        if ( (uCount + i) >= targets.size() || !(targets.at(uCount).type & JOB_TANK)) break;
+        uCount++;
+    }
+
+    for (; uCount > 0; uCount--, i++)
+    {
+        if (targets.at(i).hp <= m_MinHealthPercentTank)
+            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
+                x = i;
+    }
+    if (x > -1) return targets.at(x).p;
+
+    // Try to find master in need of healing (lowest health one first)
+    if (m_MinHealthPercentMaster != m_MinHealthPercentDPS)
+    {
+        while (true)
+        {
+            if ( (uCount + i) >= targets.size() || !(targets.at(uCount).type & JOB_MASTER)) break;
+            uCount++;
+        }
+
+        for (; uCount > 0; uCount--, i++)
+        {
+            if (targets.at(i).hp <= m_MinHealthPercentMaster)
+                if (x == -1 || targets.at(x).hp > targets.at(i).hp)
+                    x = i;
+        }
+        if (x > -1) return targets.at(x).p;
+    }
+
+    // Try to find anyone else in need of healing (lowest health one first)
+    while (true)
+    {
+        if ( (uCount + i) >= targets.size() ) break;
+        uCount++;
+    }
+
+    for (; uCount > 0; uCount--, i++)
+    {
+        if (targets.at(i).hp <= m_MinHealthPercentDPS)
+            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
+                x = i;
+    }
+    if (x > -1) return targets.at(x).p;
+
+    // Nobody is critical, find anyone hurt at all, return lowest (let the healer sort out if it's worth healing or not)
+    for (i = 0, uCount = targets.size(); uCount > 0; uCount--, i++)
+    {
+        if (targets.at(i).hp < 100)
+            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
+                x = i;
+    }
+    if (x > -1) return targets.at(x).p;
+
+    return nullptr;
+}
+
+Player* PlayerbotClassAI::GetResurrectionTarget(JOB_TYPE type, bool bMustBeOOC)
+{
+    if (!m_ai)  return nullptr;
+    if (!m_bot) return nullptr;
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return nullptr;
+    if (bMustBeOOC && m_bot->isInCombat()) return nullptr;
+
+    // First, fill the list of targets
+    if (m_bot->GetGroup())
+    {
+        // define seperately for sorting purposes - DO NOT CHANGE ORDER!
+        std::vector<heal_priority> targets;
+
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember || groupMember->isAlive())
+                continue;
+            JOB_TYPE job = GetTargetJob(groupMember);
+            if (job & type)
+                targets.push_back( heal_priority(groupMember, 0, job) );
+        }
+
+        // Sorts according to type: Healers first, tanks next, then master followed by DPS, thanks to the order of the TYPE enum
+        std::sort(targets.begin(), targets.end());
+
+        if (targets.size())
+            return targets.at(0).p;
+    }
+    else if (!m_master->isAlive())
+        return m_master;
+
+    return nullptr;
+}
+
+JOB_TYPE PlayerbotClassAI::GetTargetJob(Player* target)
+{
+    // is a bot
+    if (target->GetPlayerbotAI())
+    {
+        if (target->GetPlayerbotAI()->IsHealer())
+            return JOB_HEAL;
+        if (target->GetPlayerbotAI()->IsTank())
+            return JOB_TANK;
+        return JOB_DPS;
+    }
+
+    // figure out what to do with human players - i.e. figure out if they're tank, DPS or healer
+    uint32 uSpec = target->GetSpec();
+    switch (target->getClass())
+    {
+        case CLASS_PALADIN:
+            if (uSpec == PALADIN_SPEC_HOLY)
+                return JOB_HEAL;
+            if (uSpec == PALADIN_SPEC_PROTECTION)
+                return JOB_TANK;
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+        case CLASS_DRUID:
+            if (uSpec == DRUID_SPEC_RESTORATION)
+                return JOB_HEAL;
+            // Feral can be used for both Tank or DPS... play it safe and assume tank. If not... he best be good at threat management or he'll ravage the healer's mana
+            else if (uSpec == DRUID_SPEC_FERAL)
+                return JOB_TANK;
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+        case CLASS_PRIEST:
+            // Since Discipline can be used for both healer or DPS assume DPS
+            if (uSpec == PRIEST_SPEC_HOLY)
+                return JOB_HEAL;
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+        case CLASS_SHAMAN:
+            if (uSpec == SHAMAN_SPEC_RESTORATION)
+                return JOB_HEAL;
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+        case CLASS_WARRIOR:
+            if (uSpec == WARRIOR_SPEC_PROTECTION)
+                return JOB_TANK;
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+        case CLASS_ROGUE:
+        case CLASS_HUNTER:
+        default:
+            return (m_master == target) ? JOB_MASTER : JOB_DPS;
+    }
+}
+
+CombatManeuverReturns PlayerbotClassAI::CastSpellNoRanged(uint32 nextAction, Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (nextAction == 0)
+        return RETURN_NO_ACTION_OK; // Asked to do nothing so... yeh... Dooone.
+
+    if (pTarget != nullptr)
+        return (m_ai->CastSpell(nextAction, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
+    else
+        return (m_ai->CastSpell(nextAction) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
+}
+
+CombatManeuverReturns PlayerbotClassAI::CastSpellWand(uint32 nextAction, Unit *pTarget, uint32 SHOOT)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (SHOOT > 0 && m_bot->FindCurrentSpellBySpellId(SHOOT) && m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
+    {
+        if (nextAction == SHOOT)
+            // At this point we're already shooting and are asked to shoot. Don't cause a global cooldown by stopping to shoot! Leave it be.
+            return RETURN_CONTINUE; // ... We're asked to shoot and are already shooting so... Task accomplished?
+
+        // We are shooting but wish to cast a spell. Stop 'casting' shoot.
+        m_bot->InterruptNonMeleeSpells(true, SHOOT);
+        // ai->TellMaster("Interrupting auto shot.");
+    }
+
+    // We've stopped ranged (if applicable), if no nextAction just return
+    if (nextAction == 0)
+        return RETURN_CONTINUE; // Asked to do nothing so... yeh... Dooone.
+
+    if (nextAction == SHOOT)
+    {
+        if (SHOOT > 0 && m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_RANGED && !m_bot->FindCurrentSpellBySpellId(SHOOT) && m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
+            return (m_ai->CastSpell(SHOOT, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
+        else
+            // Do Melee attack
+            return RETURN_NO_ACTION_UNKNOWN; // We're asked to shoot and aren't.
+    }
+
+    if (pTarget != nullptr)
+        return (m_ai->CastSpell(nextAction, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
+    else
+        return (m_ai->CastSpell(nextAction) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotClassAI.h portalclassic/src/game/playerbot/PlayerbotClassAI.h
--- mangos-classic/src/game/playerbot/PlayerbotClassAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotClassAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,94 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "../World.h"
+#include "../SpellMgr.h"
+#include "../Player.h"
+#include "../ObjectMgr.h"
+#include "WorldPacket.h"
+#include "../Unit.h"
+#include "../SharedDefines.h"
+#include "PlayerbotAI.h"
+
+class Player;
+class PlayerbotAI;
+
+enum JOB_TYPE
+{
+    JOB_HEAL     = 0x01,
+    JOB_TANK     = 0x02,
+    JOB_MASTER   = 0x04, // Not a fan of this distinction but user (or rather, admin) choice
+    JOB_DPS      = 0x08,
+    JOB_ALL      = 0x0F, // all of the above
+    JOB_MANAONLY = 0x10  // for buff checking (NOTE: this means any with powertype mana AND druids (who may be shifted but still have mana)
+};
+
+struct heal_priority
+{
+    Player* p;
+    uint8 hp;
+    JOB_TYPE type;
+    heal_priority(Player* pin, uint8 hpin, JOB_TYPE t) : p(pin), hp(hpin), type(t) {}
+    // overriding the operator like this is not recommended for general use - however we won't use this struct for anything else
+    bool operator<(const heal_priority& a) const { return type < a.type; }
+};
+
+class MANGOS_DLL_SPEC PlayerbotClassAI
+{
+public:
+    PlayerbotClassAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotClassAI();
+
+    // all combat actions go here
+    virtual CombatManeuverReturns DoFirstCombatManeuver(Unit*);
+    virtual CombatManeuverReturns DoNextCombatManeuver(Unit*);
+    bool Pull() { DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::Pull() rather than class specific function"); return false; }
+    bool Neutralize() { DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::Neutralize() rather than class specific function"); return false; }
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    virtual void DoNonCombatActions();
+    bool EatDrinkBandage(bool bMana = true, unsigned char foodPercent = 50, unsigned char drinkPercent = 50, unsigned char bandagePercent = 70);
+
+    // Utilities
+    Player* GetMaster () { return m_master; }
+    Player* GetPlayerBot() { return m_bot; }
+    PlayerbotAI* GetAI() { return m_ai; }
+    bool CanPull();
+    bool CastHoTOnTank();
+    time_t GetWaitUntil() { return m_WaitUntil; }
+    void SetWait(uint8 t) { m_WaitUntil = m_ai->CurrentTime() + t; }
+    void ClearWait() { m_WaitUntil = 0; }
+    //void SetWaitUntil(time_t t) { m_WaitUntil = t; }
+
+protected:
+    virtual CombatManeuverReturns DoFirstCombatManeuverPVE(Unit*);
+    virtual CombatManeuverReturns DoNextCombatManeuverPVE(Unit*);
+    virtual CombatManeuverReturns DoFirstCombatManeuverPVP(Unit*);
+    virtual CombatManeuverReturns DoNextCombatManeuverPVP(Unit*);
+
+    CombatManeuverReturns CastSpellNoRanged(uint32 nextAction, Unit *pTarget);
+    CombatManeuverReturns CastSpellWand(uint32 nextAction, Unit *pTarget, uint32 SHOOT);
+    virtual CombatManeuverReturns HealPlayer(Player* target);
+    CombatManeuverReturns Buff(bool (*BuffHelper)(PlayerbotAI*, uint32, Unit*), uint32 spellId, uint32 type = JOB_ALL, bool bMustBeOOC = true);
+    Player* GetHealTarget(JOB_TYPE type = JOB_ALL);
+    Player* GetResurrectionTarget(JOB_TYPE type = JOB_ALL, bool bMustBeOOC = true);
+    JOB_TYPE GetTargetJob(Player* target);
+
+    // These values are used in GetHealTarget and can be overridden per class (to accomodate healing spell health checks)
+    uint8 m_MinHealthPercentTank;
+    uint8 m_MinHealthPercentHealer;
+    uint8 m_MinHealthPercentDPS;
+    uint8 m_MinHealthPercentMaster;
+
+    time_t m_WaitUntil;
+
+    Player* m_master;
+    Player* m_bot;
+    PlayerbotAI* m_ai;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotDruidAI.cpp portalclassic/src/game/playerbot/PlayerbotDruidAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotDruidAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotDruidAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,770 @@
+/*
+    Name    : PlayerbotDruidAI.cpp
+    Complete: maybe around 33%
+    Authors : rrtn, Natsukawa
+    Version : 0.42
+ */
+#include "PlayerbotDruidAI.h"
+#include "../SpellAuras.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    MOONFIRE                      = m_ai->initSpell(MOONFIRE_1); // attacks
+    STARFIRE                      = m_ai->initSpell(STARFIRE_1);
+    WRATH                         = m_ai->initSpell(WRATH_1);
+    ROOTS                         = m_ai->initSpell(ENTANGLING_ROOTS_1);
+    INSECT_SWARM                  = m_ai->initSpell(INSECT_SWARM_1);
+    MARK_OF_THE_WILD              = m_ai->initSpell(MARK_OF_THE_WILD_1); // buffs
+    GIFT_OF_THE_WILD              = m_ai->initSpell(GIFT_OF_THE_WILD_1);
+    THORNS                        = m_ai->initSpell(THORNS_1);
+    BARKSKIN                      = m_ai->initSpell(BARKSKIN_1);
+    HIBERNATE                     = m_ai->initSpell(HIBERNATE_1);
+    INNERVATE                     = m_ai->initSpell(INNERVATE_1);
+    FAERIE_FIRE                   = m_ai->initSpell(FAERIE_FIRE_1); // debuffs
+    FAERIE_FIRE_FERAL             = m_ai->initSpell(FAERIE_FIRE_FERAL_1);
+    REJUVENATION                  = m_ai->initSpell(REJUVENATION_1); // heals
+    REGROWTH                      = m_ai->initSpell(REGROWTH_1);
+    OMEN_OF_CLARITY               = m_ai->initSpell(OMEN_OF_CLARITY_1);
+    NATURES_SWIFTNESS             = m_ai->initSpell(NATURES_SWIFTNESS_DRUID_1);
+    HEALING_TOUCH                 = m_ai->initSpell(HEALING_TOUCH_1);
+    SWIFTMEND                     = m_ai->initSpell(SWIFTMEND_1);
+    TRANQUILITY                   = m_ai->initSpell(TRANQUILITY_1);
+    REBIRTH                       = m_ai->initSpell(REBIRTH_1);
+    REMOVE_CURSE                  = m_ai->initSpell(REMOVE_CURSE_DRUID_1);
+    ABOLISH_POISON                = m_ai->initSpell(ABOLISH_POISON_1);
+    // Druid Forms
+    MOONKIN_FORM                  = m_ai->initSpell(MOONKIN_FORM_1);
+    DIRE_BEAR_FORM                = m_ai->initSpell(DIRE_BEAR_FORM_1);
+    BEAR_FORM                     = m_ai->initSpell(BEAR_FORM_1);
+    CAT_FORM                      = m_ai->initSpell(CAT_FORM_1);
+    TRAVEL_FORM                   = m_ai->initSpell(TRAVEL_FORM_1);
+    // Cat Attack type's
+    RAKE                          = m_ai->initSpell(RAKE_1);
+    CLAW                          = m_ai->initSpell(CLAW_1); // 45
+    COWER                         = m_ai->initSpell(COWER_1); // 20
+    SHRED                         = m_ai->initSpell(SHRED_1);
+    TIGERS_FURY                   = m_ai->initSpell(TIGERS_FURY_1);
+    // Cat Finishing Move's
+    RIP                           = m_ai->initSpell(RIP_1); // 30
+    FEROCIOUS_BITE                = m_ai->initSpell(FEROCIOUS_BITE_1); // 35
+    // Bear/Dire Bear Attacks & Buffs
+    BASH                          = m_ai->initSpell(BASH_1);
+    MAUL                          = m_ai->initSpell(MAUL_1); // 15
+    SWIPE                         = m_ai->initSpell(SWIPE_BEAR_1); // 20
+    DEMORALIZING_ROAR             = m_ai->initSpell(DEMORALIZING_ROAR_1); // 10
+    CHALLENGING_ROAR              = m_ai->initSpell(CHALLENGING_ROAR_1);
+    ENRAGE                        = m_ai->initSpell(ENRAGE_1);
+    GROWL                         = m_ai->initSpell(GROWL_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
+    WAR_STOMP                     = m_ai->initSpell(WAR_STOMP_ALL); // tauren
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI() {}
+
+CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
+            {
+                if (meleeReach)
+                {
+                    // Set everyone's UpdateAI() waiting to 2 seconds
+                    m_ai->SetGroupIgnoreUpdateTime(2);
+                    // Clear their TEMP_WAIT_TANKAGGRO flag
+                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+                    // Start attacking, force target on current target
+                    m_ai->Attack(m_ai->GetCurrentTarget());
+
+                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
+                }
+                else
+                {
+                    // TODO: add check if target is ranged
+                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
+                }
+            }
+            else if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
+               return _DoNextPVECombatManeuverHeal();
+            else
+                return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuver(Unit* pTarget)
+{
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuverPVE(Unit* pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    uint32 spec = m_bot->GetSpec();
+    if (spec == 0) // default to spellcasting or healing for healer
+        spec = (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder() ? DRUID_SPEC_RESTORATION : DRUID_SPEC_BALANCE);
+
+    // Make sure healer stays put, don't even melee (aggro) if in range.
+    if (m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    else if (!m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    //Unit* pVictim = pTarget->getVictim();
+    uint32 BEAR = (DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM);
+
+    // TODO: do something to allow emergency heals for non-healers?
+    switch (CheckForms())
+    {
+        case RETURN_OK_SHIFTING:
+            return RETURN_CONTINUE;
+
+        case RETURN_FAIL:
+        case RETURN_OK_CANNOTSHIFT:
+            if (spec == DRUID_SPEC_FERAL)
+                spec = DRUID_SPEC_BALANCE; // Can't shift, force spellcasting
+            break; // rest functions without form
+
+        //case RETURN_OK_NOCHANGE: // great!
+        //case RETURN_FAIL_WAITINGONSELFBUFF: // This is war dammit! No time for silly buffs during combat...
+        default:
+            break;
+    }
+
+    // Low mana and bot is a caster/healer: cast Innervate on self
+    // TODO add group check to also cast on low mana healers or master
+    if (m_ai->GetManaPercent() < 15 && ((m_ai->IsHealer() || spec == DRUID_SPEC_RESTORATION)))
+        if (INNERVATE > 0 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && CastSpell(INNERVATE, m_bot))
+            return RETURN_CONTINUE;
+
+    //Used to determine if this bot is highest on threat
+    Unit *newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget) // TODO: && party has a tank
+    {
+        if (HealPlayer(m_bot) == RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+
+        // Aggroed by an elite
+        if (m_ai->IsElite(newTarget))
+        {
+            // protect the bot with barkskin: the increased casting time is meaningless
+            // because bot will then avoid to cast to not angry mob further
+            if (m_ai->IsHealer() || spec == DRUID_SPEC_RESTORATION || spec == DRUID_SPEC_BALANCE)
+            {
+                if (BARKSKIN > 0 && !m_bot->HasAura(BARKSKIN, EFFECT_INDEX_0) && CastSpell(BARKSKIN, m_bot))
+                    return RETURN_CONTINUE;
+
+                return RETURN_NO_ACTION_OK;
+            }
+            //no other cases: cats have cower in the damage rotation and bears can tank
+        }
+    }
+
+    if (m_ai->IsHealer())
+        if (_DoNextPVECombatManeuverHeal() & RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+
+    switch (spec)
+    {
+        case DRUID_SPEC_FERAL:
+            if (BEAR > 0 && m_bot->HasAura(BEAR))
+                return _DoNextPVECombatManeuverBear(pTarget);
+            if (CAT_FORM > 0 && m_bot->HasAura(CAT_FORM))
+                return _DoNextPVECombatManeuverCat(pTarget);
+            // NO break - failover to DRUID_SPEC_BALANCE
+
+        case DRUID_SPEC_RESTORATION: // There is no Resto DAMAGE rotation. If you insist, go Balance...
+        case DRUID_SPEC_BALANCE:
+            if (m_bot->HasAura(BEAR) || m_bot->HasAura(CAT_FORM))
+                return RETURN_NO_ACTION_UNKNOWN; // Didn't shift out of inappropriate form
+
+            return _DoNextPVECombatManeuverSpellDPS(pTarget);
+
+        /*if (BASH > 0 && !pTarget->HasAura(BASH, EFFECT_INDEX_0) && DruidSpellCombat < 5 && CastSpell(BASH, pTarget))
+            return RETURN_CONTINUE;
+        if (CHALLENGING_ROAR > 0 && pVictim != m_bot && !pTarget->HasAura(CHALLENGING_ROAR, EFFECT_INDEX_0) && !pTarget->HasAura(GROWL, EFFECT_INDEX_0) && CastSpell(CHALLENGING_ROAR, pTarget))
+            return RETURN_CONTINUE;
+        if (ROOTS > 0 && !pTarget->HasAura(ROOTS, EFFECT_INDEX_0) && CastSpell(ROOTS, pTarget))
+            return RETURN_CONTINUE;
+        */
+    }
+
+    return RETURN_NO_ACTION_UNKNOWN;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (m_ai->CastSpell(MOONFIRE))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverBear(Unit* pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (!m_bot->HasAura( (DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM) )) return RETURN_NO_ACTION_ERROR;
+
+    // Used to determine if this bot is highest on threat
+    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    Unit* pVictim = pTarget->getVictim();
+
+    // Face enemy, make sure you're attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder() && !newTarget && GROWL > 0 && !m_bot->HasSpellCooldown(GROWL))
+        if (CastSpell(GROWL, pTarget))
+            return RETURN_CONTINUE;
+
+    if (FAERIE_FIRE_FERAL > 0 && m_ai->In_Reach(pTarget,FAERIE_FIRE_FERAL) && !pTarget->HasAura(FAERIE_FIRE_FERAL, EFFECT_INDEX_0))
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget))
+            return RETURN_CONTINUE;
+
+    if (SWIPE > 0 && m_ai->In_Reach(pTarget,SWIPE) && m_ai->GetAttackerCount() >= 2 && CastSpell(SWIPE, pTarget))
+        return RETURN_CONTINUE;
+
+    if (ENRAGE > 0 && !m_bot->HasSpellCooldown(ENRAGE) && CastSpell(ENRAGE, m_bot))
+        return RETURN_CONTINUE;
+
+    if (DEMORALIZING_ROAR > 0 && !pTarget->HasAura(DEMORALIZING_ROAR, EFFECT_INDEX_0) && CastSpell(DEMORALIZING_ROAR, pTarget))
+        return RETURN_CONTINUE;
+
+    if (MAUL > 0 && CastSpell(MAUL, pTarget))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverCat(Unit* pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (!m_bot->HasAura(CAT_FORM)) return RETURN_NO_ACTION_UNKNOWN;
+
+    //Used to determine if this bot is highest on threat
+    Unit *newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    Unit* pVictim = pTarget->getVictim();
+
+    // Face enemy, make sure you're attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    // Attempt to do a finishing move
+    if (m_bot->GetComboPoints() >= 5)
+    {
+        if (RIP > 0 && !pTarget->HasAura(RIP, EFFECT_INDEX_0))
+        {
+            if (CastSpell(RIP, pTarget))
+                return RETURN_CONTINUE;
+        }
+        // 35 Energy
+        else if (FEROCIOUS_BITE > 0)
+        {
+            if (CastSpell(FEROCIOUS_BITE, pTarget))
+                return RETURN_CONTINUE;
+        }
+    } // End 5 ComboPoints
+
+    if (newTarget && COWER > 0 && !m_bot->HasSpellCooldown(COWER) && CastSpell(COWER, pTarget))
+        return RETURN_CONTINUE;
+
+    if (SHRED > 0 && !pTarget->HasInArc(M_PI_F, m_bot) && m_ai->CastSpell(SHRED, *pTarget))
+        return RETURN_CONTINUE;
+
+    if (FAERIE_FIRE_FERAL > 0 && m_ai->In_Reach(pTarget,FAERIE_FIRE_FERAL) && !pTarget->HasAura(FAERIE_FIRE_FERAL, EFFECT_INDEX_0) && CastSpell(FAERIE_FIRE_FERAL, pTarget))
+        return RETURN_CONTINUE;
+
+    if (TIGERS_FURY > 0 && !m_bot->HasSpellCooldown(TIGERS_FURY) && !m_bot->HasAura(TIGERS_FURY, EFFECT_INDEX_0) && CastSpell(TIGERS_FURY))
+        return RETURN_CONTINUE;
+
+    if (RAKE > 0 && !pTarget->HasAura(RAKE) && CastSpell(RAKE, pTarget))
+        return RETURN_CONTINUE;
+
+    if (CLAW > 0 && CastSpell(CLAW, pTarget))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverSpellDPS(Unit* pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    uint32 NATURE = (STARFIRE > 0 ? STARFIRE : WRATH);
+
+    if (FAERIE_FIRE > 0 && m_ai->In_Reach(pTarget,FAERIE_FIRE) && !pTarget->HasAura(FAERIE_FIRE, EFFECT_INDEX_0) && CastSpell(FAERIE_FIRE, pTarget))
+        return RETURN_CONTINUE;
+
+    if (INSECT_SWARM > 0 && m_ai->In_Reach(pTarget,INSECT_SWARM) && !pTarget->HasAura(INSECT_SWARM, EFFECT_INDEX_0) && CastSpell(INSECT_SWARM, pTarget))
+        return RETURN_CONTINUE;
+
+    // Healer? Don't waste more mana on DPS
+    if (m_ai->IsHealer())
+        return RETURN_NO_ACTION_OK;
+
+    if (MOONFIRE > 0 && m_ai->In_Reach(pTarget,MOONFIRE) && !pTarget->HasAura(MOONFIRE, EFFECT_INDEX_0) && CastSpell(MOONFIRE, pTarget))
+        return RETURN_CONTINUE;
+
+    if (NATURE > 0 && CastSpell(NATURE, pTarget))
+        return RETURN_CONTINUE;
+
+    // Face enemy, make sure you're attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_MELEE)
+            m_bot->Attack(pTarget, true);
+        else
+            m_bot->AttackStop();
+    }
+
+    return RETURN_NO_ACTION_UNKNOWN;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverHeal()
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+}
+
+CombatManeuverReturns PlayerbotDruidAI::HealPlayer(Player* target)
+{
+    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
+    if (r != RETURN_NO_ACTION_OK)
+        return r;
+
+    if (!target->isAlive())
+    {
+        if (m_bot->isInCombat())
+        {
+            // TODO: Add check for cooldown
+            if (REBIRTH && m_ai->In_Reach(target,REBIRTH) && m_ai->CastSpell(REBIRTH, *target))
+            {
+                std::string msg = "Resurrecting ";
+                msg += target->GetName();
+                m_bot->Say(msg, LANG_UNIVERSAL);
+                return RETURN_CONTINUE;
+            }
+        }
+
+        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
+    }
+
+    //If spell exists and orders say we should be dispelling
+    if ((REMOVE_CURSE > 0 || ABOLISH_POISON > 0) && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0)
+    {
+        //This does something important(lol)
+        uint32 dispelMask  = GetDispellMask(DISPEL_CURSE);
+        uint32 dispelMask2  = GetDispellMask(DISPEL_POISON);
+        //Get a list of all the targets auras(spells affecting target)
+        Unit::SpellAuraHolderMap const& auras = target->GetSpellAuraHolderMap();
+        //Iterate through the auras
+        for (Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            SpellAuraHolder *holder = itr->second;
+            //I dont know what this does but it doesn't work without it
+            if ((1 << holder->GetSpellProto()->Dispel) & dispelMask)
+            {
+                //If the spell is dispellable and we can dispel it, do so
+                if ((holder->GetSpellProto()->Dispel == DISPEL_CURSE) & (REMOVE_CURSE > 0))
+                {
+                    if (CastSpell(REMOVE_CURSE, target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+            else if ((1 << holder->GetSpellProto()->Dispel) & dispelMask2)
+            {
+                if ((holder->GetSpellProto()->Dispel == DISPEL_POISON) & (ABOLISH_POISON > 0))
+                {
+                    if (CastSpell(ABOLISH_POISON, target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+        }
+    }
+
+    uint8 hp = target->GetHealthPercent();
+
+    // Define a tank bot will look at
+    Unit* pMainTank = GetHealTarget(JOB_TANK);
+
+    // If target is out of range (40 yards) and is a tank: move towards it
+    // Other classes have to adjust their position to the healers
+    // TODO: This code should be common to all healers and will probably
+    // move to a more suitable place
+    if (pMainTank && !m_ai->In_Reach(pMainTank, HEALING_TOUCH))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
+        return RETURN_CONTINUE;
+    }
+
+    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
+    if (hp >= 80)
+        return RETURN_NO_ACTION_OK;
+
+    // Start heals. Do lowest HP checks at the top
+
+    // Emergency heal: target needs to be healed NOW!
+    if ((target == pMainTank && hp < 10) || (target != pMainTank && hp < 15))
+    {
+        // first try Nature's Swiftness + Healing Touch: instant heal
+        if (NATURES_SWIFTNESS > 0 && !m_bot->HasSpellCooldown(NATURES_SWIFTNESS) && CastSpell(NATURES_SWIFTNESS, m_bot))
+            return RETURN_CONTINUE;
+
+        if (HEALING_TOUCH > 0 && m_bot->HasAura(NATURES_SWIFTNESS, EFFECT_INDEX_0) && m_ai->In_Reach(target,HEALING_TOUCH) && CastSpell(HEALING_TOUCH, target))
+            return RETURN_CONTINUE;
+
+        // Else try to Swiftmend the target if druid HoT is active on it
+        if (SWIFTMEND > 0 && !m_bot->HasSpellCooldown(SWIFTMEND) && m_ai->In_Reach(target,SWIFTMEND) && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && CastSpell(SWIFTMEND, target))
+            return RETURN_CONTINUE;
+    }
+
+    // Urgent heal: target won't die next second, but first bot needs to gain some time to cast Healing Touch safely
+    if ((target == pMainTank && hp < 15) || (target != pMainTank && hp < 25))
+    {
+        if (REGROWTH > 0 && m_ai->In_Reach(target,REGROWTH) && !target->HasAura(REGROWTH) && CastSpell(REGROWTH, target))
+            return RETURN_CONTINUE;
+        if (REJUVENATION > 0 && m_ai->In_Reach(target,REJUVENATION) && target->HasAura(REGROWTH) && !target->HasAura(REJUVENATION) && CastSpell(REJUVENATION, target))
+            return RETURN_CONTINUE;
+        if (SWIFTMEND > 0 && !m_bot->HasSpellCooldown(SWIFTMEND) && m_ai->In_Reach(target,SWIFTMEND) && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && CastSpell(SWIFTMEND, target))
+            return RETURN_CONTINUE;
+    }
+
+    if (hp < 60 && HEALING_TOUCH > 0 && m_ai->In_Reach(target,HEALING_TOUCH) && CastSpell(HEALING_TOUCH, target))
+        return RETURN_CONTINUE;
+
+    if (hp < 80 && REJUVENATION > 0 && m_ai->In_Reach(target,REJUVENATION) && !target->HasAura(REJUVENATION) && CastSpell(REJUVENATION, target))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+} // end HealTarget
+
+/**
+* CheckForms()
+*
+* Returns bool - Value indicates success - shape was shifted, already shifted, no need to shift.
+*/
+uint8 PlayerbotDruidAI::CheckForms()
+{
+    if (!m_ai)  return RETURN_FAIL;
+    if (!m_bot) return RETURN_FAIL;
+
+    uint32 spec = m_bot->GetSpec();
+    uint32 BEAR = (DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM);
+
+    // if bot has healing orders always shift to humanoid form
+    // regardless of spec
+    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) || spec == DRUID_SPEC_RESTORATION)
+    {
+        if (m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+        {
+            m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+            //m_ai->TellMaster("FormClearCat");
+            return RETURN_OK_SHIFTING;
+        }
+        if (m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+        {
+            m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+            //m_ai->TellMaster("FormClearBear");
+            return RETURN_OK_SHIFTING;
+        }
+        if (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+        {
+            m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+            //m_ai->TellMaster("FormClearDireBear");
+            return RETURN_OK_SHIFTING;
+        }
+        // spellcasting form, but disables healing spells so it's got to go
+        if (m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+        {
+            m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+            //m_ai->TellMaster("FormClearMoonkin");
+            return RETURN_OK_SHIFTING;
+        }
+
+        return RETURN_OK_NOCHANGE;
+    }
+
+    if (spec == DRUID_SPEC_BALANCE)
+    {
+        if (m_bot->HasAura(MOONKIN_FORM))
+            return RETURN_OK_NOCHANGE;
+
+        if (!MOONKIN_FORM)
+            return RETURN_OK_CANNOTSHIFT;
+
+        if (CastSpell(MOONKIN_FORM))
+            return RETURN_OK_SHIFTING;
+        else
+            return RETURN_FAIL;
+    }
+
+    if (spec == DRUID_SPEC_FERAL)
+    {
+        // Use Bear form only if we are told we're a tank and have thorns up
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)
+        {
+            if (m_bot->HasAura(BEAR))
+                return RETURN_OK_NOCHANGE;
+
+            if (!BEAR)
+                return RETURN_OK_CANNOTSHIFT;
+
+            if (!m_bot->HasAura(THORNS))
+                return RETURN_FAIL_WAITINGONSELFBUFF;
+
+            if (CastSpell(BEAR))
+                return RETURN_OK_SHIFTING;
+            else
+                return RETURN_FAIL;
+        }
+        else // No tank orders - try to go kitty or at least bear
+        {
+            if (CAT_FORM > 0)
+            {
+                if (m_bot->HasAura(CAT_FORM))
+                    return RETURN_OK_NOCHANGE;
+
+                if (CastSpell(CAT_FORM))
+                    return RETURN_OK_SHIFTING;
+                else
+                    return RETURN_FAIL;
+            }
+
+            if (BEAR > 0)
+            {
+                if (m_bot->HasAura(BEAR))
+                    return RETURN_OK_NOCHANGE;
+
+                if (CastSpell(BEAR))
+                    return RETURN_OK_SHIFTING;
+                else
+                    return RETURN_FAIL;
+            }
+
+            return RETURN_OK_CANNOTSHIFT;
+        }
+    }
+
+    // Unknown Spec
+    return RETURN_FAIL;
+}
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    if (!m_ai)   return;
+    if (!m_bot)  return;
+
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
+
+    // Revive
+    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
+        return;
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+
+    // Buff
+    if (m_bot->GetGroup() && m_ai->HasSpellReagents(GIFT_OF_THE_WILD) && Buff(&PlayerbotDruidAI::BuffHelper, GIFT_OF_THE_WILD) & RETURN_CONTINUE)
+        return;
+    if (Buff(&PlayerbotDruidAI::BuffHelper, MARK_OF_THE_WILD) & RETURN_CONTINUE)
+        return;
+    if (Buff(&PlayerbotDruidAI::BuffHelper, THORNS, (m_bot->GetGroup() ? JOB_TANK : JOB_ALL)) & RETURN_CONTINUE)
+        return;
+    if (OMEN_OF_CLARITY && !m_bot->HasAura(OMEN_OF_CLARITY) && CastSpell(OMEN_OF_CLARITY, m_bot))
+        return;
+
+    // hp/mana check
+    if (EatDrinkBandage())
+        return;
+
+    if (INNERVATE && m_ai->In_Reach(m_bot,INNERVATE) && !m_bot->HasAura(INNERVATE) && m_ai->GetManaPercent() <= 20 && CastSpell(INNERVATE, m_bot))
+        return;
+
+    // Return to fighting form AFTER reviving, healing, buffing
+    CheckForms();
+} // end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target)
+{
+    if (!ai)          return false;
+    if (spellId == 0) return false;
+    if (!target)      return false;
+
+    Pet * pet = target->GetPet();
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+
+    if (ai->Buff(spellId, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+
+    return false;
+}
+
+void PlayerbotDruidAI::GoBuffForm(Player* self)
+{
+    // RANK_1 spell ids used because this is a static method which does not have access to instance.
+    // There is only one rank for these spells anyway.
+    if (self->HasAura(CAT_FORM_1))
+        self->RemoveAurasDueToSpell(CAT_FORM_1);
+    if (self->HasAura(BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(BEAR_FORM_1);
+    if (self->HasAura(DIRE_BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    if (self->HasAura(MOONKIN_FORM_1))
+        self->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    if (self->HasAura(TRAVEL_FORM_1))
+        self->RemoveAurasDueToSpell(TRAVEL_FORM_1);
+}
+
+// Match up with "Pull()" below
+bool PlayerbotDruidAI::CanPull()
+{
+    if (BEAR_FORM && FAERIE_FIRE_FERAL)
+        return true;
+
+    return false;
+}
+
+// Match up with "CanPull()" above
+bool PlayerbotDruidAI::Pull()
+{
+    if (BEAR_FORM && (CastSpell(FAERIE_FIRE_FERAL) & RETURN_CONTINUE))
+        return true;
+
+    return false;
+}
+
+bool PlayerbotDruidAI::CastHoTOnTank()
+{
+    if (!m_ai) return false;
+
+    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
+
+    // Druid HoTs: Rejuvenation, Regrowth, Tranquility (channeled, AoE)
+    if (REJUVENATION)
+        return (RETURN_CONTINUE & CastSpell(REJUVENATION, m_ai->GetGroupTank()));
+
+    return false;
+}
+
+// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
+uint32 PlayerbotDruidAI::Neutralize(uint8 creatureType)
+{
+    if (!m_bot)         return 0;
+    if (!m_ai)          return 0;
+    if (!creatureType)  return 0;
+
+    if (creatureType != CREATURE_TYPE_DRAGONKIN && creatureType != CREATURE_TYPE_BEAST)
+    {
+        m_ai->TellMaster("I can't make that target hibernate.");
+        return 0;
+    }
+
+    if (HIBERNATE)
+        return HIBERNATE;
+    else
+        return 0;
+
+    return 0;
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotDruidAI.h portalclassic/src/game/playerbot/PlayerbotDruidAI.h
--- mangos-classic/src/game/playerbot/PlayerbotDruidAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotDruidAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,182 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum DruidSpells
+{
+    ABOLISH_POISON_1                = 2893,
+    AQUATIC_FORM_1                  = 1066,
+    BARKSKIN_1                      = 22812,
+    BASH_1                          = 5211,
+    BEAR_FORM_1                     = 5487,
+    CAT_FORM_1                      = 768,
+    CHALLENGING_ROAR_1              = 5209,
+    CLAW_1                          = 1082,
+    COWER_1                         = 8998,
+    CURE_POISON_1                   = 8946,
+    DASH_1                          = 1850,
+    DEMORALIZING_ROAR_1             = 99,
+    DIRE_BEAR_FORM_1                = 9634,
+    ENRAGE_1                        = 5229,
+    ENTANGLING_ROOTS_1              = 339,
+    FAERIE_FIRE_1                   = 770,
+    FAERIE_FIRE_FERAL_1             = 16857,
+    FERAL_CHARGE_BEAR_1             = 16979,
+    FEROCIOUS_BITE_1                = 22568,
+    FRENZIED_REGENERATION_1         = 22842,
+    GIFT_OF_THE_WILD_1              = 21849,
+    GROWL_1                         = 6795,
+    HEALING_TOUCH_1                 = 5185,
+    HIBERNATE_1                     = 2637,
+    HURRICANE_1                     = 16914,
+    INNERVATE_1                     = 29166,
+    INSECT_SWARM_1                  = 5570,
+    MARK_OF_THE_WILD_1              = 1126,
+    MAUL_1                          = 6807,
+    MOONFIRE_1                      = 8921,
+    MOONKIN_FORM_1                  = 24858,
+    NATURES_GRASP_1                 = 16689,
+    NATURES_SWIFTNESS_DRUID_1       = 17116,
+    OMEN_OF_CLARITY_1               = 16864,
+    POUNCE_1                        = 9005,
+    PROWL_1                         = 5215,
+    RAKE_1                          = 1822,
+    RAVAGE_1                        = 6785,
+    REBIRTH_1                       = 20484,
+    REGROWTH_1                      = 8936,
+    REJUVENATION_1                  = 774,
+    REMOVE_CURSE_DRUID_1            = 2782,
+    RIP_1                           = 1079,
+    SHRED_1                         = 5221,
+    SOOTHE_ANIMAL_1                 = 2908,
+    STARFIRE_1                      = 2912,
+    SWIFTMEND_1                     = 18562,
+    SWIPE_BEAR_1                    = 779,
+    THORNS_1                        = 467,
+    TIGERS_FURY_1                   = 5217,
+    TRANQUILITY_1                   = 740,
+    TRAVEL_FORM_1                   = 783,
+    WRATH_1                         = 5176
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotDruidAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDruidAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDruidAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    bool Pull();
+    uint32 Neutralize(uint8 creatureType);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // Utility Functions
+    bool CanPull();
+    bool CastHoTOnTank();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    CombatManeuverReturns CastSpell(uint32 nextAction, Unit *pTarget = nullptr) { return CastSpellNoRanged(nextAction, pTarget); }
+
+    // Combat Maneuver helper functions
+    CombatManeuverReturns _DoNextPVECombatManeuverBear(Unit* pTarget);
+    CombatManeuverReturns _DoNextPVECombatManeuverCat(Unit* pTarget);
+    CombatManeuverReturns _DoNextPVECombatManeuverSpellDPS(Unit* pTarget);
+    CombatManeuverReturns _DoNextPVECombatManeuverHeal();
+
+    // Heals the target based off its hps
+    CombatManeuverReturns HealPlayer (Player* target);
+
+    static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target);
+    // Callback method to reset shapeshift forms blocking buffs and heals
+    static void GoBuffForm(Player *self);
+
+    //Assumes form based on spec
+    uint8 CheckForms();
+    enum CheckForms_ReturnValues {
+        RETURN_FAIL = 0,
+        RETURN_FAIL_WAITINGONSELFBUFF,
+        RETURN_OK_NOCHANGE,
+        RETURN_OK_SHIFTING,
+        RETURN_OK_CANNOTSHIFT
+    };
+
+    // druid cat/bear/dire bear/moonkin/tree of life forms
+    uint32 CAT_FORM,
+           BEAR_FORM,
+           DIRE_BEAR_FORM,
+           MOONKIN_FORM,
+           TRAVEL_FORM;
+
+    // druid cat attacks
+    uint32 CLAW,
+           COWER,
+           TIGERS_FURY,
+           RAKE,
+           RIP,
+           SHRED,
+           FEROCIOUS_BITE;
+
+    // druid bear/dire bear attacks & buffs
+    uint32 BASH,
+           MAUL,
+           SWIPE,
+           DEMORALIZING_ROAR,
+           CHALLENGING_ROAR,
+           GROWL,
+           ENRAGE,
+           FAERIE_FIRE_FERAL;
+
+    // druid caster DPS attacks & debuffs
+    uint32 MOONFIRE,
+           ROOTS,
+           WRATH,
+           OMEN_OF_CLARITY,
+           STARFIRE,
+           INSECT_SWARM,
+           FAERIE_FIRE,
+           HIBERNATE;
+
+    // druid buffs
+    uint32 MARK_OF_THE_WILD,
+           GIFT_OF_THE_WILD,
+           THORNS,
+           INNERVATE,
+           NATURES_SWIFTNESS,
+           BARKSKIN;
+
+    // druid heals
+    uint32 REJUVENATION,
+           REGROWTH,
+           HEALING_TOUCH,
+           SWIFTMEND,
+           TRANQUILITY,
+           REBIRTH,
+           REMOVE_CURSE,
+           ABOLISH_POISON;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, DruidSpellCombat;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotHunterAI.cpp portalclassic/src/game/playerbot/PlayerbotHunterAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotHunterAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotHunterAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,416 @@
+// an improved Hunter by rrtn & Runsttren :)
+
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // PET CTRL
+    PET_SUMMON                    = m_ai->initSpell(CALL_PET_1);
+    PET_DISMISS                   = m_ai->initSpell(DISMISS_PET_1);
+    PET_REVIVE                    = m_ai->initSpell(REVIVE_PET_1);
+    PET_MEND                      = m_ai->initSpell(MEND_PET_1);
+    PET_FEED                      = 1539;
+    BESTIAL_WRATH                 = m_ai->initSpell(BESTIAL_WRATH_1);
+
+    INTIMIDATION                  = m_ai->initSpell(INTIMIDATION_1); // (generic)
+
+    // PET SKILLS must be initialized by pets
+    SONIC_BLAST                   = 0; // bat
+    DEMORALIZING_SCREECH          = 0;
+    BAD_ATTITUDE                  = 0; // crocolisk
+
+    // RANGED COMBAT
+    AUTO_SHOT                     = m_ai->initSpell(AUTO_SHOT_1);
+    HUNTERS_MARK                  = m_ai->initSpell(HUNTERS_MARK_1);
+    ARCANE_SHOT                   = m_ai->initSpell(ARCANE_SHOT_1);
+    CONCUSSIVE_SHOT               = m_ai->initSpell(CONCUSSIVE_SHOT_1);
+    DISTRACTING_SHOT              = m_ai->initSpell(DISTRACTING_SHOT_1);
+    MULTI_SHOT                    = m_ai->initSpell(MULTISHOT_1);
+    SERPENT_STING                 = m_ai->initSpell(SERPENT_STING_1);
+    SCORPID_STING                 = m_ai->initSpell(SCORPID_STING_1);
+    WYVERN_STING                  = m_ai->initSpell(WYVERN_STING_1);
+    VIPER_STING                   = m_ai->initSpell(VIPER_STING_1);
+    AIMED_SHOT                    = m_ai->initSpell(AIMED_SHOT_1);
+    VOLLEY                        = m_ai->initSpell(VOLLEY_1);
+    BLACK_ARROW                   = m_ai->initSpell(BLACK_ARROW_1);
+
+    // MELEE
+    RAPTOR_STRIKE                 = m_ai->initSpell(RAPTOR_STRIKE_1);
+    WING_CLIP                     = m_ai->initSpell(WING_CLIP_1);
+    MONGOOSE_BITE                 = m_ai->initSpell(MONGOOSE_BITE_1);
+    DISENGAGE                     = m_ai->initSpell(DISENGAGE_1);
+    DETERRENCE                    = m_ai->initSpell(DETERRENCE_1);
+
+    // TRAPS
+    FREEZING_TRAP                 = m_ai->initSpell(FREEZING_TRAP_1);
+    IMMOLATION_TRAP               = m_ai->initSpell(IMMOLATION_TRAP_1);
+    FROST_TRAP                    = m_ai->initSpell(FROST_TRAP_1);
+    EXPLOSIVE_TRAP                = m_ai->initSpell(EXPLOSIVE_TRAP_1);
+
+    // BUFFS
+    ASPECT_OF_THE_HAWK            = m_ai->initSpell(ASPECT_OF_THE_HAWK_1);
+    ASPECT_OF_THE_MONKEY          = m_ai->initSpell(ASPECT_OF_THE_MONKEY_1);
+    RAPID_FIRE                    = m_ai->initSpell(RAPID_FIRE_1);
+    TRUESHOT_AURA                 = m_ai->initSpell(TRUESHOT_AURA_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
+    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY                    = m_ai->initSpell(BLOOD_FURY_ALL); // orc
+    WAR_STOMP                     = m_ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING                    = m_ai->initSpell(BERSERKING_ALL); // troll
+
+    m_petSummonFailed = false;
+    m_rangedCombat = true;
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    Player *m_bot = GetPlayerBot();
+    m_has_ammo = m_bot->HasItemCount( m_bot->GetUInt32Value(PLAYER_AMMO_ID), 1 );
+    //DEBUG_LOG("current ammo (%u)",m_bot->GetUInt32Value(PLAYER_AMMO_ID));
+    m_bot->setAttackTimer(RANGED_ATTACK,0);
+    if (!m_has_ammo)
+    {
+       m_ai->FindAmmo();
+       //DEBUG_LOG("new ammo (%u)",m_bot->GetUInt32Value(PLAYER_AMMO_ID));
+       m_has_ammo = m_bot->HasItemCount( m_bot->GetUInt32Value(PLAYER_AMMO_ID), 1 );
+    }
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult* result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')", bot->GetGUIDLow(), PET_SAVE_AS_CURRENT, PET_SAVE_NOT_IN_SLOT);
+
+    if (result)
+        return true;  //hunter has current pet
+    else
+        return false;  //hunter either has no pet or stabled
+} // end HasPet
+
+CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
+    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
+    if (!pTarget) return RETURN_NO_ACTION_ERROR;
+
+    Unit* pVictim = pTarget->getVictim();
+
+    // check for pet and heal if neccessary
+    Pet *pet = m_bot->GetPet();
+    // TODO: clarify/simplify: !pet->getDeathState() != ALIVE
+    if (pet && PET_MEND > 0 && pet->isAlive() && pet->GetHealthPercent() < 50 && pVictim != m_bot && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && m_ai->CastSpell(PET_MEND, *m_bot))
+    {
+        m_ai->TellMaster("healing pet.");
+        return RETURN_CONTINUE;
+    }
+    else if (pet && INTIMIDATION > 0 && pVictim == pet && !pet->HasAura(INTIMIDATION, EFFECT_INDEX_0) && m_ai->CastSpell(INTIMIDATION, *m_bot))
+        return RETURN_CONTINUE;
+
+    // racial traits
+    if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0))
+        m_ai->CastSpell(BLOOD_FURY, *m_bot);
+    else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0))
+        m_ai->CastSpell(BERSERKING, *m_bot);
+
+    // check if ranged combat is possible
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+
+    if (meleeReach || !m_has_ammo)
+    {
+        // switch to melee combat (target in melee range, out of ammo)
+        m_rangedCombat = false;
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+        if (!m_bot->GetUInt32Value(PLAYER_AMMO_ID))
+            m_ai->TellMaster("Out of ammo!");
+
+        // become monkey (increases dodge chance)...
+        if (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, EFFECT_INDEX_0))
+            m_ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot);
+
+    }
+    else if (!meleeReach)
+    {
+        // switch to ranged combat
+        m_rangedCombat = true;
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+
+        // increase ranged attack power...
+        if (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0))
+            m_ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot);
+
+        // m_ai->TellMaster("target dist %f",m_bot->GetCombatDistance(pTarget,true));
+        if (AUTO_SHOT > 0)
+        {
+            if (m_bot->isAttackReady(RANGED_ATTACK))
+                m_bot->CastSpell(pTarget, AUTO_SHOT, true);
+
+            m_bot->setAttackTimer(RANGED_ATTACK,500);
+
+            const SpellEntry* spellInfo = sSpellStore.LookupEntry(AUTO_SHOT);
+            if (!spellInfo)
+                return RETURN_CONTINUE;
+
+            if (m_ai->CheckBotCast(spellInfo) != SPELL_CAST_OK)
+                m_bot->InterruptNonMeleeSpells(true, AUTO_SHOT);
+        }
+    }
+
+    // damage spells
+    if (m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_RANGED)
+    {
+        if (HUNTERS_MARK > 0 && m_ai->In_Reach(pTarget,HUNTERS_MARK) && !pTarget->HasAura(HUNTERS_MARK, EFFECT_INDEX_0) && m_ai->CastSpell(HUNTERS_MARK, *pTarget))
+            return RETURN_CONTINUE;
+        else if (RAPID_FIRE > 0 && m_ai->In_Reach(pTarget,RAPID_FIRE) && !m_bot->HasAura(RAPID_FIRE, EFFECT_INDEX_0) && m_ai->CastSpell(RAPID_FIRE, *m_bot))
+            return RETURN_CONTINUE;
+        else if (MULTI_SHOT > 0 && m_ai->In_Reach(pTarget,MULTI_SHOT) && m_ai->GetAttackerCount() >= 3 && m_ai->CastSpell(MULTI_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        else if (ARCANE_SHOT > 0 && m_ai->In_Reach(pTarget,ARCANE_SHOT) && m_ai->CastSpell(ARCANE_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        else if (CONCUSSIVE_SHOT > 0 && m_ai->In_Reach(pTarget,CONCUSSIVE_SHOT) && !pTarget->HasAura(CONCUSSIVE_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CONCUSSIVE_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        else if (VIPER_STING > 0 && m_ai->In_Reach(pTarget,VIPER_STING) && pTarget->GetPower(POWER_MANA) > 0 && m_ai->GetManaPercent() < 70 && !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && m_ai->CastSpell(VIPER_STING, *pTarget))
+            return RETURN_CONTINUE;
+        else if (SERPENT_STING > 0 && m_ai->In_Reach(pTarget,SERPENT_STING) && !pTarget->HasAura(SERPENT_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SCORPID_STING, EFFECT_INDEX_0) &&  !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && m_ai->CastSpell(SERPENT_STING, *pTarget))
+            return RETURN_CONTINUE;
+        else if (SCORPID_STING > 0 && m_ai->In_Reach(pTarget,SCORPID_STING) && !pTarget->HasAura(WYVERN_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SCORPID_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SERPENT_STING, EFFECT_INDEX_0) && !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && m_ai->CastSpell(SCORPID_STING, *pTarget))
+            return RETURN_CONTINUE;
+        else if (VOLLEY > 0 && m_ai->In_Reach(pTarget,VOLLEY) && m_ai->GetAttackerCount() >= 3 && m_ai->CastSpell(VOLLEY, *pTarget))
+            return RETURN_CONTINUE;
+        else if (BLACK_ARROW > 0 && m_ai->In_Reach(pTarget,BLACK_ARROW) && !pTarget->HasAura(BLACK_ARROW, EFFECT_INDEX_0) && m_ai->CastSpell(BLACK_ARROW, *pTarget))
+            return RETURN_CONTINUE;
+        else if (AIMED_SHOT > 0 && m_ai->In_Reach(pTarget,AIMED_SHOT) && m_ai->CastSpell(AIMED_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        else
+            return RETURN_NO_ACTION_OK;
+    }
+    else
+    {
+        if (RAPTOR_STRIKE > 0 && m_ai->In_Reach(pTarget,RAPTOR_STRIKE) && m_ai->CastSpell(RAPTOR_STRIKE, *pTarget))
+            return RETURN_CONTINUE;
+        else if (EXPLOSIVE_TRAP > 0 && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(EXPLOSIVE_TRAP, *pTarget))
+            return RETURN_CONTINUE;
+        else if (WING_CLIP > 0 && m_ai->In_Reach(pTarget,WING_CLIP) && !pTarget->HasAura(WING_CLIP, EFFECT_INDEX_0) && m_ai->CastSpell(WING_CLIP, *pTarget))
+            return RETURN_CONTINUE;
+        else if (IMMOLATION_TRAP > 0 && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(IMMOLATION_TRAP, *pTarget))
+            return RETURN_CONTINUE;
+        else if (MONGOOSE_BITE > 0 && m_ai->Impulse() && m_ai->CastSpell(MONGOOSE_BITE, *pTarget))
+            return RETURN_CONTINUE;
+        else if (FROST_TRAP > 0 && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(FROST_TRAP, *pTarget))
+            return RETURN_CONTINUE;
+        else if (DETERRENCE > 0 && pVictim == m_bot && m_bot->GetHealthPercent() < 50 && !m_bot->HasAura(DETERRENCE, EFFECT_INDEX_0) && m_ai->CastSpell(DETERRENCE, *m_bot))
+            return RETURN_CONTINUE;
+        else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && m_ai->CastSpell(WAR_STOMP, *pTarget))
+            return RETURN_CONTINUE;
+//        else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && m_ai->CastSpell(STONEFORM, *m_bot))
+//            return RETURN_CONTINUE;
+        else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && m_ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
+            return RETURN_CONTINUE;
+
+        /*else if(FREEZING_TRAP > 0 && !pTarget->HasAura(FREEZING_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(FREEZING_TRAP,*pTarget) )
+            out << " > Freezing Trap"; // this can trap your bots too
+           else if(DISENGAGE > 0 && pVictim && m_ai->CastSpell(DISENGAGE,*pTarget) )
+            out << " > Disengage!"; // attempt to return to ranged combat*/
+    }
+
+    return RETURN_NO_ACTION_OK;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (m_ai->CastSpell(RAPTOR_STRIKE))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    if (!m_rangedCombat || m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_MELEE)
+    {
+        m_rangedCombat = true;
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    }
+
+    // buff group
+    if (TRUESHOT_AURA > 0 && !m_bot->HasAura(TRUESHOT_AURA, EFFECT_INDEX_0))
+        m_ai->CastSpell(TRUESHOT_AURA, *m_bot);
+
+    // buff myself
+    if (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0))
+        m_ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot);
+
+    // hp/mana check
+    if (EatDrinkBandage())
+        return;
+
+    // check for pet
+    if (PET_SUMMON > 0 && !m_petSummonFailed && HasPet(m_bot))
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if (!pet)
+        {
+            // summon pet
+            if (PET_SUMMON > 0 && m_ai->CastSpell(PET_SUMMON, *m_bot))
+                m_ai->TellMaster("summoning pet.");
+            else
+            {
+                m_petSummonFailed = true;
+                m_ai->TellMaster("summon pet failed!");
+            }
+        }
+        else if (!(pet->isAlive()))
+        {
+            if (PET_REVIVE > 0 && m_ai->CastSpell(PET_REVIVE, *m_bot))
+                m_ai->TellMaster("reviving pet.");
+        }
+        else if (pet->GetHealthPercent() < 50)
+        {
+            if (PET_MEND > 0 && pet->isAlive() && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && m_ai->CastSpell(PET_MEND, *m_bot))
+                m_ai->TellMaster("healing pet.");
+        }
+        else if (pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit *) m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster, 23355, true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, nullptr, nullptr, true); // feed pet
+                        m_ai->TellMaster("feeding pet.");
+                        m_ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemPrototype* const pItemProto = pItem->GetProto();
+                            if (!pItemProto)
+                                continue;
+
+                            if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster, 23355, true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, nullptr, nullptr, true); // feed pet
+                                m_ai->TellMaster("feeding pet.");
+                                m_ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+            }
+            if (pet->HasAura(PET_MEND, EFFECT_INDEX_0) && !pet->HasAura(PET_FEED, EFFECT_INDEX_0))
+                m_ai->TellMaster("..no pet food!");
+            m_ai->SetIgnoreUpdateTime(7);
+        }
+    }
+} // end DoNonCombatActions
diff -ruN mangos-classic/src/game/playerbot/PlayerbotHunterAI.h portalclassic/src/game/playerbot/PlayerbotHunterAI.h
--- mangos-classic/src/game/playerbot/PlayerbotHunterAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotHunterAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,154 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HUNTER
+};
+
+enum HunterSpells
+{
+    ARCANE_SHOT_1                   = 3044,
+    ASPECT_OF_THE_BEAST_1           = 13161,
+    ASPECT_OF_THE_CHEETAH_1         = 5118,
+    ASPECT_OF_THE_HAWK_1            = 13165,
+    ASPECT_OF_THE_MONKEY_1          = 13163,
+    ASPECT_OF_THE_PACK_1            = 13159,
+    ASPECT_OF_THE_WILD_1            = 20043,
+    AUTO_SHOT_1                     = 75,
+    BEAST_LORE_1                    = 1462,
+    CALL_PET_1                      = 883,
+    CONCUSSIVE_SHOT_1               = 5116,
+    DETERRENCE_1                    = 19263,
+    DISENGAGE_1                     = 781,
+    DISMISS_PET_1                   = 2641,
+    DISTRACTING_SHOT_1              = 20736,
+    EAGLE_EYE_1                     = 6197,
+    EXPLOSIVE_TRAP_1                = 13813,
+    EYES_OF_THE_BEAST_1             = 1002,
+    FEED_PET_1                      = 6991,
+    FEIGN_DEATH_1                   = 5384,
+    FLARE_1                         = 1543,
+    FREEZING_TRAP_1                 = 1499,
+    FROST_TRAP_1                    = 13809,
+    HUNTERS_MARK_1                  = 1130,
+    IMMOLATION_TRAP_1               = 13795,
+    MEND_PET_1                      = 136,
+    MONGOOSE_BITE_1                 = 1495,
+    MULTISHOT_1                     = 2643,
+    RAPID_FIRE_1                    = 3045,
+    RAPTOR_STRIKE_1                 = 2973,
+    REVIVE_PET_1                    = 982,
+    SCARE_BEAST_1                   = 1513,
+    SCORPID_STING_1                 = 3043,
+    SERPENT_STING_1                 = 1978,
+    TAME_BEAST_1                    = 1515,
+    TRACK_BEASTS_1                  = 1494,
+    TRACK_DEMONS_1                  = 19878,
+    TRACK_DRAGONKIN_1               = 19879,
+    TRACK_ELEMENTALS_1              = 19880,
+    TRACK_GIANTS_1                  = 19882,
+    TRACK_HIDDEN_1                  = 19885,
+    TRACK_HUMANOIDS_1               = 19883,
+    TRACK_UNDEAD_1                  = 19884,
+    TRANQUILIZING_SHOT_1            = 19801,
+    VIPER_STING_1                   = 3034,
+    VOLLEY_1                        = 1510,
+    WING_CLIP_1                     = 2974,
+    AIMED_SHOT_1                    = 19434,
+    BESTIAL_WRATH_1                 = 19574,
+    BLACK_ARROW_1                   = 3674,
+    COUNTERATTACK_1                 = 19306,
+    INTIMIDATION_1                  = 19577,
+    READINESS_1                     = 23989,
+    SCATTER_SHOT_1                  = 19503,
+    TRUESHOT_AURA_1                 = 19506,
+    WYVERN_STING_1                  = 19386
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotHunterAI : PlayerbotClassAI
+{
+public:
+    PlayerbotHunterAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotHunterAI();
+    bool HasPet(Player* bot);
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    // Hunter
+    bool m_petSummonFailed;
+    bool m_rangedCombat;
+    bool m_has_ammo;
+
+    uint32 PET_SUMMON,
+           PET_DISMISS,
+           PET_REVIVE,
+           PET_MEND,
+           PET_FEED,
+           BESTIAL_WRATH,
+           BAD_ATTITUDE,
+           SONIC_BLAST,
+           DEMORALIZING_SCREECH,
+           INTIMIDATION;
+
+    uint32 AUTO_SHOT,
+           HUNTERS_MARK,
+           ARCANE_SHOT,
+           CONCUSSIVE_SHOT,
+           DISTRACTING_SHOT,
+           MULTI_SHOT,
+           EXPLOSIVE_SHOT,
+           SERPENT_STING,
+           SCORPID_STING,
+           VIPER_STING,
+           WYVERN_STING,
+           AIMED_SHOT,
+           VOLLEY,
+           BLACK_ARROW;
+
+    uint32 RAPTOR_STRIKE,
+           WING_CLIP,
+           MONGOOSE_BITE,
+           DISENGAGE,
+           DETERRENCE;
+
+    uint32 FREEZING_TRAP,
+           IMMOLATION_TRAP,
+           FROST_TRAP,
+           EXPLOSIVE_TRAP;
+
+    uint32 ASPECT_OF_THE_HAWK,
+           ASPECT_OF_THE_MONKEY,
+           RAPID_FIRE,
+           TRUESHOT_AURA;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotMageAI.cpp portalclassic/src/game/playerbot/PlayerbotMageAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotMageAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotMageAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,338 @@
+
+#include "PlayerbotMageAI.h"
+
+class PlayerbotAI;
+
+PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    ARCANE_MISSILES         = m_ai->initSpell(ARCANE_MISSILES_1);
+    ARCANE_EXPLOSION        = m_ai->initSpell(ARCANE_EXPLOSION_1);
+    COUNTERSPELL            = m_ai->initSpell(COUNTERSPELL_1);
+    ARCANE_POWER            = m_ai->initSpell(ARCANE_POWER_1);
+    DAMPEN_MAGIC            = m_ai->initSpell(DAMPEN_MAGIC_1);
+    AMPLIFY_MAGIC           = m_ai->initSpell(AMPLIFY_MAGIC_1);
+    MAGE_ARMOR              = m_ai->initSpell(MAGE_ARMOR_1);
+    ARCANE_INTELLECT        = m_ai->initSpell(ARCANE_INTELLECT_1);
+    ARCANE_BRILLIANCE       = m_ai->initSpell(ARCANE_BRILLIANCE_1);
+    MANA_SHIELD             = m_ai->initSpell(MANA_SHIELD_1);
+    CONJURE_WATER           = m_ai->initSpell(CONJURE_WATER_1);
+    CONJURE_FOOD            = m_ai->initSpell(CONJURE_FOOD_1);
+    FIREBALL                = m_ai->initSpell(FIREBALL_1);
+    FIRE_BLAST              = m_ai->initSpell(FIRE_BLAST_1);
+    FLAMESTRIKE             = m_ai->initSpell(FLAMESTRIKE_1);
+    SCORCH                  = m_ai->initSpell(SCORCH_1);
+    POLYMORPH               = m_ai->initSpell(POLYMORPH_1);
+    PYROBLAST               = m_ai->initSpell(PYROBLAST_1);
+    BLAST_WAVE              = m_ai->initSpell(BLAST_WAVE_1);
+    COMBUSTION              = m_ai->initSpell(COMBUSTION_1);
+    FIRE_WARD               = m_ai->initSpell(FIRE_WARD_1);
+    FROSTBOLT               = m_ai->initSpell(FROSTBOLT_1);
+    FROST_NOVA              = m_ai->initSpell(FROST_NOVA_1);
+    BLIZZARD                = m_ai->initSpell(BLIZZARD_1);
+    CONE_OF_COLD            = m_ai->initSpell(CONE_OF_COLD_1);
+    ICE_BARRIER             = m_ai->initSpell(ICE_BARRIER_1);
+    FROST_WARD              = m_ai->initSpell(FROST_WARD_1);
+    FROST_ARMOR             = m_ai->initSpell(FROST_ARMOR_1);
+    ICE_ARMOR               = m_ai->initSpell(ICE_ARMOR_1);
+    ICE_BLOCK               = m_ai->initSpell(ICE_BLOCK_1);
+    COLD_SNAP               = m_ai->initSpell(COLD_SNAP_1);
+
+    // RANGED COMBAT
+    SHOOT                   = m_ai->initSpell(SHOOT_2);
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    ESCAPE_ARTIST           = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    PERCEPTION              = m_ai->initSpell(PERCEPTION_ALL); // human
+    BERSERKING              = m_ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotMageAI::~PlayerbotMageAI() {}
+
+CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    Unit* pVictim = pTarget->getVictim();
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+
+    uint32 spec = m_bot->GetSpec();
+
+    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    // if can't shoot OR have no ranged (wand) equipped
+    else if(m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE && (SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true)))
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    //Used to determine if this bot is highest on threat
+    Unit *newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget) // TODO: && party has a tank
+    {
+        // Insert instant threat reducing spell (if a mage has one)
+
+        // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
+        if (newTarget->GetHealthPercent() > 25)
+        {
+            // If elite, do nothing and pray tank gets aggro off you
+            // TODO: Is there an IsElite function? If so, find it and insert.
+            //if (newTarget->IsElite())
+            //    return;
+
+            // Not an elite. You could insert FEAR here but in any PvE situation that's 90-95% likely
+            // to worsen the situation for the group. ... So please don't.
+            CastSpell(SHOOT, pTarget);
+            return RETURN_CONTINUE;
+        }
+    }
+
+    switch (spec)
+    {
+        case MAGE_SPEC_FROST:
+            if (ICE_BLOCK > 0 && m_ai->In_Reach(m_bot,ICE_BLOCK) && pVictim == m_bot && !m_bot->HasAura(ICE_BLOCK, EFFECT_INDEX_0) && CastSpell(ICE_BLOCK, m_bot))
+                return RETURN_CONTINUE;
+            if (ICE_BARRIER > 0 && m_ai->In_Reach(m_bot,ICE_BARRIER) && pVictim == m_bot && !m_bot->HasAura(ICE_BARRIER, EFFECT_INDEX_0) && m_ai->GetHealthPercent() < 50 && CastSpell(ICE_BARRIER, m_bot))
+                return RETURN_CONTINUE;
+            if (BLIZZARD > 0 && m_ai->In_Reach(pTarget,BLIZZARD) && m_ai->GetAttackerCount() >= 5 && CastSpell(BLIZZARD, pTarget))
+            {
+                m_ai->SetIgnoreUpdateTime(8);
+                return RETURN_CONTINUE;
+            }
+            if (CONE_OF_COLD > 0 && meleeReach && !pTarget->HasAura(CONE_OF_COLD, EFFECT_INDEX_0) && CastSpell(CONE_OF_COLD, pTarget))
+                return RETURN_CONTINUE;
+            if (FROSTBOLT > 0 && m_ai->In_Reach(pTarget,FROSTBOLT) && !pTarget->HasAura(FROSTBOLT, EFFECT_INDEX_0) && CastSpell(FROSTBOLT, pTarget))
+                return RETURN_CONTINUE;
+            if (FROST_WARD > 0 && m_ai->In_Reach(m_bot,FROST_WARD) && !m_bot->HasAura(FROST_WARD, EFFECT_INDEX_0) && CastSpell(FROST_WARD, m_bot))
+                return RETURN_CONTINUE;
+            if (FROST_NOVA > 0 && meleeReach && !pTarget->HasAura(FROST_NOVA, EFFECT_INDEX_0) && CastSpell(FROST_NOVA, pTarget))
+                return RETURN_CONTINUE;
+            if (COLD_SNAP > 0 && m_ai->In_Reach(m_bot,COLD_SNAP) && CastSpell(COLD_SNAP, m_bot))
+                return RETURN_CONTINUE;
+
+            if (FROSTBOLT > 0 && m_ai->In_Reach(pTarget,FROSTBOLT))
+                return CastSpell(FROSTBOLT, pTarget);
+            break;
+
+        case MAGE_SPEC_FIRE:
+            if (FIRE_WARD > 0 && m_ai->In_Reach(m_bot,FIRE_WARD) && !m_bot->HasAura(FIRE_WARD, EFFECT_INDEX_0) && CastSpell(FIRE_WARD, m_bot))
+                return RETURN_CONTINUE;
+            if (COMBUSTION > 0 && m_ai->In_Reach(m_bot,COMBUSTION) && !m_bot->HasAura(COMBUSTION, EFFECT_INDEX_0) && CastSpell(COMBUSTION, m_bot))
+                return RETURN_CONTINUE;
+            if (FIREBALL > 0 && m_ai->In_Reach(pTarget,FIREBALL) && CastSpell(FIREBALL, pTarget))
+                return RETURN_CONTINUE;
+            if (FIRE_BLAST > 0 && m_ai->In_Reach(pTarget,FIRE_BLAST) && CastSpell(FIRE_BLAST, pTarget))
+                return RETURN_CONTINUE;
+            if (FLAMESTRIKE > 0 && m_ai->In_Reach(pTarget,FLAMESTRIKE) && CastSpell(FLAMESTRIKE, pTarget))
+                return RETURN_CONTINUE;
+            if (SCORCH > 0 && m_ai->In_Reach(pTarget,SCORCH) && CastSpell(SCORCH, pTarget))
+                return RETURN_CONTINUE;
+            if (PYROBLAST > 0 && m_ai->In_Reach(pTarget,PYROBLAST) && !pTarget->HasAura(PYROBLAST, EFFECT_INDEX_0) && CastSpell(PYROBLAST, pTarget))
+                return RETURN_CONTINUE;
+            if (BLAST_WAVE > 0 && m_ai->GetAttackerCount() >= 3 && meleeReach && CastSpell(BLAST_WAVE, pTarget))
+                return RETURN_CONTINUE;
+
+            if (FIREBALL > 0 && m_ai->In_Reach(pTarget,FIREBALL))
+                return CastSpell(FIREBALL, pTarget);
+            break;
+
+        case MAGE_SPEC_ARCANE:
+            if (ARCANE_POWER > 0 && m_ai->In_Reach(pTarget,ARCANE_POWER) && CastSpell(ARCANE_POWER, pTarget))
+                return RETURN_CONTINUE;
+            if (ARCANE_MISSILES > 0 && m_ai->In_Reach(pTarget,ARCANE_MISSILES) && CastSpell(ARCANE_MISSILES, pTarget))
+            {
+                m_ai->SetIgnoreUpdateTime(3);
+                return RETURN_CONTINUE;
+            }
+            if (ARCANE_EXPLOSION > 0 && m_ai->GetAttackerCount() >= 3 && meleeReach && CastSpell(ARCANE_EXPLOSION, pTarget))
+                return RETURN_CONTINUE;
+            if (COUNTERSPELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTERSPELL, pTarget))
+                return RETURN_CONTINUE;
+            if (SLOW > 0 && m_ai->In_Reach(pTarget,SLOW) && !pTarget->HasAura(SLOW, EFFECT_INDEX_0) && CastSpell(SLOW, pTarget))
+                return RETURN_CONTINUE;
+            if (MANA_SHIELD > 0 && m_ai->GetHealthPercent() < 70 && pVictim == m_bot && !m_bot->HasAura(MANA_SHIELD, EFFECT_INDEX_0) && CastSpell(MANA_SHIELD, m_bot))
+                return RETURN_CONTINUE;
+
+            if (FIREBALL > 0 && m_ai->In_Reach(pTarget,FIREBALL))
+                return CastSpell(FIREBALL, pTarget);
+            break;
+    }
+
+    // No spec due to low level OR no spell found yet
+    if (FROSTBOLT > 0 && m_ai->In_Reach(pTarget,FROSTBOLT) && !pTarget->HasAura(FROSTBOLT, EFFECT_INDEX_0))
+        return CastSpell(FROSTBOLT, pTarget);
+    if (FIREBALL > 0 && m_ai->In_Reach(pTarget,FIREBALL)) // Very low levels
+        return CastSpell(FIREBALL, pTarget);
+
+    return RETURN_NO_ACTION_ERROR; // What? Not even Fireball is available?
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (FIREBALL && m_ai->In_Reach(pTarget,FIREBALL) && m_ai->CastSpell(FIREBALL))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    Player* master = GetMaster();
+
+    if (!m_bot || !master)
+        return;
+
+    // Buff armor
+    if (MAGE_ARMOR)
+    {
+        if (m_ai->SelfBuff(MAGE_ARMOR))
+            return;
+    }
+    else if (ICE_ARMOR)
+    {
+        if (m_ai->SelfBuff(ICE_ARMOR))
+            return;
+    }
+    else if (FROST_ARMOR)
+        if (m_ai->SelfBuff(FROST_ARMOR))
+            return;
+
+    // buff group
+    if (m_bot->GetGroup() && m_ai->HasSpellReagents(ARCANE_BRILLIANCE) && Buff(&PlayerbotMageAI::BuffHelper, ARCANE_BRILLIANCE) & RETURN_CONTINUE)
+        return;
+    else if (Buff(&PlayerbotMageAI::BuffHelper, ARCANE_INTELLECT, JOB_MANAONLY) & RETURN_CONTINUE)
+        return;
+
+    // TODO: The beauty of a mage is not only its ability to supply itself with water, but to share its water
+    // So, conjure at *least* 1.25 stacks, ready to trade a stack and still have some left for self
+    if (m_ai->FindDrink() == nullptr && CONJURE_WATER && m_ai->CastSpell(CONJURE_WATER, *m_bot))
+    {
+        m_ai->TellMaster("I'm conjuring some water.");
+        m_ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+    if (m_ai->FindFood() == nullptr && CONJURE_FOOD && m_ai->CastSpell(CONJURE_FOOD, *m_bot))
+    {
+        m_ai->TellMaster("I'm conjuring some food.");
+        m_ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+
+    if (EatDrinkBandage())
+        return;
+} // end DoNonCombatActions
+
+// TODO: this and priest's BuffHelper are identical and thus could probably go in PlayerbotClassAI.cpp somewhere
+bool PlayerbotMageAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target)
+{
+    if (!ai)          return false;
+    if (spellId == 0) return false;
+    if (!target)      return false;
+
+    Pet* pet = target->GetPet();
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet))
+        return true;
+
+    if (ai->Buff(spellId, target))
+        return true;
+
+    return false;
+}
+
+// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
+uint32 PlayerbotMageAI::Neutralize(uint8 creatureType)
+{
+    if (!m_bot)         return 0;
+    if (!m_ai)          return 0;
+    if (!creatureType)  return 0;
+
+    if (creatureType != CREATURE_TYPE_HUMANOID && creatureType != CREATURE_TYPE_BEAST)
+    {
+        m_ai->TellMaster("I can't polymorph that target.");
+        return 0;
+    }
+
+    if (POLYMORPH)
+        return POLYMORPH;
+    else
+        return 0;
+
+    return 0;
+}
\ No newline at end of file
diff -ruN mangos-classic/src/game/playerbot/PlayerbotMageAI.h portalclassic/src/game/playerbot/PlayerbotMageAI.h
--- mangos-classic/src/game/playerbot/PlayerbotMageAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotMageAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,136 @@
+#ifndef _PlayerbotMageAI_H
+#define _PlayerbotMageAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_FROST,
+    SPELL_FIRE,
+    SPELL_ARCANE
+};
+
+enum MageSpells
+{
+    AMPLIFY_MAGIC_1                 = 1008,
+    ARCANE_BRILLIANCE_1             = 23028,
+    ARCANE_EXPLOSION_1              = 1449,
+    ARCANE_INTELLECT_1              = 1459,
+    ARCANE_MISSILES_1               = 5143,
+    ARCANE_POWER_1                  = 12042,
+    BLAST_WAVE_1                    = 11113,
+    BLINK_1                         = 1953,
+    BLIZZARD_1                      = 10,
+    COLD_SNAP_1                     = 12472,
+    COMBUSTION_1                    = 11129,
+    CONE_OF_COLD_1                  = 120,
+    CONJURE_FOOD_1                  = 587,
+    CONJURE_MANA_GEM_1              = 759,
+    CONJURE_WATER_1                 = 5504,
+    COUNTERSPELL_1                  = 2139,
+    DAMPEN_MAGIC_1                  = 604,
+    EVOCATION_1                     = 12051,
+    FIRE_BLAST_1                    = 2136,
+    FIRE_WARD_1                     = 543,
+    FIREBALL_1                      = 133,
+    FLAMESTRIKE_1                   = 2120,
+    FROST_ARMOR_1                   = 168,
+    FROST_NOVA_1                    = 122,
+    FROST_WARD_1                    = 6143,
+    FROSTBOLT_1                     = 116,
+    ICE_ARMOR_1                     = 7302,
+    ICE_BARRIER_1                   = 11426,
+    ICE_BLOCK_1                     = 27619,
+    INVISIBILITY_1                  = 66,
+    MAGE_ARMOR_1                    = 6117,
+    MANA_SHIELD_1                   = 1463,
+    POLYMORPH_1                     = 118,
+    PRESENCE_OF_MIND_1              = 12043,
+    PYROBLAST_1                     = 11366,
+    REMOVE_CURSE_MAGE_1             = 475,
+    SCORCH_1                        = 2948,
+    SHOOT_2                         = 5019,
+    SLOW_FALL_1                     = 130
+};
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotMageAI : PlayerbotClassAI
+{
+public:
+    PlayerbotMageAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotMageAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    uint32 Neutralize(uint8 creatureType);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    CombatManeuverReturns CastSpell(uint32 nextAction, Unit *pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
+
+    static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target);
+
+    // ARCANE
+    uint32 ARCANE_MISSILES,
+           ARCANE_EXPLOSION,
+           COUNTERSPELL,
+           SLOW,
+           POLYMORPH,
+           ARCANE_POWER;
+
+    // RANGED
+    uint32 SHOOT;
+
+    // FIRE
+    uint32 FIREBALL,
+           FIRE_BLAST,
+           FLAMESTRIKE,
+           SCORCH,
+           PYROBLAST,
+           BLAST_WAVE,
+           COMBUSTION,
+           FIRE_WARD;
+
+    // FROST
+    uint32 FROSTBOLT,
+           FROST_NOVA,
+           BLIZZARD,
+           CONE_OF_COLD,
+           ICE_BARRIER,
+           FROST_WARD,
+           ICE_BLOCK,
+           COLD_SNAP;
+
+    // buffs
+    uint32 FROST_ARMOR,
+           ICE_ARMOR,
+           MAGE_ARMOR,
+           ARCANE_INTELLECT,
+           ARCANE_BRILLIANCE,
+           MANA_SHIELD,
+           DAMPEN_MAGIC,
+           AMPLIFY_MAGIC;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           PERCEPTION,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 CONJURE_WATER,
+           CONJURE_FOOD;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotMgr.cpp portalclassic/src/game/playerbot/PlayerbotMgr.cpp
--- mangos-classic/src/game/playerbot/PlayerbotMgr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotMgr.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,1155 @@
+#include "Config/Config.h"
+#include "config.h"
+#include "../Player.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "WorldPacket.h"
+#include "../Chat.h"
+#include "../ObjectMgr.h"
+#include "../GossipDef.h"
+#include "../Chat.h"
+#include "../Language.h"
+#include "../WaypointMovementGenerator.h"
+#include "../LootMgr.h"
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+Config botConfig;
+
+void PlayerbotMgr::SetInitialWorldSettings()
+{
+    //Get playerbot configuration file
+    if (!botConfig.SetSource(_PLAYERBOT_CONFIG))
+        sLog.outError("Playerbot: Unable to open configuration file. Database will be unaccessible. Configuration values will use default.");
+    else
+        sLog.outString("Playerbot: Using configuration file %s",_PLAYERBOT_CONFIG);
+
+    //Check playerbot config file version
+    if (botConfig.GetIntDefault("ConfVersion", 0) != PLAYERBOT_CONF_VERSION)
+        sLog.outError("Playerbot: Configuration file version doesn't match expected version. Some config variables may be wrong or missing.");
+}
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : m_master(master)
+{
+    // load config variables
+    m_confMaxNumBots = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+    m_confDebugWhisper = botConfig.GetBoolDefault("PlayerbotAI.DebugWhisper", false);
+    m_confFollowDistance[0] = botConfig.GetFloatDefault("PlayerbotAI.FollowDistanceMin", 0.5f);
+    m_confFollowDistance[1] = botConfig.GetFloatDefault("PlayerbotAI.FollowDistanceMax", 1.0f);
+    m_confCollectCombat = botConfig.GetBoolDefault("PlayerbotAI.Collect.Combat", true);
+    m_confCollectQuest = botConfig.GetBoolDefault("PlayerbotAI.Collect.Quest", true);
+    m_confCollectProfession = botConfig.GetBoolDefault("PlayerbotAI.Collect.Profession", true);
+    m_confCollectLoot = botConfig.GetBoolDefault("PlayerbotAI.Collect.Loot", true);
+    m_confCollectSkin = botConfig.GetBoolDefault("PlayerbotAI.Collect.Skin", true);
+    m_confCollectObjects = botConfig.GetBoolDefault("PlayerbotAI.Collect.Objects", true);
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+    LogoutAllBots();
+}
+
+void PlayerbotMgr::UpdateAI(const uint32 /*p_time*/) {}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            ObjectGuid guid;
+            std::vector<uint32> nodes;
+            nodes.resize(2);
+            uint8 delay = 9;
+
+            p >> guid >> nodes[0] >> nodes[1];
+
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXI from %d to %d", nodes[0], nodes[1]);
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = ObjectAccessor::GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            ObjectGuid guid;
+            uint32 node_count;
+            uint8 delay = 9;
+
+            p >> guid;
+            p.read_skip<uint32>();
+            p >> node_count;
+
+            std::vector<uint32> nodes;
+
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                nodes.push_back(node);
+            }
+
+            if (nodes.empty())
+                return;
+
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXIEXPRESS from %d to %d", nodes.front(), nodes.back());
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = ObjectAccessor::GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        case CMSG_MOVE_SPLINE_DONE:
+        {
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE");
+
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            ObjectGuid guid;                                        // used only for proper packet read
+            MovementInfo movementInfo;                              // used only for proper packet read
+
+            p >> guid.ReadAsPacked();
+            p >> movementInfo;
+            p >> Unused<uint32>();                          // unk
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                // in taxi flight packet received in 2 case:
+                // 1) end taxi path in far (multi-node) flight
+                // 2) switch from one map to other in case multi-map taxi path
+                // we need process only (1)
+                uint32 curDest = bot->m_taxi.GetTaxiDestination();
+                if (!curDest)
+                    return;
+
+                TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+
+                // far teleport case
+                if (curDestNode && curDestNode->map_id != bot->GetMapId())
+                {
+                    if (bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+                    {
+                        // short preparations to continue flight
+                        FlightPathMovementGenerator* flight = (FlightPathMovementGenerator *) (bot->GetMotionMaster()->top());
+
+                        flight->Interrupt(*bot);                // will reset at map landing
+
+                        flight->SetCurrentNodeAfterTeleport();
+                        TaxiPathNodeEntry const& node = flight->GetPath()[flight->GetCurrentNode()];
+                        flight->SkipCurrentNode();
+
+                        bot->TeleportTo(curDestNode->map_id, node.x, node.y, node.z, bot->GetOrientation());
+                    }
+                    return;
+                }
+
+                uint32 destinationnode = bot->m_taxi.NextTaxiDestination();
+                if (destinationnode > 0)                                // if more destinations to go
+                {
+                    // current source node for next destination
+                    uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+
+                    // Add to taximask middle hubs in taxicheat mode (to prevent having player with disabled taxicheat and not having back flight path)
+                    if (bot->isTaxiCheater())
+                        if (bot->m_taxi.SetTaximaskNode(sourcenode))
+                        {
+                            WorldPacket data(SMSG_NEW_TAXI_PATH, 0);
+                            bot->GetSession()->SendPacket(&data);
+                        }
+
+                    DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE Taxi has to go from %u to %u", sourcenode, destinationnode);
+
+                    uint32 mountDisplayId = sObjectMgr.GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                    uint32 path, cost;
+                    sObjectMgr.GetTaxiPath(sourcenode, destinationnode, path, cost);
+
+                    if (path && mountDisplayId)
+                        bot->GetSession()->SendDoFlight(mountDisplayId, path, 1);          // skip start fly node
+                    else
+                        bot->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+                }
+                else
+                    /* std::ostringstream out;
+                       out << "Destination reached" << bot->GetName();
+                       ChatHandler ch(m_master);
+                       ch.SendSysMessage(out.str().c_str()); */
+                    bot->m_taxi.ClearTaxiDestinations();        // Destination, clear source node
+            }
+            return;
+        }
+
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+
+        // If master inspects one of his bots, give the master useful info in chat window
+        // such as inventory that can be equipped
+        case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            ObjectGuid guid;
+            p >> guid;
+            Player* const bot = GetPlayerBot(guid);
+            if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+            return;
+        }
+
+        // handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint32 emoteNum;
+            p >> emoteNum;
+
+            /* std::ostringstream out;
+               out << "emote is: " << emoteNum;
+               ChatHandler ch(m_master);
+               ch.SendSysMessage(out.str().c_str()); */
+
+            switch (emoteNum)
+            {
+                case TEXTEMOTE_BOW:
+                {
+                    // Buff anyone who bows before me. Useful for players not in bot's group
+                    // How do I get correct target???
+                    //Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
+                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    return;
+                }
+                /*
+                   case TEXTEMOTE_BONK:
+                   {
+                    Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    if (!pPlayer || !pPlayer->GetPlayerbotAI())
+                        return;
+                    PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(m_master);
+                    {
+                        std::ostringstream out;
+                        out << "CurrentTime: " << CurrentTime()
+                            << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                            << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
+                        out << "tradeActive: " << tradeActive;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsCharmed() " << pBot->getPlayer()->isCharmed();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                   }
+                 */
+
+                case TEXTEMOTE_EAT:
+                case TEXTEMOTE_DRINK:
+                    return;
+
+                // emote to attack selected target
+                case TEXTEMOTE_POINT:
+                {
+                    ObjectGuid attackOnGuid = m_master->GetSelectionGuid();
+                    if (!attackOnGuid)
+                        return;
+
+                    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_master, attackOnGuid);
+                    if (!thingToAttack) return;
+
+                    Player* bot = 0;
+                    for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+                    {
+                        bot = itr->second;
+                        if (!bot->IsFriendlyTo(thingToAttack))
+                        {
+                            if (!bot->IsWithinLOSInMap(thingToAttack))
+                                bot->GetPlayerbotAI()->DoTeleport(*m_master);
+                            if (bot->IsWithinLOSInMap(thingToAttack))
+                                bot->GetPlayerbotAI()->Attack(thingToAttack);
+                        }
+                    }
+                    return;
+                }
+
+                // emote to stay
+                case TEXTEMOTE_STAND:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelectionGuid());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
+                    else
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
+                        }
+                    return;
+                }
+
+                // 324 is the followme emote (not defined in enum)
+                // if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXTEMOTE_WAVE:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelectionGuid());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
+                    else
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
+                        }
+                    return;
+                }
+            }
+            return;
+        } /* EMOTE ends here */
+
+        case CMSG_GAMEOBJ_USE: // not sure if we still need this one
+        {
+            DEBUG_LOG("PlayerbotMgr: CMSG_GAMEOBJ_USE");
+
+            WorldPacket p(packet);
+            p.rpos(0);     // reset reader
+            ObjectGuid objGUID;
+            p >> objGUID;
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+                if (!obj)
+                    return;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    bot->GetPlayerbotAI()->TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    bot->PrepareQuestMenu(objGUID);
+                    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.m_qId;
+                        if (!bot->GetPlayerbotAI()->AddQuest(questID, obj))
+                            DEBUG_LOG("Couldn't take quest");
+                    }
+                }
+            }
+        }
+        break;
+
+        case CMSG_QUESTGIVER_HELLO:
+        {
+            DEBUG_LOG("PlayerbotMgr: CMSG_QUESTGIVER_HELLO");
+
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            ObjectGuid npcGUID;
+            p >> npcGUID;
+
+            WorldObject* pNpc = m_master->GetMap()->GetWorldObject(npcGUID);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+
+            return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            ObjectGuid guid;
+            uint32 quest;
+            uint32 unk1;
+            p >> guid >> quest;
+
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_ACCEPT_QUEST npc = %s, quest = %u, unk1 = %u", guid.GetString().c_str(), quest, unk1);
+
+            Quest const* qInfo = sObjectMgr.GetQuestTemplate(quest);
+            if (qInfo)
+                for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (!bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (!bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (!bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (!bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0);         // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+
+                        // build needed items if quest contains any
+                        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+                            if (qInfo->ReqItemCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedItems();
+                                break;
+                            }
+
+                        // build needed creatures if quest contains any
+                        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                            if (qInfo->ReqCreatureOrGOCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedCreatures();
+                                break;
+                            }
+                    }
+                }
+            return;
+        }
+
+        case CMSG_AREATRIGGER:
+        {
+            WorldPacket p(packet);
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                p.rpos(0);         // reset reader
+                bot->GetSession()->HandleAreaTriggerOpcode(p);
+            }
+            return;
+        }
+
+        case CMSG_QUESTGIVER_COMPLETE_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint32 quest;
+            ObjectGuid npcGUID;
+            p >> npcGUID >> quest;
+
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %s, quest = %u", npcGUID.GetString().c_str(), quest);
+
+            WorldObject* pNpc = m_master->GetMap()->GetWorldObject(npcGUID);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+            return;
+        }
+
+        case CMSG_LOOT_ROLL:
+        {
+            WorldPacket p(packet);  //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+            ObjectGuid Guid;
+            uint32 itemSlot;
+            uint8 rollType;
+
+            p.rpos(0);              //reset packet pointer
+            p >> Guid;              //guid of the lootable target
+            p >> itemSlot;          //loot index
+            p >> rollType;          //need,greed or pass on roll
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                uint32 choice = 0;
+
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    return;
+
+                // check that the bot did not already vote
+                if (rollType >= ROLL_NOT_EMITED_YET)
+                    return;
+
+                Loot* loot = sLootMgr.GetLoot(bot, Guid);
+
+                if (!loot)
+                {
+                    sLog.outError("LootMgr::PlayerVote> Error cannot get loot object info!");
+                    return;
+                }
+
+                LootItem* lootItem = loot->GetLootItemInSlot(itemSlot);
+
+                ItemPrototype const *pProto = lootItem->itemProto;
+                if (!pProto)
+                    return;
+
+                if (bot->GetPlayerbotAI()->CanStore())
+                {
+                    if (bot->CanUseItem(pProto) == EQUIP_ERR_OK && bot->GetPlayerbotAI()->IsItemUseful(lootItem->itemId))
+                        choice = 1; // Need
+                    else
+                        choice = 2; // Greed
+                }
+                else
+                    choice = 0;     // Pass
+
+                sLootMgr.PlayerVote(bot, Guid, itemSlot, RollVote(choice));
+            }
+            return;
+        }
+        // Handle GOSSIP activate actions, prior to GOSSIP select menu actions
+        case CMSG_GOSSIP_HELLO:
+        {
+            DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_GOSSIP_HELLO");
+
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_GOSSIP_HELLO, (8)
+            ObjectGuid guid;
+            p.rpos(0);                //reset packet pointer
+            p >> guid;
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+                if (!pCreature)
+                {
+                    DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %s not found or you can't interact with him.", guid.GetString().c_str());
+                    return;
+                }
+
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(pCreature->GetCreatureInfo()->GossipMenuId);
+                for (GossipMenuItemsMap::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
+                {
+                    uint32 npcflags = pCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+                    if (!(itr->second.npc_option_npcflag & npcflags))
+                        continue;
+
+                    switch (itr->second.option_id)
+                    {
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_TAXIVENDOR");
+                            bot->GetSession()->SendLearnNewTaxiNode(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_QUESTGIVER");
+                            bot->GetPlayerbotAI()->TurnInQuests(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_VENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_VENDOR");
+                            if (!botConfig.GetBoolDefault("PlayerbotAI.SellGarbage", true))
+                                return;
+
+                            bot->GetPlayerbotAI()->SellGarbage();
+                            break;
+                        }
+                        case GOSSIP_OPTION_STABLEPET:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_STABLEPET");
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_AUCTIONEER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_BANKER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_INNKEEPER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_INNKEEPER");
+                            break;
+                        }
+                    }
+                }
+            }
+            return;
+        }
+
+        case CMSG_SPIRIT_HEALER_ACTIVATE:
+        {
+            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_SPIRIT_HEALER_ACTIVATE SpiritHealer is resurrecting the Player %s",m_master->GetName());
+            for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+            {
+                Player* const bot = itr->second;
+                Group *grp = bot->GetGroup();
+                if (grp)
+                    grp->RemoveMember(bot->GetObjectGuid(), 1);
+            }
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+        {
+            if (!botConfig.GetBoolDefault("PlayerbotAI.SellGarbage", true))
+                return;
+
+            WorldPacket p(packet);
+            p.rpos(0);  // reset reader
+            ObjectGuid npcGUID;
+            p >> npcGUID;
+
+            Object* const pNpc = (WorldObject *) m_master->GetObjectByTypeMask(npcGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot->IsInMap(static_cast<WorldObject *>(pNpc)))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                    continue;
+                }
+                else
+                    bot->GetPlayerbotAI()->SellGarbage();
+            }
+            return;
+        }
+
+        /*
+        case CMSG_NAME_QUERY:
+        case MSG_MOVE_START_FORWARD:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case MSG_MOVE_START_STRAFE_RIGHT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_BACKWARD:
+        case MSG_MOVE_HEARTBEAT:
+        case CMSG_STANDSTATECHANGE:
+        case CMSG_QUERY_TIME:
+        case CMSG_CREATURE_QUERY:
+        case CMSG_GAMEOBJECT_QUERY:
+        case MSG_MOVE_JUMP:
+        case MSG_MOVE_FALL_LAND:
+        return;*/
+
+    default:
+        {
+            /*const char* oc = LookupOpcodeName(packet.GetOpcode());
+            // ChatHandler ch(m_master);
+            // ch.SendSysMessage(oc);
+
+            std::ostringstream out;
+            out << "masterin: " << oc;
+            sLog.outError(out.str().c_str()); */
+        }
+    }
+}
+
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& /*packet*/)
+{
+    /*
+       switch (packet.GetOpcode())
+       {
+        // maybe our bots should only start looting after the master loots?
+        //case SMSG_LOOT_RELEASE_RESPONSE: {}
+        case SMSG_NAME_QUERY_RESPONSE:
+        case SMSG_MONSTER_MOVE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case SMSG_DESTROY_OBJECT:
+        case SMSG_UPDATE_OBJECT:
+        case SMSG_STANDSTATE_UPDATE:
+        case MSG_MOVE_HEARTBEAT:
+        case SMSG_QUERY_TIME_RESPONSE:
+        case SMSG_AURA_UPDATE_ALL:
+        case SMSG_CREATURE_QUERY_RESPONSE:
+        case SMSG_GAMEOBJECT_QUERY_RESPONSE:
+            return;
+        default:
+        {
+            const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+            std::ostringstream out;
+            out << "masterout: " << oc;
+            sLog.outError(out.str().c_str());
+        }
+       }
+     */
+}
+
+void PlayerbotMgr::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot = itr->second;
+        LogoutPlayerBot(bot->GetObjectGuid());
+    }
+    RemoveAllBotsFromGroup();
+}
+
+
+
+void PlayerbotMgr::Stay()
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* bot = itr->second;
+        bot->GetMotionMaster()->Clear();
+    }
+}
+
+
+// Playerbot mod: logs out a Playerbot.
+void PlayerbotMgr::LogoutPlayerBot(ObjectGuid guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+// Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* PlayerbotMgr::GetPlayerBot(ObjectGuid playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return (it == m_playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotMgr::OnBotLogin(Player * const bot)
+{
+    // give the bot some AI, object is owned by the player class
+    PlayerbotAI* ai = new PlayerbotAI(this, bot);
+    bot->SetPlayerbotAI(ai);
+
+    // tell the world session that they now manage this new bot
+    m_playerBots[bot->GetObjectGuid()] = bot;
+
+    // if bot is in a group and master is not in group then
+    // have bot leave their group
+    if (bot->GetGroup() &&
+        (m_master->GetGroup() == nullptr ||
+         m_master->GetGroup()->IsMember(bot->GetObjectGuid()) == false))
+        bot->RemoveFromGroup();
+
+    // sometimes master can lose leadership, pass leadership to master check
+    const ObjectGuid masterGuid = m_master->GetObjectGuid();
+    if (m_master->GetGroup() &&
+        !m_master->GetGroup()->IsLeader(masterGuid))
+        m_master->GetGroup()->ChangeLeader(masterGuid);
+}
+
+void PlayerbotMgr::RemoveAllBotsFromGroup()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); m_master->GetGroup() && it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->IsInSameGroupWith(m_master))
+            m_master->GetGroup()->RemoveMember(bot->GetObjectGuid(), 0);
+    }
+}
+
+void Creature::LoadBotMenu(Player *pPlayer)
+{
+
+    if (pPlayer->GetPlayerbotAI()) return;
+    ObjectGuid guid = pPlayer->GetObjectGuid();
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(guid);
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account='%d'", accountId);
+    do
+    {
+        Field *fields = result->Fetch();
+        ObjectGuid guidlo = ObjectGuid(fields[0].GetUInt64());
+        std::string name = fields[1].GetString();
+        std::string word = "";
+
+        if ((guid == ObjectGuid()) || (guid == guidlo))
+        {
+            //not found or himself
+        }
+        else
+        {
+            // if(sConfig.GetBoolDefault("PlayerbotAI.DisableBots", false)) return;
+            // create the manager if it doesn't already exist
+            if (!pPlayer->GetPlayerbotMgr())
+                pPlayer->SetPlayerbotMgr(new PlayerbotMgr(pPlayer));
+            if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) == nullptr) // add (if not already in game)
+            {
+                word += "Recruit ";
+                word += name;
+                word += " as a Bot.";
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8) 9, word, guidlo, GOSSIP_OPTION_BOT, word, false);
+            }
+            else if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) != nullptr) // remove (if in game)
+            {
+                word += "Dismiss ";
+                word += name;
+                word += " from duty.";
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8) 0, word, guidlo, GOSSIP_OPTION_BOT, word, false);
+            }
+        }
+    }
+    while (result->NextRow());
+    delete result;
+}
+
+void Player::skill(std::list<uint32>& m_spellsToLearn)
+{
+    for (SkillStatusMap::const_iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+    {
+        if (itr->second.uState == SKILL_DELETED)
+            continue;
+
+        uint32 pskill = itr->first;
+
+        m_spellsToLearn.push_back(pskill);
+    }
+}
+
+void Player::chompAndTrim(std::string& str)
+{
+    while (str.length() > 0)
+    {
+        char lc = str[str.length() - 1];
+        if (lc == '\r' || lc == '\n' || lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(0, str.length() - 1);
+        else
+            break;
+        while (str.length() > 0)
+        {
+            char lc = str[0];
+            if (lc == ' ' || lc == '"' || lc == '\'')
+                str = str.substr(1, str.length() - 1);
+            else
+                break;
+        }
+    }
+}
+
+bool Player::getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId)
+{
+    bool result = false;
+    unsigned int i;
+    for (i = pStartPos; i < pString.size(); ++i)
+    {
+        if (pString[i] == ',')
+            break;
+    }
+    if (i > pStartPos)
+    {
+        std::string idString = pString.substr(pStartPos, i - pStartPos);
+        pStartPos = i + 1;
+        chompAndTrim(idString);
+        pId = atoi(idString.c_str());
+        result = true;
+    }
+    return(result);
+}
+
+bool Player::requiredQuests(const char* pQuestIdString)
+{
+    if (pQuestIdString != nullptr)
+    {
+        unsigned int pos = 0;
+        unsigned int id;
+        std::string confString(pQuestIdString);
+        chompAndTrim(confString);
+        while (getNextQuestId(confString, pos, id))
+        {
+            QuestStatus status = GetQuestStatus(id);
+            if (status == QUEST_STATUS_COMPLETE)
+                return true;
+        }
+    }
+    return false;
+}
+
+//See MainSpec enum in PlayerbotAI.h for details on class return values
+uint32 Player::GetSpec()
+{
+    uint32 row = 0, spec = 0;
+    Player* player = m_session->GetPlayer();
+    uint32 classMask = player->getClassMask();
+
+    for (unsigned int i = 0; i < sTalentStore.GetNumRows(); ++i)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(i);
+
+        if (!talentInfo)
+            continue;
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+        if (!talentTabInfo)
+            continue;
+
+        if ((classMask & talentTabInfo->ClassMask) == 0)
+            continue;
+
+        uint32 curtalent_maxrank = 0;
+        for (int32 k = MAX_TALENT_RANK - 1; k > -1; --k)
+        {
+            if (talentInfo->RankID[k] && HasSpell(talentInfo->RankID[k]))
+            {
+                if (row == 0 && spec == 0)
+                    spec = talentInfo->TalentTab;
+
+                if (talentInfo->Row > row)
+                {
+                    row = talentInfo->Row;
+                    spec = talentInfo->TalentTab;
+                }
+            }
+        }
+    }
+
+    //Return the tree with the deepest talent
+    return spec;
+}
+
+bool ChatHandler::HandlePlayerbotCommand(char* args)
+{
+    if (!(m_session->GetSecurity() > SEC_PLAYER))
+        if (botConfig.GetBoolDefault("PlayerbotAI.DisableBots", false))
+        {
+            PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+    if (!m_session)
+    {
+        PSendSysMessage("|cffff0000You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!*args)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char *) args, " ");
+    char *charname = strtok (nullptr, " ");
+
+    if (!cmd || !charname)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    if (!normalizePlayerName(charnameStr))
+        return false;
+
+    ObjectGuid guid = sObjectMgr.GetPlayerGuidByName(charnameStr.c_str());
+    if (guid == ObjectGuid() || (guid == m_session->GetPlayer()->GetObjectGuid()))
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(guid);
+    if (accountId != m_session->GetAccountId())
+    {
+        PSendSysMessage("|cffff0000You may only add bots from the same account.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // create the playerbot manager if it doesn't already exist
+    PlayerbotMgr* mgr = m_session->GetPlayer()->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        mgr = new PlayerbotMgr(m_session->GetPlayer());
+        m_session->GetPlayer()->SetPlayerbotMgr(mgr);
+    }
+
+    QueryResult *resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
+    if (resultchar)
+    {
+        Field *fields = resultchar->Fetch();
+        int acctcharcount = fields[0].GetUInt32();
+        int maxnum = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+        if (!(m_session->GetSecurity() > SEC_PLAYER))
+            if (acctcharcount > maxnum && (cmdStr == "add" || cmdStr == "login"))
+            {
+                PSendSysMessage("|cffff0000You cannot summon anymore bots.(Current Max: |cffffffff%u)", maxnum);
+                SetSentErrorMessage(true);
+                delete resultchar;
+                return false;
+            }
+        delete resultchar;
+    }
+
+    QueryResult *resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guid.GetCounter());
+    if (resultlvl)
+    {
+        Field *fields = resultlvl->Fetch();
+        int charlvl = fields[0].GetUInt32();
+        int maxlvl = botConfig.GetIntDefault("PlayerbotAI.RestrictBotLevel", 60);
+        if (!(m_session->GetSecurity() > SEC_PLAYER))
+            if (charlvl > maxlvl)
+            {
+                PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.(Current Max:lvl |cffffffff%u)", fields[1].GetString(), maxlvl);
+                SetSentErrorMessage(true);
+                delete resultlvl;
+                return false;
+            }
+        delete resultlvl;
+    }
+
+    // end of gmconfig patch
+    if (cmdStr == "add" || cmdStr == "login")
+    {
+        if (mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("Bot already exists in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 1 WHERE guid = '%u'", guid.GetCounter());
+        mgr->LoginPlayerBot(guid);
+        PSendSysMessage("Bot added successfully.");
+    }
+    else if (cmdStr == "remove" || cmdStr == "logout")
+    {
+        if (!mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("|cffff0000Bot can not be removed because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid.GetCounter());
+        mgr->LogoutPlayerBot(guid);
+        PSendSysMessage("Bot removed successfully.");
+    }
+    else if (cmdStr == "co" || cmdStr == "combatorder")
+    {
+        Unit *target = nullptr;
+        char *orderChar = strtok(nullptr, " ");
+        if (!orderChar)
+        {
+            PSendSysMessage("|cffff0000Syntax error:|cffffffff .bot co <botName> <order=reset|tank|assist|heal|protect> [targetPlayer]");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+        return true;
+    }
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotMgr.h portalclassic/src/game/playerbot/PlayerbotMgr.h
--- mangos-classic/src/game/playerbot/PlayerbotMgr.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotMgr.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,68 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+typedef std::unordered_map<ObjectGuid, Player*> PlayerBotMap;
+
+class MANGOS_DLL_SPEC PlayerbotMgr
+{
+    // static functions, available without a PlayerbotMgr instance
+public:
+    static void SetInitialWorldSettings();
+
+public:
+    PlayerbotMgr(Player * const master);
+    virtual ~PlayerbotMgr();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called whenever the master sends a packet to the server.
+    // These packets can be viewed, but not edited.
+    // It allows bot creators to craft AI in response to a master's actions.
+    // For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    // Notice: that this is static which means it is called once for all bots of the master.
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+
+    void LoginPlayerBot(ObjectGuid guid);
+    void LogoutPlayerBot(ObjectGuid guid);
+    Player* GetPlayerBot (ObjectGuid guid) const;
+    Player* GetMaster() const { return m_master; };
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
+    void LogoutAllBots();
+    void RemoveAllBotsFromGroup();
+    void OnBotLogin(Player * const bot);
+    void Stay();
+
+public:
+    // config variables
+    uint32 m_confRestrictBotLevel;
+    uint32 m_confDisableBotsInRealm;
+    uint32 m_confMaxNumBots;
+    bool m_confDisableBots;
+    bool m_confDebugWhisper;
+    float m_confFollowDistance[2];
+    bool m_confCollectCombat;
+    bool m_confCollectQuest;
+    bool m_confCollectProfession;
+    bool m_confCollectLoot;
+    bool m_confCollectSkin;
+    bool m_confCollectObjects;
+
+private:
+    Player* const m_master;
+    PlayerBotMap m_playerBots;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotPaladinAI.cpp portalclassic/src/game/playerbot/PlayerbotPaladinAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotPaladinAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotPaladinAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,770 @@
+/*
+   Name    : PlayerbotPaladinAI.cpp
+   Complete: maybe around 27% :D
+   Author  : Natsukawa
+   Version : 0.35
+ */
+
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMgr.h"
+#include "../SpellAuras.h"
+
+class PlayerbotAI;
+
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RETRIBUTION_AURA              = m_ai->initSpell(RETRIBUTION_AURA_1);
+    SEAL_OF_COMMAND               = m_ai->initSpell(SEAL_OF_COMMAND_1);
+    SEAL_OF_RIGHTEOUSNESS         = m_ai->initSpell(SEAL_OF_RIGHTEOUSNESS_1);
+    SEAL_OF_JUSTICE               = m_ai->initSpell(SEAL_OF_JUSTICE_1);
+    SEAL_OF_LIGHT                 = m_ai->initSpell(SEAL_OF_LIGHT_1);
+    SEAL_OF_WISDOM                = m_ai->initSpell(SEAL_OF_WISDOM_1);
+    SEAL_OF_THE_CRUSADER          = m_ai->initSpell(SEAL_OF_THE_CRUSADER_1);
+    JUDGEMENT                     = m_ai->initSpell(JUDGEMENT_1);
+    BLESSING_OF_MIGHT             = m_ai->initSpell(BLESSING_OF_MIGHT_1);
+    GREATER_BLESSING_OF_MIGHT     = m_ai->initSpell(GREATER_BLESSING_OF_MIGHT_1);
+    HAMMER_OF_WRATH               = m_ai->initSpell(HAMMER_OF_WRATH_1);
+    FLASH_OF_LIGHT                = m_ai->initSpell(FLASH_OF_LIGHT_1); // Holy
+    HOLY_LIGHT                    = m_ai->initSpell(HOLY_LIGHT_1);
+    HOLY_SHOCK                    = m_ai->initSpell(HOLY_SHOCK_1);
+    HOLY_WRATH                    = m_ai->initSpell(HOLY_WRATH_1);
+    DIVINE_FAVOR                  = m_ai->initSpell(DIVINE_FAVOR_1);
+    CONCENTRATION_AURA            = m_ai->initSpell(CONCENTRATION_AURA_1);
+    BLESSING_OF_WISDOM            = m_ai->initSpell(BLESSING_OF_WISDOM_1);
+    GREATER_BLESSING_OF_WISDOM    = m_ai->initSpell(GREATER_BLESSING_OF_WISDOM_1);
+    CONSECRATION                  = m_ai->initSpell(CONSECRATION_1);
+    LAY_ON_HANDS                  = m_ai->initSpell(LAY_ON_HANDS_1);
+    EXORCISM                      = m_ai->initSpell(EXORCISM_1);
+    BLESSING_OF_KINGS             = m_ai->initSpell(BLESSING_OF_KINGS_1);
+    GREATER_BLESSING_OF_KINGS     = m_ai->initSpell(GREATER_BLESSING_OF_KINGS_1);
+    BLESSING_OF_SANCTUARY         = m_ai->initSpell(BLESSING_OF_SANCTUARY_1);
+    GREATER_BLESSING_OF_SANCTUARY = m_ai->initSpell(GREATER_BLESSING_OF_SANCTUARY_1);
+    HAMMER_OF_JUSTICE             = m_ai->initSpell(HAMMER_OF_JUSTICE_1);
+    RIGHTEOUS_FURY                = m_ai->initSpell(RIGHTEOUS_FURY_1);
+    SHADOW_RESISTANCE_AURA        = m_ai->initSpell(SHADOW_RESISTANCE_AURA_1);
+    DEVOTION_AURA                 = m_ai->initSpell(DEVOTION_AURA_1);
+    FIRE_RESISTANCE_AURA          = m_ai->initSpell(FIRE_RESISTANCE_AURA_1);
+    FROST_RESISTANCE_AURA         = m_ai->initSpell(FROST_RESISTANCE_AURA_1);
+    BLESSING_OF_PROTECTION        = m_ai->initSpell(BLESSING_OF_PROTECTION_1);
+    DIVINE_PROTECTION             = m_ai->initSpell(DIVINE_PROTECTION_1);
+    DIVINE_INTERVENTION           = m_ai->initSpell(DIVINE_INTERVENTION_1);
+    DIVINE_SHIELD                 = m_ai->initSpell(DIVINE_SHIELD_1);
+    HOLY_SHIELD                   = m_ai->initSpell(HOLY_SHIELD_1);
+    BLESSING_OF_SACRIFICE         = m_ai->initSpell(BLESSING_OF_SACRIFICE_1);
+    REDEMPTION                    = m_ai->initSpell(REDEMPTION_1);
+    PURIFY                        = m_ai->initSpell(PURIFY_1);
+    CLEANSE                       = m_ai->initSpell(CLEANSE_1);
+
+    FORBEARANCE                   = 25771; // cannot be protected
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
+    PERCEPTION                    = m_ai->initSpell(PERCEPTION_ALL); // human
+
+    //The check doesn't work for now
+    //PRAYER_OF_SHADOW_PROTECTION   = m_ai->initSpell(PriestSpells::PRAYER_OF_SHADOW_PROTECTION_1);
+}
+
+PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
+            {
+                if (m_bot->CanReachWithMeleeAttack(pTarget))
+                {
+                    // Set everyone's UpdateAI() waiting to 2 seconds
+                    m_ai->SetGroupIgnoreUpdateTime(2);
+                    // Clear their TEMP_WAIT_TANKAGGRO flag
+                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+                    // Start attacking, force target on current target
+                    m_ai->Attack(m_ai->GetCurrentTarget());
+
+                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
+                }
+                else
+                {
+                    // TODO: add check if target is ranged
+                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
+                }
+            }
+            else if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
+               return HealPlayer(GetHealTarget());
+            else
+                return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    // Check if bot needs to cast seal on self
+    m_CurrentSeal      = 0;
+    m_CurrentJudgement = 0;
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+    if (!pTarget) return RETURN_NO_ACTION_INVALIDTARGET;
+
+    // damage spells
+    uint32 spec = m_bot->GetSpec();
+    std::ostringstream out;
+
+    // Make sure healer stays put, don't even melee (aggro) if in range.
+    if (m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    else if (!m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    // Emergency check: bot is about to die: use Divine Shield (first)
+    // Use Divine Protection if Divine Shield is not available and bot is not tanking because of the pacify effect
+    // TODO adjust treshold (may be too low)
+    if (m_ai->GetHealthPercent() < 8)
+    {
+        if (DIVINE_SHIELD > 0 && !m_bot->HasSpellCooldown(DIVINE_SHIELD) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_SHIELD, *m_bot))
+            return RETURN_CONTINUE;
+
+        if (DIVINE_PROTECTION > 0 && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) && !m_bot->HasSpellCooldown(DIVINE_PROTECTION) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_PROTECTION, *m_bot))
+            return RETURN_CONTINUE;
+    }
+
+    // Check if bot needs to cast a seal on self or judge the target
+    if (CheckSealAndJudgement(pTarget))
+        return RETURN_CONTINUE;
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
+            return RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
+            return RETURN_CONTINUE;
+    }
+
+    //Used to determine if this bot has highest threat
+    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)) // TODO: && party has a tank
+    {
+        if (HealPlayer(m_bot) == RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+
+        // Aggroed by an elite
+        if (m_ai->IsElite(newTarget))
+        {
+            // Try to stun the mob
+            if (HAMMER_OF_JUSTICE > 0 && m_ai->In_Reach(newTarget, HAMMER_OF_JUSTICE) && !m_bot->HasSpellCooldown(HAMMER_OF_JUSTICE) && !newTarget->HasAura(HAMMER_OF_JUSTICE) && m_ai->CastSpell(HAMMER_OF_JUSTICE, *newTarget))
+                return RETURN_CONTINUE;
+
+            // Bot has low life: use divine powers to protect him/herself
+            if (m_ai->GetHealthPercent() < 15)
+            {
+                if (DIVINE_SHIELD > 0 && !m_bot->HasSpellCooldown(DIVINE_SHIELD) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_SHIELD, *m_bot))
+                    return RETURN_CONTINUE;
+
+                if (DIVINE_PROTECTION > 0 && !m_bot->HasSpellCooldown(DIVINE_PROTECTION) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_PROTECTION, *m_bot))
+                    return RETURN_CONTINUE;
+            }
+
+            // Else: do nothing and pray for tank to pick aggro from mob
+            return RETURN_NO_ACTION_OK;
+        }
+    }
+
+    // Damage rotation
+    switch (spec)
+    {
+        case PALADIN_SPEC_HOLY:
+            if (m_ai->IsHealer())
+                return RETURN_NO_ACTION_OK;
+            // else: DPS (retribution, NEVER protection)
+
+        case PALADIN_SPEC_RETRIBUTION:
+            if (HAMMER_OF_WRATH > 0 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && m_ai->CastSpell (HAMMER_OF_WRATH, *pTarget))
+                return RETURN_CONTINUE;
+                return RETURN_CONTINUE;
+            /*if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE, EFFECT_INDEX_0) && m_ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget))
+                return RETURN_CONTINUE;*/
+            /*if (HOLY_WRATH > 0 && m_ai->GetAttackerCount() >= 3 && meleeReach && m_ai->CastSpell (HOLY_WRATH, *pTarget))
+                return RETURN_CONTINUE;*/
+            /*if (BLESSING_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(BLESSING_OF_SACRIFICE, EFFECT_INDEX_0) && m_ai->CastSpell (BLESSING_OF_SACRIFICE, *GetMaster()))
+                return RETURN_CONTINUE;*/
+            /*if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && m_ai->CastSpell (DIVINE_FAVOR, *m_bot))
+                return RETURN_CONTINUE;*/
+            return RETURN_NO_ACTION_OK;
+
+        case PALADIN_SPEC_PROTECTION:
+            //Taunt if orders specify
+            if (CONSECRATION > 0 && !m_bot->HasSpellCooldown(CONSECRATION) && m_ai->CastSpell(CONSECRATION, *pTarget))
+                return RETURN_CONTINUE;
+            if (HOLY_SHIELD > 0 && !m_bot->HasAura(HOLY_SHIELD) && m_ai->CastSpell(HOLY_SHIELD, *m_bot))
+                return RETURN_CONTINUE;
+            if (SHIELD_OF_RIGHTEOUSNESS > 0 && !m_bot->HasSpellCooldown(SHIELD_OF_RIGHTEOUSNESS) && m_ai->CastSpell(SHIELD_OF_RIGHTEOUSNESS, *pTarget))
+                return RETURN_CONTINUE;
+            return RETURN_NO_ACTION_OK;
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (m_ai->CastSpell(HAMMER_OF_JUSTICE))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+CombatManeuverReturns PlayerbotPaladinAI::HealPlayer(Player* target)
+{
+    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
+    if (r != RETURN_NO_ACTION_OK)
+        return r;
+
+    if (!target->isAlive())
+    {
+        if (REDEMPTION && m_ai->CastSpell(REDEMPTION, *target))
+        {
+            std::string msg = "Resurrecting ";
+            msg += target->GetName();
+            m_bot->Say(msg, LANG_UNIVERSAL);
+            return RETURN_CONTINUE;
+        }
+        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
+    }
+
+    if (PURIFY > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0)
+    {
+        uint32 DISPEL = CLEANSE > 0 ? CLEANSE : PURIFY;
+        uint32 dispelMask  = GetDispellMask(DISPEL_DISEASE);
+        uint32 dispelMask2 = GetDispellMask(DISPEL_POISON);
+        uint32 dispelMask3 = GetDispellMask(DISPEL_MAGIC);
+        Unit::SpellAuraHolderMap const& auras = target->GetSpellAuraHolderMap();
+        for(Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            SpellAuraHolder *holder = itr->second;
+            if ((1 << holder->GetSpellProto()->Dispel) & dispelMask)
+            {
+                if (holder->GetSpellProto()->Dispel == DISPEL_DISEASE)
+                {
+                    if (m_ai->CastSpell(DISPEL, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+            else if ((1 << holder->GetSpellProto()->Dispel) & dispelMask2)
+            {
+                if (holder->GetSpellProto()->Dispel == DISPEL_POISON)
+                {
+                    if (m_ai->CastSpell(DISPEL, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+            else if ((1 << holder->GetSpellProto()->Dispel) & dispelMask3 & (DISPEL == CLEANSE))
+            {
+                if (holder->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                {
+                    if (m_ai->CastSpell(DISPEL, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+        }
+    }
+
+    // Define a tank bot will look at
+    Unit* pMainTank = GetHealTarget(JOB_TANK);
+
+    // If target is out of range (40 yards) and is a tank: move towards it
+    // Other classes have to adjust their position to the healers
+    // TODO: This code should be common to all healers and will probably
+    // move to a more suitable place
+    if (pMainTank && !m_ai->In_Reach(pMainTank, FLASH_OF_LIGHT))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
+        return RETURN_CONTINUE;
+    }
+
+    uint8 hp = target->GetHealthPercent();
+
+    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
+    if (hp >= 90)
+        return RETURN_NO_ACTION_OK;
+
+    if (hp < 10 && LAY_ON_HANDS && !m_bot->HasSpellCooldown(LAY_ON_HANDS) && m_ai->In_Reach(target,LAY_ON_HANDS) && m_ai->CastSpell(LAY_ON_HANDS, *target))
+        return RETURN_CONTINUE;
+
+    // Target is a moderately wounded healer or a badly wounded not tank? Blessing of Protection!
+    if (BLESSING_OF_PROTECTION > 0
+        && ((hp < 25 && (GetTargetJob(target) & JOB_HEAL)) || (hp < 15 && !(GetTargetJob(target) & JOB_TANK)))
+        && !m_bot->HasSpellCooldown(BLESSING_OF_PROTECTION) && m_ai->In_Reach(target,BLESSING_OF_PROTECTION)
+        && !target->HasAura(FORBEARANCE, EFFECT_INDEX_0)
+        && !target->HasAura(BLESSING_OF_PROTECTION, EFFECT_INDEX_0) && !target->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0)
+        && !target->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0)
+        && m_ai->CastSpell(BLESSING_OF_PROTECTION, *target))
+        return RETURN_CONTINUE;
+
+    // Low HP : activate Divine Favor to make next heal a critical heal
+    if (hp < 25 && DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && !m_bot->HasSpellCooldown(DIVINE_FAVOR) && m_ai->CastSpell (DIVINE_FAVOR, *m_bot))
+        return RETURN_CONTINUE;
+
+    if (hp < 40 && FLASH_OF_LIGHT && m_ai->In_Reach(target,FLASH_OF_LIGHT) && m_ai->CastSpell(FLASH_OF_LIGHT, *target))
+        return RETURN_CONTINUE;
+
+    if (hp < 60 && HOLY_SHOCK && m_ai->In_Reach(target,HOLY_SHOCK) && m_ai->CastSpell(HOLY_SHOCK, *target))
+        return RETURN_CONTINUE;
+
+    if (hp < 90 && HOLY_LIGHT && m_ai->In_Reach(target,HOLY_LIGHT) && m_ai->CastSpell(HOLY_LIGHT, *target))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+} // end HealTarget
+
+void PlayerbotPaladinAI::CheckAuras()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    // If we have resist orders, adjust accordingly
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FROST)
+    {
+        if (!m_bot->HasAura(FROST_RESISTANCE_AURA) && FROST_RESISTANCE_AURA > 0 && !m_bot->HasAura(FROST_RESISTANCE_AURA))
+            m_ai->CastSpell(FROST_RESISTANCE_AURA);
+        return;
+    }
+    else if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FIRE)
+    {
+        if (!m_bot->HasAura(FIRE_RESISTANCE_AURA) && FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA))
+            m_ai->CastSpell(FIRE_RESISTANCE_AURA);
+        return;
+    }
+    else if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW)
+    {
+        // Shadow protection check is broken, they stack!
+        if (!m_bot->HasAura(SHADOW_RESISTANCE_AURA) && SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA)) // /*&& !m_bot->HasAura(PRAYER_OF_SHADOW_PROTECTION)*/ /*&& !m_bot->HasAura(PRAYER_OF_SHADOW_PROTECTION)*/
+            m_ai->CastSpell(SHADOW_RESISTANCE_AURA);
+        return;
+    }
+
+    // if there is a tank in the group, use concentration aura
+    bool tankInGroup = false;
+    if (m_bot->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *groupMember = sObjectMgr.GetPlayer(itr->guid);
+            if (!groupMember)
+                continue;
+
+            if (GetTargetJob(groupMember) & JOB_TANK)
+            {
+                tankInGroup = true;
+                break;
+            }
+        }
+    }
+
+    // If we have no resist orders, adjust aura based on spec or tank
+    if (spec == PALADIN_SPEC_PROTECTION || tankInGroup)
+    {
+        if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA))
+            m_ai->CastSpell(DEVOTION_AURA);
+        return;
+    }
+    else if (spec == PALADIN_SPEC_HOLY)
+    {
+        if (CONCENTRATION_AURA > 0 && !m_bot->HasAura(CONCENTRATION_AURA))
+            m_ai->CastSpell(CONCENTRATION_AURA);
+        return;
+    }
+    else if (spec == PALADIN_SPEC_RETRIBUTION)
+    {
+        if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA))
+            m_ai->CastSpell(RETRIBUTION_AURA);
+        return;
+    }
+}
+
+// Check if the paladin bot needs to cast/refresh a seal on him/herself
+// also check if the paladin bot needs to judge its target and first buff
+// him/herself with the relevant seal
+// TODO: handle other paladins in group/raid, for example to cast Seal/Judgement of Light
+bool PlayerbotPaladinAI::CheckSealAndJudgement(Unit* pTarget)
+{
+    if (!m_ai)      return false;
+    if (!m_bot)     return false;
+    if (!pTarget)   return false;
+
+    Creature * pCreature = (Creature*) pTarget;
+
+    // Prevent low health humanoid from fleeing by judging them with Seal of Justice
+    if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
+    {
+        if (SEAL_OF_JUSTICE > 0 && !m_bot->HasAura(SEAL_OF_JUSTICE, EFFECT_INDEX_0) && m_ai->CastSpell(SEAL_OF_JUSTICE, *m_bot))
+        {
+            m_CurrentSeal = SEAL_OF_JUSTICE;
+            m_CurrentJudgement = 0;
+            return true;
+        }
+    }
+
+    // Bot already defined a seal and a judgement and each is active on bot and target: don't waste time to go further
+    if (m_CurrentSeal > 0 && m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_CurrentJudgement > 0 && pTarget->HasAura(m_CurrentJudgement, EFFECT_INDEX_0))
+        return false;
+
+    // Refresh judgement if needed by forcing paladin bot to cast seal and judgement anew
+    // But first, unleash current seal if bot can do extra damage to the target in the process
+    if (m_CurrentJudgement > 0 && !pTarget->HasAura(m_CurrentJudgement, EFFECT_INDEX_0))
+    {
+        if (m_bot->HasAura(SEAL_OF_COMMAND, EFFECT_INDEX_0) || m_bot->HasAura(SEAL_OF_RIGHTEOUSNESS, EFFECT_INDEX_0))
+            if (JUDGEMENT > 0 && !m_bot->HasSpellCooldown(JUDGEMENT) && m_ai->In_Reach(pTarget, JUDGEMENT))
+                m_ai->CastSpell(JUDGEMENT, *pTarget);
+
+        m_CurrentJudgement = 0;
+        m_CurrentSeal = 0;
+        return false;
+    }
+
+    // Judgement is still active on target: refresh seal on bot if needed
+    if (m_CurrentJudgement > 0 && m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0))
+        if (m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_ai->CastSpell(m_CurrentSeal, *m_bot))
+            return true;
+
+    // No judgement on target but bot has seal active: time to judge the target
+    if (m_CurrentJudgement == 0 && m_CurrentSeal > 0 && m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0))
+    {
+        if (JUDGEMENT > 0 && !m_bot->HasSpellCooldown(JUDGEMENT) && m_ai->In_Reach(pTarget, JUDGEMENT) && m_ai->CastSpell(JUDGEMENT, *pTarget))
+        {
+            if (m_CurrentSeal == SEAL_OF_JUSTICE)
+                m_CurrentJudgement = JUDGEMENT_OF_JUSTICE;
+            else if (m_CurrentSeal == SEAL_OF_WISDOM)
+                m_CurrentJudgement = JUDGEMENT_OF_WISDOM;
+            else if (m_CurrentSeal == SEAL_OF_THE_CRUSADER)
+                m_CurrentJudgement = JUDGEMENT_OF_THE_CRUSADER;
+            else
+                return false;
+
+            // Set current seal to 0 to force the bot to seal him/herself for combat now that the target is judged
+            m_CurrentSeal = 0;
+            return true;
+        }
+
+        return false;
+    }
+
+    // Now bot casts seal on him/herself
+    // No judgement on target: look for best seal to judge target next
+    // Target already judged: bot will buff him/herself for combat according to spec/orders
+    uint32 spec = m_bot->GetSpec();
+
+    // Bypass spec if combat orders were given
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) spec = PALADIN_SPEC_HOLY;
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) spec = PALADIN_SPEC_PROTECTION;
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST) spec = PALADIN_SPEC_RETRIBUTION;
+
+    if (m_CurrentJudgement == 0)
+    {
+        if (spec == PALADIN_SPEC_HOLY || m_ai->IsHealer())
+            m_CurrentSeal = SEAL_OF_WISDOM;
+        else
+            m_CurrentSeal = SEAL_OF_THE_CRUSADER;
+    }
+    else
+    {
+        if (spec == PALADIN_SPEC_HOLY)
+            m_CurrentSeal = SEAL_OF_WISDOM;
+        else if (spec == PALADIN_SPEC_PROTECTION)
+            m_CurrentSeal = SEAL_OF_RIGHTEOUSNESS;
+        else if (spec == PALADIN_SPEC_RETRIBUTION && SEAL_OF_COMMAND > 0)
+            m_CurrentSeal = SEAL_OF_COMMAND;
+        // no spec: try Seal of Righteouness
+        else
+            m_CurrentSeal = SEAL_OF_RIGHTEOUSNESS;
+    }
+
+    if (m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_ai->CastSpell(m_CurrentSeal, *m_bot))
+        return true;
+
+    return false;
+}
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    if (!m_ai)   return;
+    if (!m_bot)  return;
+
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
+
+    CheckAuras();
+
+    //Put up RF if tank
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)
+        m_ai->SelfBuff(RIGHTEOUS_FURY);
+    //Disable RF if not tank
+    else if (m_bot->HasAura(RIGHTEOUS_FURY))
+        m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+
+    // Revive
+    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
+        return;
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+
+    // buff group
+    if (Buff(&PlayerbotPaladinAI::BuffHelper, 1) & RETURN_CONTINUE) // Paladin's BuffHelper takes care of choosing the specific Blessing so just pass along a non-zero value
+        return;
+
+    // hp/mana check
+    if (EatDrinkBandage())
+        return;
+    // m_ai->TellMaster("DoNonCombatActions() - 10. past EatDrinkBandage()"); // debug
+}
+
+/**
+ * BuffHelper
+ * BuffHelper is a static function, takes an AI, spellId (ignored for paladin) and a target and attempts to buff them as well as their pets as
+ * best as possible.
+ *
+ * Return bool - returns true if a buff took place.
+ */
+bool PlayerbotPaladinAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target)
+{
+    if (!ai)          return false;
+    if (spellId == 0) return false;
+    if (!target)      return false;
+
+    PlayerbotPaladinAI* c = (PlayerbotPaladinAI*) ai->GetClassAI();
+    uint32 bigSpellId = 0;
+
+    Pet* pet = target->GetPet();
+    uint32 petSpellId = 0, petBigSpellId = 0;
+
+    // See which buff is appropriate according to class
+    // TODO: take into account other paladins in the group
+    switch (target->getClass())
+    {
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            spellId = c->BLESSING_OF_MIGHT;
+            if (!spellId)
+            {
+                spellId = c->BLESSING_OF_KINGS;
+                if (!spellId)
+                {
+                    spellId = c->BLESSING_OF_WISDOM;
+                    if (!spellId)
+                    {
+                        spellId = c->BLESSING_OF_SANCTUARY;
+                        if (!spellId)
+                            return false;
+                    }
+                }
+            }
+            break;
+        case CLASS_HUNTER:
+            if (pet && ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet) && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+            {
+                petSpellId = c->BLESSING_OF_MIGHT;
+                if (!petSpellId)
+                {
+                    petSpellId = c->BLESSING_OF_KINGS;
+                    if (!petSpellId)
+                        petSpellId = c->BLESSING_OF_SANCTUARY;
+                }
+            }
+        case CLASS_ROGUE:
+        case CLASS_WARRIOR:
+            spellId = c->BLESSING_OF_MIGHT;
+            if (!spellId)
+            {
+                spellId = c->BLESSING_OF_KINGS;
+                if (!spellId)
+                {
+                    spellId = c->BLESSING_OF_SANCTUARY;
+                    if (!spellId)
+                        return false;
+                }
+            }
+            break;
+        case CLASS_WARLOCK:
+            if (pet && ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet) && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+            {
+                if (pet->GetPowerType() == POWER_MANA)
+                    petSpellId = c->BLESSING_OF_WISDOM;
+                else
+                    petSpellId = c->BLESSING_OF_MIGHT;
+
+                if (!petSpellId)
+                {
+                    petSpellId = c->BLESSING_OF_KINGS;
+                    if (!petSpellId)
+                        petSpellId = c->BLESSING_OF_SANCTUARY;
+                }
+            }
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+            spellId = c->BLESSING_OF_WISDOM;
+            if (!spellId)
+            {
+                spellId = c->BLESSING_OF_KINGS;
+                if (!spellId)
+                {
+                    spellId = c->BLESSING_OF_SANCTUARY;
+                    if (!spellId)
+                        return false;
+                }
+            }
+            break;
+    }
+
+    if (petSpellId == c->BLESSING_OF_MIGHT)
+        petBigSpellId = c->GREATER_BLESSING_OF_MIGHT;
+    else if (petSpellId == c->BLESSING_OF_WISDOM)
+        petBigSpellId = c->GREATER_BLESSING_OF_WISDOM;
+    else if (petSpellId == c->BLESSING_OF_KINGS)
+        petBigSpellId = c->GREATER_BLESSING_OF_KINGS;
+    else if (petSpellId == c->BLESSING_OF_SANCTUARY)
+        petBigSpellId = c->GREATER_BLESSING_OF_SANCTUARY;
+
+    if (spellId == c->BLESSING_OF_MIGHT)
+        bigSpellId = c->GREATER_BLESSING_OF_MIGHT;
+    else if (spellId == c->BLESSING_OF_WISDOM)
+        bigSpellId = c->GREATER_BLESSING_OF_WISDOM;
+    else if (spellId == c->BLESSING_OF_KINGS)
+        bigSpellId = c->GREATER_BLESSING_OF_KINGS;
+    else if (spellId == c->BLESSING_OF_SANCTUARY)
+        bigSpellId = c->GREATER_BLESSING_OF_SANCTUARY;
+
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->HasSpellReagents(petBigSpellId) && ai->Buff(petBigSpellId, pet))
+        return true;
+    if (ai->HasSpellReagents(bigSpellId) && ai->Buff(bigSpellId, target))
+        return true;
+    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(petSpellId, pet)) || ai->Buff(spellId, target))
+        return true;
+    return false;
+}
+
+// Match up with "Pull()" below
+bool PlayerbotPaladinAI::CanPull()
+{
+    if (HAND_OF_RECKONING && !m_bot->HasSpellCooldown(HAND_OF_RECKONING))
+        return true;
+    if (EXORCISM && !m_bot->HasSpellCooldown(EXORCISM))
+        return true;
+
+    return false;
+}
+
+// Match up with "CanPull()" above
+bool PlayerbotPaladinAI::Pull()
+{
+    if (EXORCISM && m_ai->CastSpell(EXORCISM))
+        return true;
+
+    return false;
+}
+
+bool PlayerbotPaladinAI::CastHoTOnTank()
+{
+    if (!m_ai) return false;
+
+    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
+
+    // Paladin: Sheath of Light (with talents), Flash of Light (with Infusion of Light talent and only on a target with the Sacred Shield buff),
+    //          Holy Shock (with Tier 8 set bonus)
+    // None of these are HoTs to cast before pulling (I think)
+
+    return false;
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotPaladinAI.h portalclassic/src/game/playerbot/PlayerbotPaladinAI.h
--- mangos-classic/src/game/playerbot/PlayerbotPaladinAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotPaladinAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,182 @@
+#ifndef _PlayerbotPaladinAI_H
+#define _PlayerbotPaladinAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    Combat,
+    Healing
+};
+
+enum PaladinSpells
+{
+    BLESSING_OF_KINGS_1             = 20217,
+    BLESSING_OF_MIGHT_1             = 19740,
+    BLESSING_OF_SANCTUARY_1         = 20911,
+    BLESSING_OF_WISDOM_1            = 19742,
+    CLEANSE_1                       = 4987,
+    CONCENTRATION_AURA_1            = 19746,
+    CONSECRATION_1                  = 26573,
+    DEVOTION_AURA_1                 = 465,
+    DIVINE_FAVOR_1                  = 20216,
+    DIVINE_INTERVENTION_1           = 19752,
+    DIVINE_PROTECTION_1             = 498,
+    DIVINE_SHIELD_1                 = 642,
+    EXORCISM_1                      = 879,
+    FIRE_RESISTANCE_AURA_1          = 19891,
+    FLASH_OF_LIGHT_1                = 19750,
+    FROST_RESISTANCE_AURA_1         = 19888,
+    GREATER_BLESSING_OF_KINGS_1     = 25898,
+    GREATER_BLESSING_OF_MIGHT_1     = 25782,
+    GREATER_BLESSING_OF_SANCTUARY_1 = 25899,
+    GREATER_BLESSING_OF_WISDOM_1    = 25894,
+    HAMMER_OF_JUSTICE_1             = 853,
+    HAMMER_OF_WRATH_1               = 24275,
+    HAND_OF_FREEDOM_1               = 1044,
+    BLESSING_OF_PROTECTION_1        = 1022,
+    BLESSING_OF_SACRIFICE_1         = 6940,
+    HAND_OF_SALVATION_1             = 1038,
+    HOLY_LIGHT_1                    = 635,
+    HOLY_SHIELD_1                   = 20925,
+    HOLY_SHOCK_1                    = 20473,
+    HOLY_WRATH_1                    = 2812,
+    JUDGEMENT_1                     = 20271,
+    LAY_ON_HANDS_1                  = 633,
+    PURIFY_1                        = 1152,
+    REDEMPTION_1                    = 7328,
+    REPENTANCE_1                    = 20066,
+    RETRIBUTION_AURA_1              = 7294,
+    RIGHTEOUS_FURY_1                = 25780,
+    SEAL_OF_COMMAND_1               = 20375,
+    SEAL_OF_JUSTICE_1               = 20164,
+    SEAL_OF_LIGHT_1                 = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1         = 21084,
+    SEAL_OF_WISDOM_1                = 20166,
+    SEAL_OF_THE_CRUSADER_1          = 21082,
+    SENSE_UNDEAD_1                  = 5502,
+    SHADOW_RESISTANCE_AURA_1        = 19876,
+    TURN_EVIL_1                     = 10326,
+
+    // Judgement auras on target
+    JUDGEMENT_OF_WISDOM             = 20355, // rank 2: 20354, rank 1: 20186
+    JUDGEMENT_OF_JUSTICE            = 20184,
+    JUDGEMENT_OF_THE_CRUSADER       = 20303  // rank 5: 20302, rank 4: 20301, rank 3: 20300, rank 2: 20188, rank 1: 21183
+};
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotPaladinAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPaladinAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPaladinAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    bool Pull();
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // Utility Functions
+    bool CanPull();
+    bool CastHoTOnTank();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    // Heals the target based off its hps
+    CombatManeuverReturns HealPlayer(Player* target);
+
+    //Changes aura according to spec/orders
+    void CheckAuras();
+    //Changes Seal according to spec
+    bool CheckSealAndJudgement(Unit* target);
+    uint32 m_CurrentSeal;
+    uint32 m_CurrentJudgement;
+
+    static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target);
+
+    // make this public so the static function can access it. Either that or make an accessor function for each
+public:
+    // Retribution
+    uint32 RETRIBUTION_AURA,
+           SEAL_OF_COMMAND,
+           GREATER_BLESSING_OF_WISDOM,
+           GREATER_BLESSING_OF_MIGHT,
+           BLESSING_OF_WISDOM,
+           BLESSING_OF_MIGHT,
+           HAMMER_OF_JUSTICE,
+           RIGHTEOUS_FURY,
+           JUDGEMENT;
+
+    // Holy
+    uint32 FLASH_OF_LIGHT,
+           HOLY_LIGHT,
+           DIVINE_SHIELD,
+           HAMMER_OF_WRATH,
+           CONSECRATION,
+           CONCENTRATION_AURA,
+           DIVINE_FAVOR,
+           HOLY_SHOCK,
+           HOLY_WRATH,
+           LAY_ON_HANDS,
+           EXORCISM,
+           REDEMPTION,
+           SEAL_OF_JUSTICE,
+           SEAL_OF_LIGHT,
+           SEAL_OF_RIGHTEOUSNESS,
+           SEAL_OF_WISDOM,
+           SEAL_OF_THE_CRUSADER,
+           PURIFY,
+           CLEANSE;
+
+    // Protection
+    uint32 GREATER_BLESSING_OF_KINGS,
+           BLESSING_OF_KINGS,
+           BLESSING_OF_PROTECTION,
+           SHADOW_RESISTANCE_AURA,
+           DEVOTION_AURA,
+           FIRE_RESISTANCE_AURA,
+           FROST_RESISTANCE_AURA,
+           DEFENSIVE_STANCE,
+           BERSERKER_STANCE,
+           BATTLE_STANCE,
+           DIVINE_SACRIFICE,
+           DIVINE_PROTECTION,
+           DIVINE_INTERVENTION,
+           HOLY_SHIELD,
+           AVENGERS_SHIELD,
+           RIGHTEOUS_DEFENSE,
+           BLESSING_OF_SANCTUARY,
+           GREATER_BLESSING_OF_SANCTUARY,
+           BLESSING_OF_SACRIFICE,
+           SHIELD_OF_RIGHTEOUSNESS,
+           HAND_OF_RECKONING,
+           HAMMER_OF_THE_RIGHTEOUS;
+
+    // cannot be protected
+    uint32 FORBEARANCE;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           PERCEPTION,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    //Non-Stacking buffs
+    uint32 PRAYER_OF_SHADOW_PROTECTION;
+
+private:
+    uint32 SpellSequence, CombatCounter, HealCounter;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotPriestAI.cpp portalclassic/src/game/playerbot/PlayerbotPriestAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotPriestAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotPriestAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,562 @@
+#include "PlayerbotPriestAI.h"
+#include "../SpellAuras.h"
+
+class PlayerbotAI;
+
+PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RENEW                         = m_ai->initSpell(RENEW_1);
+    LESSER_HEAL                   = m_ai->initSpell(LESSER_HEAL_1);
+    FLASH_HEAL                    = m_ai->initSpell(FLASH_HEAL_1);
+    (FLASH_HEAL > 0) ? FLASH_HEAL : FLASH_HEAL = LESSER_HEAL;
+    HEAL                          = m_ai->initSpell(HEAL_1);
+    (HEAL > 0) ? HEAL : HEAL = FLASH_HEAL;
+    GREATER_HEAL                  = m_ai->initSpell(GREATER_HEAL_1);
+    (GREATER_HEAL > 0) ? GREATER_HEAL : GREATER_HEAL = HEAL;
+    RESURRECTION                  = m_ai->initSpell(RESURRECTION_1);
+    SMITE                         = m_ai->initSpell(SMITE_1);
+    MANA_BURN                     = m_ai->initSpell(MANA_BURN_1);
+    HOLY_NOVA                     = m_ai->initSpell(HOLY_NOVA_1);
+    HOLY_FIRE                     = m_ai->initSpell(HOLY_FIRE_1);
+    DESPERATE_PRAYER              = m_ai->initSpell(DESPERATE_PRAYER_1);
+    PRAYER_OF_HEALING             = m_ai->initSpell(PRAYER_OF_HEALING_1);
+    CURE_DISEASE                  = m_ai->initSpell(CURE_DISEASE_1);
+    SHACKLE_UNDEAD                = m_ai->initSpell(SHACKLE_UNDEAD_1);
+
+    // SHADOW
+    FADE                          = m_ai->initSpell(FADE_1);
+    SHADOW_WORD_PAIN              = m_ai->initSpell(SHADOW_WORD_PAIN_1);
+    MIND_BLAST                    = m_ai->initSpell(MIND_BLAST_1);
+    SCREAM                        = m_ai->initSpell(PSYCHIC_SCREAM_1);
+    MIND_FLAY                     = m_ai->initSpell(MIND_FLAY_1);
+    DEVOURING_PLAGUE              = m_ai->initSpell(DEVOURING_PLAGUE_1);
+    SHADOW_PROTECTION             = m_ai->initSpell(SHADOW_PROTECTION_1);
+    PRAYER_OF_SHADOW_PROTECTION   = m_ai->initSpell(PRAYER_OF_SHADOW_PROTECTION_1);
+    SHADOWFORM                    = m_ai->initSpell(SHADOWFORM_1);
+    VAMPIRIC_EMBRACE              = m_ai->initSpell(VAMPIRIC_EMBRACE_1);
+
+    // RANGED COMBAT
+    SHOOT                         = m_ai->initSpell(SHOOT_1);
+
+    // DISCIPLINE
+    INNER_FIRE                    = m_ai->initSpell(INNER_FIRE_1);
+    POWER_WORD_SHIELD             = m_ai->initSpell(POWER_WORD_SHIELD_1);
+    POWER_WORD_FORTITUDE          = m_ai->initSpell(POWER_WORD_FORTITUDE_1);
+    PRAYER_OF_FORTITUDE           = m_ai->initSpell(PRAYER_OF_FORTITUDE_1);
+    FEAR_WARD                     = m_ai->initSpell(FEAR_WARD_1);
+    DIVINE_SPIRIT                 = m_ai->initSpell(DIVINE_SPIRIT_1);
+    PRAYER_OF_SPIRIT              = m_ai->initSpell(PRAYER_OF_SPIRIT_1);
+    POWER_INFUSION                = m_ai->initSpell(POWER_INFUSION_1);
+    INNER_FOCUS                   = m_ai->initSpell(INNER_FOCUS_1);
+    PRIEST_DISPEL_MAGIC           = m_ai->initSpell(DISPEL_MAGIC_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
+    ELUNES_GRACE                  = m_ai->initSpell(ELUNES_GRACE_1); // night elf
+    PERCEPTION                    = m_ai->initSpell(PERCEPTION_ALL); // human
+    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
+    BERSERKING                    = m_ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN          = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotPriestAI::~PlayerbotPriestAI() {}
+
+CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
+               return HealPlayer(GetHealTarget());
+            else
+                return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    if (m_ai->IsHealer())
+    {
+        // Cast renew on tank
+        if (CastHoTOnTank())
+            return RETURN_FINISHED_FIRST_MOVES;
+    }
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+    uint32 spec = m_bot->GetSpec();
+
+    // Define a tank bot will look at
+    Unit* pMainTank = GetHealTarget(JOB_TANK);
+
+    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    // if in melee range OR can't shoot OR have no ranged (wand) equipped
+    else if(m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE
+            && (SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
+            && !m_ai->IsHealer())
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    // Dwarves priests will try to buff with Fear Ward
+    if (FEAR_WARD > 0 && !m_bot->HasSpellCooldown(FEAR_WARD))
+    {
+        // Buff tank first
+        if (pMainTank)
+        {
+            if (m_ai->In_Reach(pMainTank, FEAR_WARD) && !pMainTank->HasAura(FEAR_WARD, EFFECT_INDEX_0) && CastSpell(FEAR_WARD, pMainTank))
+                return RETURN_CONTINUE;
+        }
+        // Else try to buff master
+        else if (GetMaster())
+        {
+            if (m_ai->In_Reach(GetMaster(), FEAR_WARD) && !GetMaster()->HasAura(FEAR_WARD, EFFECT_INDEX_0) && CastSpell(FEAR_WARD, GetMaster()))
+                return RETURN_CONTINUE;
+        }
+    }
+
+    //Used to determine if this bot is highest on threat
+    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget) // TODO: && party has a tank
+    {
+        if (FADE > 0 && !m_bot->HasAura(FADE, EFFECT_INDEX_0) && !m_bot->HasSpellCooldown(FADE))
+        {
+            if (CastSpell(FADE, m_bot))
+            {
+                m_ai->TellMaster("I'm casting fade.");
+                return RETURN_CONTINUE;
+            }
+            else
+                m_ai->TellMaster("I have AGGRO.");
+        }
+
+        // Heal myself
+        // TODO: move to HealTarget code
+        if (m_ai->GetHealthPercent() < 35 && POWER_WORD_SHIELD > 0 && !m_bot->HasAura(POWER_WORD_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(WEAKNED_SOUL, EFFECT_INDEX_0))
+        {
+            if (CastSpell(POWER_WORD_SHIELD) & RETURN_CONTINUE)
+            {
+                m_ai->TellMaster("I'm casting PW:S on myself.");
+                return RETURN_CONTINUE;
+            }
+            else if (m_ai->IsHealer()) // Even if any other RETURN_ANY_OK - aside from RETURN_CONTINUE
+                m_ai->TellMaster("Your healer's about TO DIE. HELP ME.");
+        }
+        if (m_ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0 && m_ai->In_Reach(m_bot,DESPERATE_PRAYER) && CastSpell(DESPERATE_PRAYER, m_bot) & RETURN_CONTINUE)
+        {
+            m_ai->TellMaster("I'm casting desperate prayer.");
+            return RETURN_CONTINUE;
+        }
+        // Night Elves priest bot can also cast Elune's Grace to improve his/her dodge rating
+        if (ELUNES_GRACE && !m_bot->HasAura(ELUNES_GRACE, EFFECT_INDEX_0) && !m_bot->HasSpellCooldown(ELUNES_GRACE) && CastSpell(ELUNES_GRACE, m_bot))
+            return RETURN_CONTINUE;
+
+        // Already healed self or tank. If healer, do nothing else to anger mob.
+        if (m_ai->IsHealer())
+            return RETURN_NO_ACTION_OK; // In a sense, mission accomplished.
+
+        // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
+        if (newTarget->GetHealthPercent() > 25)
+        {
+            // If elite, do nothing and pray tank gets aggro off you
+            if (m_ai->IsElite(newTarget))
+                return RETURN_NO_ACTION_OK;
+
+            // Not an elite. You could insert PSYCHIC SCREAM here but in any PvE situation that's 90-95% likely
+            // to worsen the situation for the group. ... So please don't.
+            return CastSpell(SHOOT, pTarget);
+        }
+    }
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // ... Certainly could be very detrimental to a shadow priest
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+    }
+
+    // Do damage tweaking for healers here
+    if (m_ai->IsHealer())
+    {
+        // If target is elite and not handled by MT: do nothing
+        if (m_ai->IsElite(pTarget) && pMainTank && pMainTank->getVictim() != pTarget)
+            return RETURN_NO_ACTION_OK;
+
+        // Cast Shadow Word:Pain on current target and keep its up (if mana >= 40% or target HP < 15%)
+        if (SHADOW_WORD_PAIN > 0 && m_ai->In_Reach(pTarget,SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) &&
+        (pTarget->GetHealthPercent() < 15 || m_ai->GetManaPercent() >= 40) && CastSpell(SHADOW_WORD_PAIN, pTarget))
+            return RETURN_CONTINUE;
+        else // else shoot at it
+            return CastSpell(SHOOT, pTarget);
+    }
+
+    // Damage Spells
+
+    switch (spec)
+    {
+        case PRIEST_SPEC_HOLY:
+            if (HOLY_FIRE > 0 && m_ai->In_Reach(pTarget,HOLY_FIRE) && !pTarget->HasAura(HOLY_FIRE, EFFECT_INDEX_0) && CastSpell(HOLY_FIRE, pTarget))
+                return RETURN_CONTINUE;
+            if (SMITE > 0 && m_ai->In_Reach(pTarget,SMITE) && CastSpell(SMITE, pTarget))
+                return RETURN_CONTINUE;
+            //if (HOLY_NOVA > 0 && m_ai->In_Reach(pTarget,HOLY_NOVA) && meleeReach && m_ai->CastSpell(HOLY_NOVA))
+            //    return RETURN_CONTINUE;
+            break;
+
+        case PRIEST_SPEC_SHADOW:
+            if (DEVOURING_PLAGUE > 0 && m_ai->In_Reach(pTarget,DEVOURING_PLAGUE) && !pTarget->HasAura(DEVOURING_PLAGUE, EFFECT_INDEX_0) && CastSpell(DEVOURING_PLAGUE, pTarget))
+                return RETURN_CONTINUE;
+            if (SHADOW_WORD_PAIN > 0 && m_ai->In_Reach(pTarget,SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) && CastSpell(SHADOW_WORD_PAIN, pTarget))
+                return RETURN_CONTINUE;
+            if (MIND_BLAST > 0 && m_ai->In_Reach(pTarget,MIND_BLAST) && (!m_bot->HasSpellCooldown(MIND_BLAST)) && CastSpell(MIND_BLAST, pTarget))
+                return RETURN_CONTINUE;
+            if (MIND_FLAY > 0 && m_ai->In_Reach(pTarget,MIND_FLAY) && CastSpell(MIND_FLAY, pTarget))
+            {
+                m_ai->SetIgnoreUpdateTime(3);
+                return RETURN_CONTINUE;
+            }
+            if (SHADOWFORM == 0 && MIND_FLAY == 0 && SMITE > 0 && m_ai->In_Reach(pTarget,SMITE) && CastSpell(SMITE, pTarget)) // low levels
+                return RETURN_CONTINUE;
+            break;
+
+        case PRIEST_SPEC_DISCIPLINE:
+            if (POWER_INFUSION > 0 && m_ai->In_Reach(GetMaster(),POWER_INFUSION) && CastSpell(POWER_INFUSION, GetMaster())) // TODO: just master?
+                return RETURN_CONTINUE;
+            if (INNER_FOCUS > 0 && m_ai->In_Reach(m_bot,INNER_FOCUS) && !m_bot->HasAura(INNER_FOCUS, EFFECT_INDEX_0) && CastSpell(INNER_FOCUS, m_bot))
+                return RETURN_CONTINUE;
+            if (SMITE > 0 && m_ai->In_Reach(pTarget,SMITE) && CastSpell(SMITE, pTarget))
+                return RETURN_CONTINUE;
+            break;
+    }
+
+    // No spec due to low level OR no spell found yet
+    if (MIND_BLAST > 0 && m_ai->In_Reach(pTarget,MIND_BLAST) && (!m_bot->HasSpellCooldown(MIND_BLAST)) && CastSpell(MIND_BLAST, pTarget))
+        return RETURN_CONTINUE;
+    if (SHADOW_WORD_PAIN > 0 && m_ai->In_Reach(pTarget,SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) && CastSpell(SHADOW_WORD_PAIN, pTarget))
+        return RETURN_CONTINUE;
+    if (MIND_FLAY > 0 && m_ai->In_Reach(pTarget,MIND_FLAY) && CastSpell(MIND_FLAY, pTarget))
+    {
+        m_ai->SetIgnoreUpdateTime(3);
+        return RETURN_CONTINUE;
+    }
+    if (SHADOWFORM == 0 && SMITE > 0 && m_ai->In_Reach(pTarget,SMITE) && CastSpell(SMITE, pTarget))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_OK;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+            // TODO: spec tweaking
+            if (m_ai->HasAura(SCREAM, *pTarget) && m_ai->GetHealthPercent() < 60 && HEAL && m_ai->In_Reach(pTarget,HEAL) && CastSpell(HEAL) & RETURN_ANY_OK)
+                return RETURN_CONTINUE;
+
+            if (SHADOW_WORD_PAIN && m_ai->In_Reach(pTarget,SHADOW_WORD_PAIN) && CastSpell(SHADOW_WORD_PAIN) & RETURN_ANY_OK) // TODO: Check whether enemy has it active yet
+                return RETURN_CONTINUE;
+
+            if (m_ai->GetHealthPercent() < 80 && RENEW && m_ai->In_Reach(pTarget,RENEW) && CastSpell(RENEW) & RETURN_ANY_OK) // TODO: Check whether you have renew active on you
+                return RETURN_CONTINUE;
+
+            if (SCREAM && m_ai->In_Reach(pTarget,SCREAM) && CastSpell(SCREAM) & RETURN_ANY_OK) // TODO: Check for cooldown
+                return RETURN_CONTINUE;
+
+            if (MIND_BLAST && m_ai->In_Reach(pTarget,MIND_BLAST) && CastSpell(MIND_BLAST) & RETURN_ANY_OK) // TODO: Check for cooldown
+                return RETURN_CONTINUE;
+
+            if (m_ai->GetHealthPercent() < 50 && GREATER_HEAL && m_ai->In_Reach(pTarget,GREATER_HEAL) && CastSpell(GREATER_HEAL) & RETURN_ANY_OK)
+                return RETURN_CONTINUE;
+
+            if (SMITE && m_ai->In_Reach(pTarget,SMITE) && CastSpell(SMITE) & RETURN_ANY_OK)
+                return RETURN_CONTINUE;
+
+            m_ai->TellMaster("Couldn't find a spell to cast while dueling");
+        default:
+            break;
+    }
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+CombatManeuverReturns PlayerbotPriestAI::HealPlayer(Player* target)
+{
+    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
+    if (r != RETURN_NO_ACTION_OK)
+        return r;
+
+    if (!target->isAlive())
+    {
+        if (RESURRECTION && m_ai->In_Reach(target,RESURRECTION) && m_ai->CastSpell(RESURRECTION, *target))
+        {
+            std::string msg = "Resurrecting ";
+            msg += target->GetName();
+            m_bot->Say(msg, LANG_UNIVERSAL);
+            return RETURN_CONTINUE;
+        }
+        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
+    }
+
+    if ((CURE_DISEASE > 0 || PRIEST_DISPEL_MAGIC > 0) && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0)
+    {
+        uint32 dispelMask  = GetDispellMask(DISPEL_DISEASE);
+        uint32 dispelMask2 = GetDispellMask(DISPEL_MAGIC);
+        Unit::SpellAuraHolderMap const& auras = target->GetSpellAuraHolderMap();
+        for (Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            SpellAuraHolder *holder = itr->second;
+            if ((1 << holder->GetSpellProto()->Dispel) & dispelMask)
+            {
+                if ((holder->GetSpellProto()->Dispel == DISPEL_DISEASE) && CURE_DISEASE > 0)
+                {
+                    if (m_ai->CastSpell(CURE_DISEASE, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+            else if ((1 << holder->GetSpellProto()->Dispel) & dispelMask2)
+            {
+                // only remove negative effects
+                if ((holder->GetSpellProto()->Dispel == DISPEL_MAGIC) && !holder->IsPositive() && PRIEST_DISPEL_MAGIC > 0)
+                {
+                    if (m_ai->CastSpell(PRIEST_DISPEL_MAGIC, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+        }
+    }
+
+    uint8 hp = target->GetHealthPercent();
+    uint8 hpSelf = m_ai->GetHealthPercent();
+
+    // Define a tank bot will look at
+    Unit* pMainTank = GetHealTarget(JOB_TANK);
+
+    if (hp >= 90)
+        return RETURN_NO_ACTION_OK;
+
+    // If target is out of range (40 yards) and is a tank: move towards it
+    // Other classes have to adjust their position to the healers
+    // TODO: This code should be common to all healers and will probably
+    // move to a more suitable place
+    if (pMainTank && !m_ai->In_Reach(pMainTank, FLASH_HEAL))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
+        return RETURN_CONTINUE;
+    }
+
+    // Get a free and more efficient heal if needed: low mana for bot or average health for target
+    if (m_ai->IsInCombat() && (hp < 50 || m_ai->GetManaPercent() < 40))
+        if (INNER_FOCUS > 0 && !m_bot->HasSpellCooldown(INNER_FOCUS) && !m_bot->HasAura(INNER_FOCUS, EFFECT_INDEX_0) && CastSpell(INNER_FOCUS, m_bot))
+            return RETURN_CONTINUE;
+
+    if (hp < 25 && POWER_WORD_SHIELD > 0 && m_ai->In_Reach(target,POWER_WORD_SHIELD) && !m_bot->HasAura(POWER_WORD_SHIELD, EFFECT_INDEX_0) && !target->HasAura(WEAKNED_SOUL,EFFECT_INDEX_0) && m_ai->CastSpell(POWER_WORD_SHIELD, *target))
+        return RETURN_CONTINUE;
+    if (hp < 35 && FLASH_HEAL > 0 && m_ai->In_Reach(target,FLASH_HEAL) && m_ai->CastSpell(FLASH_HEAL, *target))
+        return RETURN_CONTINUE;
+    if (hp < 50 && GREATER_HEAL > 0 && m_ai->In_Reach(target,GREATER_HEAL) && m_ai->CastSpell(GREATER_HEAL, *target))
+        return RETURN_CONTINUE;
+    if (hp < 70 && HEAL > 0 && m_ai->In_Reach(target,HEAL) && m_ai->CastSpell(HEAL, *target))
+        return RETURN_CONTINUE;
+    if (hp < 90 && RENEW > 0 && m_ai->In_Reach(target,RENEW) && !target->HasAura(RENEW) && m_ai->CastSpell(RENEW, *target))
+        return RETURN_CONTINUE;
+
+    // Group heal. Not really useful until a group check is available?
+    //if (hp < 40 && PRAYER_OF_HEALING > 0 && m_ai->CastSpell(PRAYER_OF_HEALING, *target) & RETURN_CONTINUE)
+    //    return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_OK;
+} // end HealTarget
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    if (!m_ai)   return;
+    if (!m_bot)  return;
+
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    // selfbuff goes first
+    if (m_ai->SelfBuff(INNER_FIRE))
+        return;
+
+    // Revive
+    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
+        return;
+
+    // After revive
+    if (spec == PRIEST_SPEC_SHADOW && SHADOWFORM > 0)
+        m_ai->SelfBuff(SHADOWFORM);
+    if (VAMPIRIC_EMBRACE > 0)
+        m_ai->SelfBuff(VAMPIRIC_EMBRACE);
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+
+    // Buff
+    if (m_bot->GetGroup() && m_ai->HasSpellReagents(PRAYER_OF_FORTITUDE))
+    {
+        if (Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_FORTITUDE) & RETURN_CONTINUE)
+            return;
+        if (Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_SPIRIT) & RETURN_CONTINUE)
+            return;
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW && Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_SHADOW_PROTECTION) & RETURN_CONTINUE)
+            return;
+    }
+    else
+    {
+        if (Buff(&PlayerbotPriestAI::BuffHelper, POWER_WORD_FORTITUDE) & RETURN_CONTINUE)
+            return;
+        if (Buff(&PlayerbotPriestAI::BuffHelper, DIVINE_SPIRIT, (JOB_ALL | JOB_MANAONLY)) & RETURN_CONTINUE)
+            return;
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW && Buff(&PlayerbotPriestAI::BuffHelper, SHADOW_PROTECTION, (JOB_TANK | JOB_HEAL)) & RETURN_CONTINUE)
+            return;
+    }
+    if (EatDrinkBandage())
+        return;
+} // end DoNonCombatActions
+
+// TODO: this and mage's BuffHelper are identical and thus could probably go in PlayerbotClassAI.cpp somewhere
+bool PlayerbotPriestAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target)
+{
+    if (!ai)          return false;
+    if (spellId == 0) return false;
+    if (!target)      return false;
+
+    Pet * pet = target->GetPet();
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet))
+        return true;
+
+    if (ai->Buff(spellId, target))
+        return true;
+
+    return false;
+}
+
+bool PlayerbotPriestAI::CastHoTOnTank()
+{
+    if (!m_ai) return false;
+
+    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
+
+    // Priest HoTs: Renew, Penance (with talents, channeled)
+    if (RENEW && m_ai->In_Reach(m_ai->GetGroupTank(),RENEW))
+        return (RETURN_CONTINUE & CastSpell(RENEW, m_ai->GetGroupTank()));
+
+    return false;
+}
+
+// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
+uint32 PlayerbotPriestAI::Neutralize(uint8 creatureType)
+{
+    if (!m_bot)         return 0;
+    if (!m_ai)          return 0;
+    if (!creatureType)  return 0;
+
+    if (creatureType != CREATURE_TYPE_UNDEAD)
+    {
+        m_ai->TellMaster("I can't shackle that target.");
+        return 0;
+    }
+
+    if (SHACKLE_UNDEAD)
+        return SHACKLE_UNDEAD;
+    else
+        return 0;
+
+    return 0;
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotPriestAI.h portalclassic/src/game/playerbot/PlayerbotPriestAI.h
--- mangos-classic/src/game/playerbot/PlayerbotPriestAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotPriestAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,148 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HOLY,
+    SPELL_SHADOWMAGIC,
+    SPELL_DISCIPLINE
+};
+
+enum PriestSpells
+{
+    ABOLISH_DISEASE_1               = 552,
+    CURE_DISEASE_1                  = 528,
+    DESPERATE_PRAYER_1              = 19236,
+    DEVOURING_PLAGUE_1              = 2944,
+    DISPEL_MAGIC_1                  = 527,
+    DIVINE_SPIRIT_1                 = 14752,
+    ELUNES_GRACE_1                  = 2651,
+    FADE_1                          = 586,
+    FEAR_WARD_1                     = 6346,
+    FLASH_HEAL_1                    = 2061,
+    GREATER_HEAL_1                  = 2060,
+    HEAL_1                          = 2054,
+    HOLY_FIRE_1                     = 14914,
+    HOLY_NOVA_1                     = 15237,
+    INNER_FIRE_1                    = 588,
+    INNER_FOCUS_1                   = 14751,
+    LESSER_HEAL_1                   = 2050,
+    LEVITATE_1                      = 1706,
+    LIGHTWELL_1                     = 724,
+    MANA_BURN_1                     = 8129,
+    MIND_BLAST_1                    = 8092,
+    MIND_CONTROL_1                  = 605,
+    MIND_FLAY_1                     = 15407,
+    MIND_SOOTHE_1                   = 453,
+    MIND_VISION_1                   = 2096,
+    POWER_INFUSION_1                = 10060,
+    POWER_WORD_FORTITUDE_1          = 1243,
+    POWER_WORD_SHIELD_1             = 17,
+    PRAYER_OF_FORTITUDE_1           = 21562,
+    PRAYER_OF_HEALING_1             = 596,
+    PRAYER_OF_SHADOW_PROTECTION_1   = 27683,
+    PRAYER_OF_SPIRIT_1              = 27681,
+    PSYCHIC_SCREAM_1                = 8122,
+    RENEW_1                         = 139,
+    RESURRECTION_1                  = 2006,
+    SHACKLE_UNDEAD_1                = 9484,
+    SHADOW_PROTECTION_1             = 976,
+    SHADOW_WORD_PAIN_1              = 589,
+    SHADOWFORM_1                    = 15473,
+    SHOOT_1                         = 5019,
+    SILENCE_1                       = 15487,
+    SMITE_1                         = 585,
+    VAMPIRIC_EMBRACE_1              = 15286,
+    WEAKNED_SOUL                    = 6788
+};
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPriestAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    uint32 Neutralize(uint8 creatureType);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // Utility Functions
+    bool CastHoTOnTank();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    CombatManeuverReturns CastSpell(uint32 nextAction, Unit *pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
+
+    // Heals the target based off its hps
+    CombatManeuverReturns HealPlayer(Player* target);
+
+    static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit *target);
+
+    // holy
+    uint32 CLEARCASTING,
+           DESPERATE_PRAYER,
+           FLASH_HEAL,
+           GREATER_HEAL,
+           HEAL,
+           HOLY_FIRE,
+           HOLY_NOVA,
+           LESSER_HEAL,
+           MANA_BURN,
+           PRAYER_OF_HEALING,
+           RENEW,
+           RESURRECTION,
+           SHACKLE_UNDEAD,
+           SMITE,
+           CURE_DISEASE,
+           PRIEST_DISPEL_MAGIC;
+
+    // ranged
+    uint32 SHOOT;
+
+    // shadowmagic
+    uint32 FADE,
+           SHADOW_WORD_PAIN,
+           MIND_BLAST,
+           SCREAM,
+           MIND_FLAY,
+           DEVOURING_PLAGUE,
+           SHADOW_PROTECTION,
+           PRAYER_OF_SHADOW_PROTECTION,
+           SHADOWFORM,
+           VAMPIRIC_EMBRACE;
+
+    // discipline
+    uint32 POWER_WORD_SHIELD,
+           INNER_FIRE,
+           POWER_WORD_FORTITUDE,
+           PRAYER_OF_FORTITUDE,
+           FEAR_WARD,
+           POWER_INFUSION,
+           MASS_DISPEL,
+           DIVINE_SPIRIT,
+           PRAYER_OF_SPIRIT,
+           INNER_FOCUS;
+
+    // racial
+    uint32 STONEFORM,
+           ELUNES_GRACE,
+           ESCAPE_ARTIST,
+           PERCEPTION,
+           SHADOWMELD,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotRogueAI.cpp portalclassic/src/game/playerbot/PlayerbotRogueAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotRogueAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotRogueAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,486 @@
+/*
+   Name    : PlayerbotRogueAI.cpp
+   Complete: maybe around 28%
+   Author    : Natsukawa
+   Version : 0.37
+ */
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    ADRENALINE_RUSH          = m_ai->initSpell(ADRENALINE_RUSH_1);
+    SINISTER_STRIKE          = m_ai->initSpell(SINISTER_STRIKE_1);
+    BACKSTAB                 = m_ai->initSpell(BACKSTAB_1);
+    KICK                     = m_ai->initSpell(KICK_1);
+    FEINT                    = m_ai->initSpell(FEINT_1);
+    GOUGE                    = m_ai->initSpell(GOUGE_1);
+    SPRINT                   = m_ai->initSpell(SPRINT_1);
+
+    STEALTH                  = m_ai->initSpell(STEALTH_1);
+    VANISH                   = m_ai->initSpell(VANISH_1);
+    EVASION                  = m_ai->initSpell(EVASION_1);
+    HEMORRHAGE               = m_ai->initSpell(HEMORRHAGE_1);
+    GHOSTLY_STRIKE           = m_ai->initSpell(GHOSTLY_STRIKE_1);
+    BLIND                    = m_ai->initSpell(BLIND_1);
+    DISTRACT                 = m_ai->initSpell(DISTRACT_1);
+    PREPARATION              = m_ai->initSpell(PREPARATION_1);
+    PREMEDITATION            = m_ai->initSpell(PREMEDITATION_1);
+    PICK_POCKET              = m_ai->initSpell(PICK_POCKET_1);
+
+    EVISCERATE               = m_ai->initSpell(EVISCERATE_1);
+    KIDNEY_SHOT              = m_ai->initSpell(KIDNEY_SHOT_1);
+    SLICE_DICE               = m_ai->initSpell(SLICE_AND_DICE_1);
+    GARROTE                  = m_ai->initSpell(GARROTE_1);
+    EXPOSE_ARMOR             = m_ai->initSpell(EXPOSE_ARMOR_1);
+    RUPTURE                  = m_ai->initSpell(RUPTURE_1);
+    CHEAP_SHOT               = m_ai->initSpell(CHEAP_SHOT_1);
+    AMBUSH                   = m_ai->initSpell(AMBUSH_1);
+    COLD_BLOOD               = m_ai->initSpell(COLD_BLOOD_1);
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+    // racial
+    STONEFORM                = m_ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST            = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    PERCEPTION               = m_ai->initSpell(PERCEPTION_ALL); // human
+    SHADOWMELD               = m_ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY               = m_ai->initSpell(BLOOD_FURY_ALL); // orc
+    BERSERKING               = m_ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN     = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotRogueAI::~PlayerbotRogueAI() {}
+
+CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuverPVE(Unit *pTarget)
+{
+    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, EFFECT_INDEX_0) && m_ai->CastSpell(STEALTH, *m_bot))
+    {
+        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
+    }
+    else if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation()); // TODO: this isn't the place for movement code, is it?
+        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
+    }
+
+    // Not in stealth, can't cast stealth; Off to DoNextCombatManeuver
+    return RETURN_NO_ACTION_OK;
+}
+
+// TODO: blatant copy of PVE for now, please PVP-port it
+CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuverPVP(Unit *pTarget)
+{
+    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, EFFECT_INDEX_0) && m_ai->CastSpell(STEALTH, *m_bot))
+    {
+        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
+    }
+    else if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation()); // TODO: this isn't the place for movement code, is it?
+        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
+    }
+
+    // Not in stealth, can't cast stealth; Off to DoNextCombatManeuver
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!pTarget) return RETURN_NO_ACTION_ERROR;
+    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
+    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
+
+    Unit* pVictim = pTarget->getVictim();
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+
+    // TODO: make this work better...
+    /*if (pVictim)
+       {
+        if( pVictim!=m_bot && !m_bot->hasUnitState(UNIT_STAT_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
+            m_ai->TellMaster( "getting behind target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
+        }
+        else if( pVictim==m_bot && m_bot->hasUnitState(UNIT_STAT_FOLLOW) )
+        {
+            m_ai->TellMaster( "chasing attacking target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveChase( pTarget );
+        }
+       }*/
+
+    // If bot is stealthed: pre-combat actions
+    if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
+    {
+        if (PICK_POCKET > 0 && m_ai->In_Reach(pTarget,PICK_POCKET) && (pTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0 && m_ai->PickPocket(pTarget))
+            return RETURN_CONTINUE;
+        if (PREMEDITATION > 0 && m_ai->CastSpell(PREMEDITATION, *pTarget))
+            return RETURN_CONTINUE;
+        if (AMBUSH > 0 && !pTarget->HasInArc(M_PI_F, m_bot) && m_ai->CastSpell(AMBUSH, *pTarget))
+            return RETURN_CONTINUE;
+        if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        if (GARROTE > 0 && !pTarget->HasInArc(M_PI_F, m_bot) && m_ai->CastSpell(GARROTE, *pTarget))
+            return RETURN_CONTINUE;
+
+        // No appropriate action found, remove stealth
+        m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+        return RETURN_CONTINUE;
+    }
+
+    //Used to determine if this bot has highest threat
+    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)) // TODO: && party has a tank
+    {
+        // Aggroed by an elite
+        if (m_ai->IsElite(newTarget))
+        {
+            if (EVASION > 0 && m_ai->GetHealthPercent() <= 35 && !m_bot->HasSpellCooldown(EVASION) && !m_bot->HasAura(EVASION, EFFECT_INDEX_0) && m_ai->CastSpell(EVASION))
+                return RETURN_CONTINUE;
+            if (BLIND > 0 && m_ai->GetHealthPercent() <= 30 && m_ai->HasSpellReagents(BLIND) && !pTarget->HasAura(BLIND, EFFECT_INDEX_0) && m_ai->CastSpell(BLIND, *pTarget))
+                return RETURN_CONTINUE;
+            if (VANISH > 0 && m_ai->GetHealthPercent() <= 20 && !m_bot->HasSpellCooldown(VANISH) && !m_bot->HasAura(FEINT, EFFECT_INDEX_0) && m_ai->CastSpell(VANISH))
+            {
+                m_ai->SetIgnoreUpdateTime(11);
+                return RETURN_CONTINUE;
+            }
+            if (FEINT > 0 && !m_bot->HasSpellCooldown(FEINT) && m_ai->CastSpell(FEINT))
+                return RETURN_CONTINUE;
+            if (PREPARATION > 0 && !m_bot->HasSpellCooldown(PREPARATION) && (m_bot->HasSpellCooldown(EVASION) || m_bot->HasSpellCooldown(VANISH)) && m_ai->CastSpell(PREPARATION))
+                return RETURN_CONTINUE;
+        }
+
+        // Default: Gouge the target
+        if (GOUGE > 0 && !pTarget->HasAura(GOUGE, EFFECT_INDEX_0) && m_ai->CastSpell(GOUGE, *pTarget))
+            return RETURN_CONTINUE;
+    }
+
+    // Buff bot with cold blood if available
+    // This buff is done after the stealth and aggro management code because we don't want to give starting extra damage (= extra threat) to a bot
+    // as it is obviously not soloing his/her target
+    if (COLD_BLOOD > 0 && !m_bot->HasAura(COLD_BLOOD, EFFECT_INDEX_0) && !m_bot->HasSpellCooldown(COLD_BLOOD) && m_ai->CastSpell(COLD_BLOOD, *m_bot))
+            return RETURN_CONTINUE;
+
+    // Rogue like behaviour ^^
+    /*if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
+        m_bot->AttackStop();
+        m_bot->RemoveAllAttackers();
+        m_ai->CastSpell(VANISH);
+        //m_bot->RemoveAllSpellCooldown();
+        m_ai->TellMaster("AttackStop, CombatStop, Vanish");
+    }*/
+
+    // we fight in melee, target is not in range, skip the next part!
+    if (!meleeReach)
+        return RETURN_CONTINUE;
+
+    // If target is elite and wounded: use adrenaline rush to finish it quicker
+    if (ADRENALINE_RUSH > 0 && m_ai->IsElite(pTarget) && pTarget->GetHealthPercent() < 50 && !m_bot->HasAura(ADRENALINE_RUSH, EFFECT_INDEX_0) && !m_bot->HasSpellCooldown(ADRENALINE_RUSH) && m_ai->CastSpell(ADRENALINE_RUSH, *m_bot))
+        return RETURN_CONTINUE;
+
+    // Bot's target is casting a spell: try to interrupt it
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (KIDNEY_SHOT > 0 && !m_bot->HasSpellCooldown(KIDNEY_SHOT) && m_bot->GetComboPoints() >= 1 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget))
+            return RETURN_CONTINUE;
+        else if (KICK > 0 && !m_bot->HasSpellCooldown(KICK) && m_ai->CastSpell(KICK, *pTarget))
+            return RETURN_CONTINUE;
+    }
+
+    // Finishing moves
+    // Bot will try to activate finishing move at 4 combos points (5 combos points case will be bonus)
+    // TODO : define combo points treshold depending on target rank and HP
+    if (m_bot->GetComboPoints() >= 4)
+    {
+        Creature * pCreature = (Creature*) pTarget;
+        // wait for energy
+        if (m_ai->GetEnergyAmount() < 25 && (KIDNEY_SHOT || SLICE_DICE || EXPOSE_ARMOR || RUPTURE))
+            return RETURN_NO_ACTION_OK;
+
+        // If target is elite Slice & Dice is a must have
+        if (SLICE_DICE > 0 && m_ai->IsElite(pTarget) && !m_bot->HasAura(SLICE_DICE, EFFECT_INDEX_1) && m_ai->CastSpell(SLICE_DICE, *pTarget)) // 25 energy (checked above)
+            return RETURN_CONTINUE;
+
+        // If target is a warrior or paladin type (high armor): expose its armor
+        if (EXPOSE_ARMOR > 0 && pCreature && pCreature->GetCreatureInfo()->UnitClass != 8 && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && m_ai->CastSpell(EXPOSE_ARMOR, *pTarget)) // 25 energy (checked above)
+            return RETURN_CONTINUE;
+
+        if (RUPTURE > 0 && !pTarget->HasAura(RUPTURE, EFFECT_INDEX_0) && m_ai->CastSpell(RUPTURE, *pTarget)) // 25 energy (checked above)
+            return RETURN_CONTINUE;
+
+        // default combo action or if other combo action is unavailable/failed
+        // wait for energy
+        if (m_ai->GetEnergyAmount() < 35 && EVISCERATE > 0)
+            return RETURN_NO_ACTION_OK;
+        if (EVISCERATE > 0 && m_ai->CastSpell(EVISCERATE, *pTarget))
+            return RETURN_CONTINUE;
+
+        // failed for some (non-energy related) reason, fall through to normal attacks to maximize DPS
+    }
+
+    // Combo generating or damage increasing attacks
+    if (HEMORRHAGE > 0 && !pTarget->HasAura(HEMORRHAGE, EFFECT_INDEX_2) && m_ai->CastSpell(HEMORRHAGE, *pTarget))
+            return RETURN_CONTINUE;
+    if (BACKSTAB > 0 && !pTarget->HasInArc(M_PI_F, m_bot) && m_ai->CastSpell(BACKSTAB, *pTarget))
+            return RETURN_CONTINUE;
+    if (GHOSTLY_STRIKE > 0 && !m_bot->HasSpellCooldown(GHOSTLY_STRIKE) && m_ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
+            return RETURN_CONTINUE;
+    if (SINISTER_STRIKE > 0 && m_ai->CastSpell(SINISTER_STRIKE, *pTarget))
+            return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_OK;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (!pTarget) return RETURN_NO_ACTION_ERROR;
+    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
+    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
+
+    Unit* pVictim = pTarget->getVictim();
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+
+    // decide what to do:
+    if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
+        SpellSequence = RogueStealth;
+    else if (pTarget->IsNonMeleeSpellCasted(true))
+        SpellSequence = RogueSpellPreventing;
+    else if (pVictim == m_bot && m_ai->GetHealthPercent() < 40)
+        SpellSequence = RogueThreat;
+    else
+        SpellSequence = RogueCombat;
+
+    // we fight in melee, target is not in range, skip the next part!
+    if (!meleeReach)
+        return RETURN_CONTINUE;
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case RogueStealth:
+            if (PREMEDITATION > 0 && m_ai->CastSpell(PREMEDITATION, *pTarget))
+                return RETURN_CONTINUE;
+            if (AMBUSH > 0 && m_ai->CastSpell(AMBUSH, *pTarget))
+                return RETURN_CONTINUE;
+            if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
+                return RETURN_CONTINUE;
+            if (GARROTE > 0 && m_ai->CastSpell(GARROTE, *pTarget))
+                return RETURN_CONTINUE;
+
+            // No appropriate action found, remove stealth
+            m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            return RETURN_CONTINUE;
+
+        case RogueThreat:
+            if (GOUGE > 0 && !pTarget->HasAura(GOUGE, EFFECT_INDEX_0) && m_ai->CastSpell(GOUGE, *pTarget))
+                return RETURN_CONTINUE;
+            if (EVASION > 0 && m_ai->GetHealthPercent() <= 35 && !m_bot->HasAura(EVASION, EFFECT_INDEX_0) && m_ai->CastSpell(EVASION))
+                return RETURN_CONTINUE;
+            if (BLIND > 0 && m_ai->GetHealthPercent() <= 30 && !pTarget->HasAura(BLIND, EFFECT_INDEX_0) && m_ai->CastSpell(BLIND, *pTarget))
+                return RETURN_CONTINUE;
+            if (FEINT > 0 && m_ai->GetHealthPercent() <= 25 && m_ai->CastSpell(FEINT))
+                return RETURN_CONTINUE;
+            if (VANISH > 0 && m_ai->GetHealthPercent() <= 20 && !m_bot->HasAura(FEINT, EFFECT_INDEX_0) && m_ai->CastSpell(VANISH))
+                return RETURN_CONTINUE;
+            if (PREPARATION > 0 && m_ai->CastSpell(PREPARATION))
+                return RETURN_CONTINUE;
+            break;
+
+        case RogueSpellPreventing:
+            if (KIDNEY_SHOT > 0 && m_bot->GetComboPoints() >= 2 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                return RETURN_CONTINUE;
+            else if (KICK > 0 && m_ai->CastSpell(KICK, *pTarget))
+                return RETURN_CONTINUE;
+            // break; // No action? Go combat!
+
+        case RogueCombat:
+        default:
+            if (m_bot->GetComboPoints() >= 5)
+            {
+                // wait for energy
+                if (m_ai->GetEnergyAmount() < 25 && (KIDNEY_SHOT || SLICE_DICE || EXPOSE_ARMOR))
+                    return RETURN_NO_ACTION_OK;
+
+                switch (pTarget->getClass())
+                {
+                case CLASS_SHAMAN:
+                    if (KIDNEY_SHOT > 0 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget)) // 25 energy (checked above)
+                        return RETURN_CONTINUE;
+                    break;
+
+                case CLASS_WARLOCK:
+                case CLASS_HUNTER:
+                    if (SLICE_DICE > 0 && m_ai->CastSpell(SLICE_DICE, *pTarget)) // 25 energy (checked above)
+                       return RETURN_CONTINUE;
+                    break;
+
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                    if (EXPOSE_ARMOR > 0 && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && m_ai->CastSpell(EXPOSE_ARMOR, *pTarget)) // 25 energy (checked above)
+                        return RETURN_CONTINUE;
+                    break;
+
+
+                case CLASS_MAGE:
+                case CLASS_PRIEST:
+                    if (RUPTURE > 0 && m_ai->CastSpell(RUPTURE, *pTarget)) // 25 energy (checked above)
+                        return RETURN_CONTINUE;
+                    break;
+
+                case CLASS_ROGUE:
+                case CLASS_DRUID:
+                default:
+                    break; // fall through to below
+                }
+
+                // default combo action for rogue/druid or if other combo action is unavailable/failed
+                // wait for energy
+                if (m_ai->GetEnergyAmount() < 35 && EVISCERATE)
+                    return RETURN_NO_ACTION_OK;
+                if (EVISCERATE > 0 && m_ai->CastSpell(EVISCERATE, *pTarget))
+                    return RETURN_CONTINUE;
+
+                // failed for some (non-energy related) reason, fall through to normal attacks to maximize DPS
+            }
+
+            if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
+                return RETURN_CONTINUE;
+            if (AMBUSH > 0 && m_ai->CastSpell(AMBUSH, *pTarget))
+                return RETURN_CONTINUE;
+            if (GARROTE > 0 && m_ai->CastSpell(GARROTE, *pTarget))
+                return RETURN_CONTINUE;
+            if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 1) && m_ai->CastSpell(BACKSTAB, *pTarget))
+                return RETURN_CONTINUE;
+            if (SINISTER_STRIKE > 0 && m_ai->CastSpell(SINISTER_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+            if (GHOSTLY_STRIKE > 0 && m_ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+            if (HEMORRHAGE > 0 && m_ai->CastSpell(HEMORRHAGE, *pTarget))
+                return RETURN_CONTINUE;
+
+            break;
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    // remove stealth
+    if (m_bot->HasAura(STEALTH))
+        m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+
+    // hp check
+    if (EatDrinkBandage(false))
+        return;
+
+    // Search and apply poisons to weapons
+    // Mainhand ...
+    Item * poison, * weapon;
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = m_ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (!poison)
+            // Note: in Classic, wound poison and crippling poison share the same display ID
+            // If bot has both in his/her inventory, the first one picked will be used, be it a wound poison or not
+            poison = m_ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = m_ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (poison)
+        {
+            m_ai->UseItem(poison, EQUIPMENT_SLOT_MAINHAND);
+            m_ai->SetIgnoreUpdateTime(5);
+        }
+    }
+    //... and offhand
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = m_ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (!poison)
+            // Note: in Classic, wound poison and crippling poison share the same display ID
+            // If bot has both in his/her inventory, the first one picked will be used, be it a wound poison or not
+            poison = m_ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = m_ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (poison)
+        {
+            m_ai->UseItem(poison, EQUIPMENT_SLOT_OFFHAND);
+            m_ai->SetIgnoreUpdateTime(5);
+        }
+    }
+} // end DoNonCombatActions
diff -ruN mangos-classic/src/game/playerbot/PlayerbotRogueAI.h portalclassic/src/game/playerbot/PlayerbotRogueAI.h
--- mangos-classic/src/game/playerbot/PlayerbotRogueAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotRogueAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,127 @@
+
+#ifndef _PlayerbotRogueAI_H
+#define _PlayerbotRogueAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    RogueCombat,
+    RogueSpellPreventing,
+    RogueThreat,
+    RogueStealth
+};
+
+enum RoguePoisonDisplayId
+{
+    DEADLY_POISON_DISPLAYID         = 13707,
+    CRIPPLING_POISON_DISPLAYID      = 13708,
+    MIND_NUMBLING_POISON_DISPLAYID  = 13709,
+    INSTANT_POISON_DISPLAYID        = 13710,
+    WOUND_POISON_DISPLAYID          = 13708
+};
+
+enum RogueSpells
+{
+    ADRENALINE_RUSH_1               = 13750,
+    AMBUSH_1                        = 8676,
+    BACKSTAB_1                      = 53,
+    BLADE_FLURRY_1                  = 13877,
+    BLIND_1                         = 2094,
+    CHEAP_SHOT_1                    = 1833,
+    COLD_BLOOD_1                    = 14177,
+    DISARM_TRAP_1                   = 1842,
+    DISTRACT_1                      = 1725,
+    EVASION_1                       = 5277,
+    EVISCERATE_1                    = 2098,
+    EXPOSE_ARMOR_1                  = 8647,
+    FEINT_1                         = 1966,
+    GARROTE_1                       = 703,
+    GHOSTLY_STRIKE_1                = 14278,
+    GOUGE_1                         = 1776,
+    HEMORRHAGE_1                    = 16511,
+    KICK_1                          = 1766,
+    KIDNEY_SHOT_1                   = 408,
+    PICK_LOCK_1                     = 1804,
+    PICK_POCKET_1                   = 921,
+    PREMEDITATION_1                 = 14183,
+    PREPARATION_1                   = 14185,
+    RIPOSTE_1                       = 14251,
+    RUPTURE_1                       = 1943,
+    SAP_1                           = 6770,
+    SINISTER_STRIKE_1               = 1752,
+    SLICE_AND_DICE_1                = 5171,
+    SPRINT_1                        = 2983,
+    STEALTH_1                       = 1784,
+    VANISH_1                        = 1856
+};
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotRogueAI : PlayerbotClassAI
+{
+public:
+    PlayerbotRogueAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotRogueAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    // COMBAT
+    uint32 ADRENALINE_RUSH,
+           SINISTER_STRIKE,
+           BACKSTAB,
+           GOUGE,
+           EVASION,
+           SPRINT,
+           KICK,
+           FEINT;
+
+    // SUBTLETY
+    uint32 STEALTH,
+           VANISH,
+           HEMORRHAGE,
+           BLIND,
+           PICK_POCKET,
+           CRIPPLING_POISON,
+           DEADLY_POISON,
+           MIND_NUMBING_POISON,
+           GHOSTLY_STRIKE,
+           DISTRACT,
+           PREPARATION,
+           PREMEDITATION;
+
+    // ASSASSINATION
+    uint32 COLD_BLOOD,
+           EVISCERATE,
+           SLICE_DICE,
+           GARROTE,
+           EXPOSE_ARMOR,
+           AMBUSH,
+           RUPTURE,
+           CHEAP_SHOT,
+           KIDNEY_SHOT;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           PERCEPTION,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotShamanAI.cpp portalclassic/src/game/playerbot/PlayerbotShamanAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotShamanAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotShamanAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,497 @@
+#include "PlayerbotShamanAI.h"
+#include "../SpellAuras.h"
+#include "../Totem.h"
+
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // restoration
+    CHAIN_HEAL               = m_ai->initSpell(CHAIN_HEAL_1);
+    HEALING_WAVE             = m_ai->initSpell(HEALING_WAVE_1);
+    LESSER_HEALING_WAVE      = m_ai->initSpell(LESSER_HEALING_WAVE_1);
+    ANCESTRAL_SPIRIT         = m_ai->initSpell(ANCESTRAL_SPIRIT_1);
+    EARTH_SHIELD             = m_ai->initSpell(EARTH_SHIELD_1);
+    TREMOR_TOTEM             = m_ai->initSpell(TREMOR_TOTEM_1); // totems
+    HEALING_STREAM_TOTEM     = m_ai->initSpell(HEALING_STREAM_TOTEM_1);
+    MANA_SPRING_TOTEM        = m_ai->initSpell(MANA_SPRING_TOTEM_1);
+    MANA_TIDE_TOTEM          = m_ai->initSpell(MANA_TIDE_TOTEM_1);
+    CURE_DISEASE_SHAMAN      = m_ai->initSpell(CURE_DISEASE_SHAMAN_1);
+    CURE_POISON_SHAMAN       = m_ai->initSpell(CURE_POISON_SHAMAN_1);
+    NATURES_SWIFTNESS_SHAMAN = m_ai->initSpell(NATURES_SWIFTNESS_SHAMAN_1);
+    // enhancement
+    FOCUSED                  = 0; // Focused what?
+    STORMSTRIKE              = m_ai->initSpell(STORMSTRIKE_1);
+    BLOODLUST                = m_ai->initSpell(BLOODLUST_1);
+    LIGHTNING_SHIELD         = m_ai->initSpell(LIGHTNING_SHIELD_1);
+    ROCKBITER_WEAPON         = m_ai->initSpell(ROCKBITER_WEAPON_1);
+    FLAMETONGUE_WEAPON       = m_ai->initSpell(FLAMETONGUE_WEAPON_1);
+    FROSTBRAND_WEAPON        = m_ai->initSpell(FROSTBRAND_WEAPON_1);
+    WINDFURY_WEAPON          = m_ai->initSpell(WINDFURY_WEAPON_1);
+    STONESKIN_TOTEM          = m_ai->initSpell(STONESKIN_TOTEM_1); // totems
+    STRENGTH_OF_EARTH_TOTEM  = m_ai->initSpell(STRENGTH_OF_EARTH_TOTEM_1);
+    FROST_RESISTANCE_TOTEM   = m_ai->initSpell(FROST_RESISTANCE_TOTEM_1);
+    FLAMETONGUE_TOTEM        = m_ai->initSpell(FLAMETONGUE_TOTEM_1);
+    FIRE_RESISTANCE_TOTEM    = m_ai->initSpell(FIRE_RESISTANCE_TOTEM_1);
+    GROUNDING_TOTEM          = m_ai->initSpell(GROUNDING_TOTEM_1);
+    NATURE_RESISTANCE_TOTEM  = m_ai->initSpell(NATURE_RESISTANCE_TOTEM_1);
+    WIND_FURY_TOTEM          = m_ai->initSpell(WINDFURY_TOTEM_1);
+    STONESKIN_TOTEM          = m_ai->initSpell(STONESKIN_TOTEM_1);
+    WRATH_OF_AIR_TOTEM       = m_ai->initSpell(WRATH_OF_AIR_TOTEM_1);
+    EARTH_ELEMENTAL_TOTEM    = m_ai->initSpell(EARTH_ELEMENTAL_TOTEM_1);
+    // elemental
+    LIGHTNING_BOLT           = m_ai->initSpell(LIGHTNING_BOLT_1);
+    EARTH_SHOCK              = m_ai->initSpell(EARTH_SHOCK_1);
+    FLAME_SHOCK              = m_ai->initSpell(FLAME_SHOCK_1);
+    PURGE                    = m_ai->initSpell(PURGE_1);
+    FROST_SHOCK              = m_ai->initSpell(FROST_SHOCK_1);
+    CHAIN_LIGHTNING          = m_ai->initSpell(CHAIN_LIGHTNING_1);
+    STONECLAW_TOTEM          = m_ai->initSpell(STONECLAW_TOTEM_1); // totems
+    SEARING_TOTEM            = m_ai->initSpell(SEARING_TOTEM_1);
+    FIRE_NOVA_TOTEM          = 0; // NPC only spell, check FIRE_NOVA_1
+    MAGMA_TOTEM              = m_ai->initSpell(MAGMA_TOTEM_1);
+    EARTHBIND_TOTEM          = m_ai->initSpell(EARTHBIND_TOTEM_1);
+    FIRE_ELEMENTAL_TOTEM     = m_ai->initSpell(FIRE_ELEMENTAL_TOTEM_1);
+    ELEMENTAL_MASTERY        = m_ai->initSpell(ELEMENTAL_MASTERY_1);
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+
+    // racial
+    BLOOD_FURY               = m_ai->initSpell(BLOOD_FURY_ALL); // orc
+    WAR_STOMP                = m_ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING               = m_ai->initSpell(BERSERKING_ALL); // troll
+
+    // totem buffs
+    STRENGTH_OF_EARTH_EFFECT    = m_ai->initSpell(STRENGTH_OF_EARTH_EFFECT_1);
+    FLAMETONGUE_EFFECT          = m_ai->initSpell(FLAMETONGUE_EFFECT_1);
+    MAGMA_TOTEM_EFFECT          = m_ai->initSpell(MAGMA_TOTEM_EFFECT_1);
+    STONECLAW_EFFECT            = m_ai->initSpell(STONECLAW_EFFECT_1);
+    FIRE_RESISTANCE_EFFECT      = m_ai->initSpell(FIRE_RESISTANCE_EFFECT_1);
+    FROST_RESISTANCE_EFFECT     = m_ai->initSpell(FROST_RESISTANCE_EFFECT_1);
+    GROUDNING_EFFECT            = m_ai->initSpell(GROUDNING_EFFECT_1);
+    NATURE_RESISTANCE_EFFECT    = m_ai->initSpell(NATURE_RESISTANCE_EFFECT_1);
+    STONESKIN_EFFECT            = m_ai->initSpell(STONESKIN_EFFECT_1);
+    WINDFURY_EFFECT             = m_ai->initSpell(WINDFURY_EFFECT_1);
+    WRATH_OF_AIR_EFFECT         = m_ai->initSpell(WRATH_OF_AIR_EFFECT_1);
+    CLEANSING_TOTEM_EFFECT      = m_ai->initSpell(CLEANSING_TOTEM_EFFECT_1);
+    MANA_SPRING_EFFECT          = m_ai->initSpell(MANA_SPRING_EFFECT_1);
+    TREMOR_TOTEM_EFFECT         = m_ai->initSpell(TREMOR_TOTEM_EFFECT_1);
+    STONECLAW_EFFECT            = m_ai->initSpell(STONECLAW_EFFECT_1);
+    EARTHBIND_EFFECT            = m_ai->initSpell(EARTHBIND_EFFECT_1);
+}
+
+PlayerbotShamanAI::~PlayerbotShamanAI() {}
+
+CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
+               return HealPlayer(GetHealTarget());
+            else
+                return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    uint32 spec = m_bot->GetSpec();
+
+    // Make sure healer stays put, don't even melee (aggro) if in range.
+    if (m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    else if (!m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
+            return RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return RETURN_CONTINUE;
+    }
+
+    // Damage Spells
+    DropTotems();
+    CheckShields();
+    UseCooldowns();
+    switch (spec)
+    {
+        case SHAMAN_SPEC_ENHANCEMENT:
+            if (STORMSTRIKE > 0 && (!m_bot->HasSpellCooldown(STORMSTRIKE)) && m_ai->CastSpell(STORMSTRIKE, *pTarget))
+                return RETURN_CONTINUE;
+            if (FLAME_SHOCK > 0 && (!pTarget->HasAura(FLAME_SHOCK)) && m_ai->CastSpell(FLAME_SHOCK, *pTarget))
+                return RETURN_CONTINUE;
+            if (EARTH_SHOCK > 0 && (!m_bot->HasSpellCooldown(EARTH_SHOCK)) && m_ai->CastSpell(EARTH_SHOCK, *pTarget))
+                return RETURN_CONTINUE;
+
+            /*if (FOCUSED > 0 && m_ai->CastSpell(FOCUSED, *pTarget))
+                return RETURN_CONTINUE;*/
+            break;
+
+        case SHAMAN_SPEC_RESTORATION:
+            // fall through to elemental
+
+        case SHAMAN_SPEC_ELEMENTAL:
+            if (FLAME_SHOCK > 0 && (!pTarget->HasAura(FLAME_SHOCK)) && m_ai->CastSpell(FLAME_SHOCK, *pTarget))
+                return RETURN_CONTINUE;
+            if (LIGHTNING_BOLT > 0 && m_ai->CastSpell(LIGHTNING_BOLT, *pTarget))
+                return RETURN_CONTINUE;
+            /*if (PURGE > 0 && m_ai->CastSpell(PURGE, *pTarget))
+                return RETURN_CONTINUE;*/
+            /*if (FROST_SHOCK > 0 && !pTarget->HasAura(FROST_SHOCK, EFFECT_INDEX_0) && m_ai->CastSpell(FROST_SHOCK, *pTarget))
+                return RETURN_CONTINUE;*/
+            /*if (CHAIN_LIGHTNING > 0 && m_ai->CastSpell(CHAIN_LIGHTNING, *pTarget))
+                return RETURN_CONTINUE;*/
+    }
+
+    return RETURN_NO_ACTION_OK;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    DropTotems();
+    CheckShields();
+    UseCooldowns();
+
+    Player* healTarget = (m_ai->GetScenarioType() == PlayerbotAI::SCENARIO_PVP_DUEL) ? GetHealTarget() : m_bot;
+    if (HealPlayer(healTarget) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
+        return RETURN_CONTINUE;
+    if (m_ai->CastSpell(LIGHTNING_BOLT))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+CombatManeuverReturns PlayerbotShamanAI::HealPlayer(Player* target)
+{
+    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
+    if (r != RETURN_NO_ACTION_OK)
+        return r;
+
+    if (!target->isAlive())
+    {
+        if (ANCESTRAL_SPIRIT && m_ai->CastSpell(ANCESTRAL_SPIRIT, *target))
+        {
+            std::string msg = "Resurrecting ";
+            msg += target->GetName();
+            m_bot->Say(msg, LANG_UNIVERSAL);
+            return RETURN_CONTINUE;
+        }
+        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
+    }
+
+    // Dispel if necessary
+    if ((CURE_DISEASE_SHAMAN > 0 || CURE_POISON_SHAMAN > 0) && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0)
+    {
+        uint32 dispelMask  = GetDispellMask(DISPEL_POISON);
+        uint32 dispelMask2  = GetDispellMask(DISPEL_DISEASE);
+        Unit::SpellAuraHolderMap const& auras = target->GetSpellAuraHolderMap();
+        for (Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            SpellAuraHolder *holder = itr->second;
+            if ((1 << holder->GetSpellProto()->Dispel) & dispelMask)
+            {
+                if (holder->GetSpellProto()->Dispel == DISPEL_POISON)
+                {
+                    if (m_ai->CastSpell(CURE_POISON_SHAMAN, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+            else if ((1 << holder->GetSpellProto()->Dispel) & dispelMask2)
+            {
+                if (holder->GetSpellProto()->Dispel == DISPEL_DISEASE)
+                {
+                    if (m_ai->CastSpell(CURE_DISEASE_SHAMAN, *target))
+                        return RETURN_CONTINUE;
+                    return RETURN_NO_ACTION_ERROR;
+                }
+            }
+        }
+    }
+
+    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
+    if (target->GetHealthPercent() >= 80)
+        return RETURN_NO_ACTION_OK;
+
+    // Technically the best rotation is CHAIN + LHW + LHW subbing in HW for trouble (bad mana efficiency)
+    if (target->GetHealthPercent() < 30 && HEALING_WAVE > 0 && m_ai->CastSpell(HEALING_WAVE, *target))
+        return RETURN_CONTINUE;
+    if (target->GetHealthPercent() < 50 && LESSER_HEALING_WAVE > 0 && m_ai->CastSpell(LESSER_HEALING_WAVE, *target))
+        return RETURN_CONTINUE;
+    if (target->GetHealthPercent() < 80 && CHAIN_HEAL > 0 && m_ai->CastSpell(CHAIN_HEAL, *target))
+        return RETURN_CONTINUE;
+
+    return RETURN_NO_ACTION_UNKNOWN;
+} // end HealTarget
+
+void PlayerbotShamanAI::DropTotems()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    Totem* earth = m_bot->GetTotem(TOTEM_SLOT_EARTH);
+    Totem* fire = m_bot->GetTotem(TOTEM_SLOT_FIRE);
+    Totem* water = m_bot->GetTotem(TOTEM_SLOT_WATER);
+    Totem* air = m_bot->GetTotem(TOTEM_SLOT_AIR);
+
+    // Earth Totems
+    if ((earth == nullptr) || (m_bot->GetDistance(earth) > 30))
+    {
+        if (STRENGTH_OF_EARTH_TOTEM > 0 && m_ai->CastSpell(STRENGTH_OF_EARTH_TOTEM))
+            return;
+    }
+
+    // Fire Totems
+    if ((fire == nullptr) || (m_bot->GetDistance(fire) > 30))
+    {
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FROST && FROST_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(FROST_RESISTANCE_TOTEM))
+            return;
+        // If the spec didn't take totem of wrath, use flametongue
+        else if ((spec != SHAMAN_SPEC_ELEMENTAL) && FLAMETONGUE_TOTEM > 0 && m_ai->CastSpell(FLAMETONGUE_TOTEM))
+            return;
+    }
+
+    // Air totems
+    if ((air == nullptr) || (m_bot->GetDistance(air) > 30))
+    {
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_NATURE && NATURE_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(NATURE_RESISTANCE_TOTEM))
+            return;
+        else if (spec == SHAMAN_SPEC_ENHANCEMENT)
+        {
+            if (WIND_FURY_TOTEM > 0 /*&& !m_bot->HasAura(IMPROVED_ICY_TALONS)*/ && m_ai->CastSpell(WIND_FURY_TOTEM))
+            return;
+        }
+        else
+        {
+            if (WRATH_OF_AIR_TOTEM > 0 && m_ai->CastSpell(WRATH_OF_AIR_TOTEM))
+            return;
+        }
+    }
+
+    // Water Totems
+    if ((water == nullptr) || (m_bot->GetDistance(water) > 30))
+    {
+        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FIRE && FIRE_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(FIRE_RESISTANCE_TOTEM))
+            return;
+        else if (MANA_SPRING_TOTEM > 0 && m_ai->CastSpell(MANA_SPRING_TOTEM))
+            return;
+    }
+
+    /*if (EARTH_ELEMENTAL_TOTEM > 0 && m_ai->CastSpell(EARTH_ELEMENTAL_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (EARTHBIND_TOTEM > 0 && !pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(EARTHBIND_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (FIRE_ELEMENTAL_TOTEM > 0 && m_ai->CastSpell(FIRE_ELEMENTAL_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (FIRE_NOVA_TOTEM > 0 && m_ai->CastSpell(FIRE_NOVA_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (GROUNDING_TOTEM > 0 && !m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(WIND_FURY_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(GROUNDING_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (HEALING_STREAM_TOTEM > 0 && m_ai->GetHealthPercent() < 50 && !m_bot->HasAura(HEALING_STREAM_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(MANA_SPRING_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(HEALING_STREAM_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (MAGMA_TOTEM > 0 && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && m_ai->CastSpell(MAGMA_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (SEARING_TOTEM > 0 && !pTarget->HasAura(SEARING_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0) && m_ai->CastSpell(SEARING_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (STONECLAW_TOTEM > 0 && m_ai->GetHealthPercent() < 51 && !pTarget->HasAura(STONECLAW_TOTEM, EFFECT_INDEX_0) && !pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(STONECLAW_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (STONESKIN_TOTEM > 0 && !m_bot->HasAura(STONESKIN_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(STONESKIN_TOTEM))
+        return RETURN_CONTINUE;*/
+    /*if (TREMOR_TOTEM > 0 && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(TREMOR_TOTEM))
+        return RETURN_CONTINUE;*/
+}
+
+void PlayerbotShamanAI::CheckShields()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    if (spec == SHAMAN_SPEC_ENHANCEMENT && LIGHTNING_SHIELD > 0 && !m_bot->HasAura(LIGHTNING_SHIELD, EFFECT_INDEX_0))
+        m_ai->CastSpell(LIGHTNING_SHIELD, *m_bot);
+    if (EARTH_SHIELD > 0 && !GetMaster()->HasAura(EARTH_SHIELD, EFFECT_INDEX_0))
+        m_ai->CastSpell(EARTH_SHIELD, *(GetMaster()));
+}
+
+void PlayerbotShamanAI::UseCooldowns()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    if (BLOODLUST > 0 && (!GetMaster()->HasAura(BLOODLUST, EFFECT_INDEX_0)) && m_ai->CastSpell(BLOODLUST))
+        return;
+
+    switch(spec)
+    {
+        case SHAMAN_SPEC_ENHANCEMENT:
+            break;
+
+        case SHAMAN_SPEC_ELEMENTAL:
+            if (ELEMENTAL_MASTERY > 0 && m_ai->CastSpell(ELEMENTAL_MASTERY, *m_bot))
+                return;
+            break;
+
+        case SHAMAN_SPEC_RESTORATION:
+            if (MANA_TIDE_TOTEM > 0 && m_ai->GetManaPercent() < 50 && m_ai->CastSpell(MANA_TIDE_TOTEM))
+                return;
+            else if (NATURES_SWIFTNESS_SHAMAN > 0 && m_ai->CastSpell(NATURES_SWIFTNESS_SHAMAN))
+                return;
+
+        default:
+            break;
+    }
+}
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    if (!m_ai)   return;
+    if (!m_bot)  return;
+
+    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    CheckShields();
+/*
+       // buff myself weapon
+       if (ROCKBITER_WEAPON > 0)
+            (!m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
+       else if (EARTHLIVING_WEAPON > 0)
+            (!m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (WINDFURY_WEAPON > 0)
+            (!m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (FLAMETONGUE_WEAPON > 0)
+            (!m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
+       else if (FROSTBRAND_WEAPON > 0)
+            (!m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
+ */
+    // Mainhand
+    Item* weapon;
+    weapon = m_bot->GetItemByPos(EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ELEMENTAL)
+        m_ai->CastSpell(FLAMETONGUE_WEAPON, *m_bot);
+    else if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ENHANCEMENT)
+        m_ai->CastSpell(WINDFURY_WEAPON, *m_bot);
+
+    //Offhand
+    weapon = m_bot->GetItemByPos(EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ENHANCEMENT)
+        m_ai->CastSpell(FLAMETONGUE_WEAPON, *m_bot);
+
+    // Revive
+    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
+        return;
+
+    // Heal
+    if (m_ai->IsHealer())
+    {
+        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+    else
+    {
+        // Is this desirable? Debatable.
+        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
+        if (HealPlayer(m_bot) & RETURN_CONTINUE)
+            return;// RETURN_CONTINUE;
+    }
+
+    // hp/mana check
+    if (EatDrinkBandage())
+        return;
+} // end DoNonCombatActions
+
+bool PlayerbotShamanAI::CastHoTOnTank()
+{
+    if (!m_ai) return false;
+
+    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
+
+    // Shaman: Healing Stream Totem
+    // None of these are cast before Pulling
+
+    return false;
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotShamanAI.h portalclassic/src/game/playerbot/PlayerbotShamanAI.h
--- mangos-classic/src/game/playerbot/PlayerbotShamanAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotShamanAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,197 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_ENHANCEMENT,
+    SPELL_RESTORATION,
+    SPELL_ELEMENTAL
+};
+
+enum
+{
+    ANCESTRAL_SPIRIT_1              = 2008,
+    ASTRAL_RECALL_1                 = 556,
+    BLOODLUST_1                     = 2825,
+    CHAIN_HEAL_1                    = 1064,
+    CHAIN_LIGHTNING_1               = 421,
+    CLEANSING_TOTEM_1               = 8170,
+    CURE_DISEASE_SHAMAN_1           = 2870,
+    CURE_POISON_SHAMAN_1            = 526,
+    EARTH_ELEMENTAL_TOTEM_1         = 2062,
+    EARTH_SHIELD_1                  = 974,
+    EARTH_SHOCK_1                   = 8042,
+    EARTHBIND_TOTEM_1               = 2484,
+    ELEMENTAL_MASTERY_1             = 16166,
+    FIRE_ELEMENTAL_TOTEM_1          = 2894,
+    FIRE_NOVA_1                     = 1535,
+    FIRE_RESISTANCE_TOTEM_1         = 8184,
+    FLAME_SHOCK_1                   = 8050,
+    FLAMETONGUE_TOTEM_1             = 8227,
+    FLAMETONGUE_WEAPON_1            = 8024,
+    FROST_RESISTANCE_TOTEM_1        = 8181,
+    FROST_SHOCK_1                   = 8056,
+    FROSTBRAND_WEAPON_1             = 8033,
+    GHOST_WOLF_1                    = 2645,
+    GROUNDING_TOTEM_1               = 8177,
+    HEALING_STREAM_TOTEM_1          = 5394,
+    HEALING_WAVE_1                  = 331,
+    LESSER_HEALING_WAVE_1           = 8004,
+    LIGHTNING_BOLT_1                = 403,
+    LIGHTNING_SHIELD_1              = 324,
+    MAGMA_TOTEM_1                   = 8190,
+    MANA_SPRING_TOTEM_1             = 5675,
+    MANA_TIDE_TOTEM_1               = 16190,
+    NATURE_RESISTANCE_TOTEM_1       = 10595,
+    NATURES_SWIFTNESS_SHAMAN_1      = 16188,
+    PURGE_1                         = 370,
+    ROCKBITER_WEAPON_1              = 8017,
+    SEARING_TOTEM_1                 = 3599,
+    SENTRY_TOTEM_1                  = 6495,
+    STONECLAW_TOTEM_1               = 5730,
+    STONESKIN_TOTEM_1               = 8071,
+    STORMSTRIKE_1                   = 17364,
+    STRENGTH_OF_EARTH_TOTEM_1       = 8075,
+    TREMOR_TOTEM_1                  = 8143,
+    WATER_BREATHING_1               = 131,
+    WATER_WALKING_1                 = 546,
+    WINDFURY_TOTEM_1                = 8512,
+    WINDFURY_WEAPON_1               = 8232,
+    WRATH_OF_AIR_TOTEM_1            = 3738,
+
+    //Totem Buffs
+    STRENGTH_OF_EARTH_EFFECT_1      = 8076,
+    FLAMETONGUE_EFFECT_1            = 8026,
+    MAGMA_TOTEM_EFFECT_1            = 8188,
+    STONECLAW_EFFECT_1              = 5728,
+    FIRE_RESISTANCE_EFFECT_1        = 8185,
+    FROST_RESISTANCE_EFFECT_1       = 8182,
+    GROUDNING_EFFECT_1              = 8178,
+    NATURE_RESISTANCE_EFFECT_1      = 10596,
+    STONESKIN_EFFECT_1              = 8072,
+    WINDFURY_EFFECT_1               = 8515,
+    WRATH_OF_AIR_EFFECT_1           = 2895,
+    CLEANSING_TOTEM_EFFECT_1        = 8172,
+    MANA_SPRING_EFFECT_1            = 5677,
+    TREMOR_TOTEM_EFFECT_1           = 8145,
+    EARTHBIND_EFFECT_1              = 6474,
+    // FIRE_ELEMENTAL_TOTEM uses spell effect index 2
+    // SEARING_TOTEM uses spell effect index 0
+    // EARTH_ELEMENTAL_TOTEM uses spell effect indexes 1 and 2
+
+    //Spec buffs
+};
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotShamanAI : PlayerbotClassAI
+{
+public:
+    PlayerbotShamanAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotShamanAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // Utility Functions
+    bool CastHoTOnTank();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    // Heals the target based off its hps
+    CombatManeuverReturns HealPlayer(Player* target);
+    Player* GetHealTarget() { return PlayerbotClassAI::GetHealTarget(); }
+    void DropTotems();
+    void CheckShields();
+    void UseCooldowns();
+
+    // ENHANCEMENT
+    uint32 ROCKBITER_WEAPON,
+           STONESKIN_TOTEM,
+           LIGHTNING_SHIELD,
+           FLAMETONGUE_WEAPON,
+           STRENGTH_OF_EARTH_TOTEM,
+           FOCUSED,
+           FROSTBRAND_WEAPON,
+           FROST_RESISTANCE_TOTEM,
+           FLAMETONGUE_TOTEM,
+           FIRE_RESISTANCE_TOTEM,
+           WINDFURY_WEAPON,
+           GROUNDING_TOTEM,
+           NATURE_RESISTANCE_TOTEM,
+           WIND_FURY_TOTEM,
+           STORMSTRIKE,
+           WRATH_OF_AIR_TOTEM,
+           EARTH_ELEMENTAL_TOTEM,
+           BLOODLUST;
+
+    // RESTORATION
+    uint32 HEALING_WAVE,
+           LESSER_HEALING_WAVE,
+           ANCESTRAL_SPIRIT,
+           TREMOR_TOTEM,
+           HEALING_STREAM_TOTEM,
+           MANA_SPRING_TOTEM,
+           CHAIN_HEAL,
+           MANA_TIDE_TOTEM,
+           EARTH_SHIELD,
+           CURE_DISEASE_SHAMAN,
+           CURE_POISON_SHAMAN,
+           NATURES_SWIFTNESS_SHAMAN;
+
+    // ELEMENTAL
+    uint32 LIGHTNING_BOLT,
+           EARTH_SHOCK,
+           STONECLAW_TOTEM,
+           FLAME_SHOCK,
+           SEARING_TOTEM,
+           PURGE,
+           FIRE_NOVA_TOTEM,
+           FROST_SHOCK,
+           MAGMA_TOTEM,
+           CHAIN_LIGHTNING,
+           FIRE_ELEMENTAL_TOTEM,
+           EARTHBIND_TOTEM,
+           ELEMENTAL_MASTERY;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    // totem buffs
+    uint32 STRENGTH_OF_EARTH_EFFECT,
+           FLAMETONGUE_EFFECT,
+           MAGMA_TOTEM_EFFECT,
+           STONECLAW_EFFECT,
+           FIRE_RESISTANCE_EFFECT,
+           FROST_RESISTANCE_EFFECT,
+           GROUDNING_EFFECT,
+           NATURE_RESISTANCE_EFFECT,
+           STONESKIN_EFFECT,
+           WINDFURY_EFFECT,
+           WRATH_OF_AIR_EFFECT,
+           CLEANSING_TOTEM_EFFECT,
+           HEALING_STREAM_EFFECT,
+           MANA_SPRING_EFFECT,
+           TREMOR_TOTEM_EFFECT,
+           EARTHBIND_EFFECT;
+
+    uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotWarlockAI.cpp portalclassic/src/game/playerbot/PlayerbotWarlockAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotWarlockAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotWarlockAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,695 @@
+
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // DESTRUCTION
+    SHADOW_BOLT           = m_ai->initSpell(SHADOW_BOLT_1);
+    IMMOLATE              = m_ai->initSpell(IMMOLATE_1);
+    SEARING_PAIN          = m_ai->initSpell(SEARING_PAIN_1);
+    CONFLAGRATE           = m_ai->initSpell(CONFLAGRATE_1);
+    HELLFIRE              = m_ai->initSpell(HELLFIRE_1);
+    RAIN_OF_FIRE          = m_ai->initSpell(RAIN_OF_FIRE_1);
+    SOUL_FIRE             = m_ai->initSpell(SOUL_FIRE_1); // soul shard spells
+    SHADOWBURN            = m_ai->initSpell(SHADOWBURN_1);
+    // CURSE
+    CURSE_OF_WEAKNESS     = m_ai->initSpell(CURSE_OF_WEAKNESS_1);
+    CURSE_OF_THE_ELEMENTS = m_ai->initSpell(CURSE_OF_THE_ELEMENTS_1);
+    CURSE_OF_AGONY        = m_ai->initSpell(CURSE_OF_AGONY_1);
+    CURSE_OF_EXHAUSTION   = m_ai->initSpell(CURSE_OF_EXHAUSTION_1);
+    CURSE_OF_RECKLESSNESS = m_ai->initSpell(CURSE_OF_RECKLESSNESS_1);
+    CURSE_OF_SHADOW       = m_ai->initSpell(CURSE_OF_SHADOW_1);
+    CURSE_OF_TONGUES      = m_ai->initSpell(CURSE_OF_TONGUES_1);
+    CURSE_OF_DOOM         = m_ai->initSpell(CURSE_OF_DOOM_1);
+    // AFFLICTION
+    AMPLIFY_CURSE         = m_ai->initSpell(AMPLIFY_CURSE_1);
+    CORRUPTION            = m_ai->initSpell(CORRUPTION_1);
+    DRAIN_SOUL            = m_ai->initSpell(DRAIN_SOUL_1);
+    DRAIN_LIFE            = m_ai->initSpell(DRAIN_LIFE_1);
+    DRAIN_MANA            = m_ai->initSpell(DRAIN_MANA_1);
+    LIFE_TAP              = m_ai->initSpell(LIFE_TAP_1);
+    DARK_PACT             = m_ai->initSpell(DARK_PACT_1);
+    HOWL_OF_TERROR        = m_ai->initSpell(HOWL_OF_TERROR_1);
+    FEAR                  = m_ai->initSpell(FEAR_1);
+    SIPHON_LIFE           = m_ai->initSpell(SIPHON_LIFE_1);
+    // DEMONOLOGY
+    BANISH                = m_ai->initSpell(BANISH_1);
+    ENSLAVE_DEMON         = m_ai->initSpell(ENSLAVE_DEMON_1);
+    DEMON_SKIN            = m_ai->initSpell(DEMON_SKIN_1);
+    DEMON_ARMOR           = m_ai->initSpell(DEMON_ARMOR_1);
+    SHADOW_WARD           = m_ai->initSpell(SHADOW_WARD_1);
+    SOUL_LINK             = m_ai->initSpell(SOUL_LINK_1);
+    SOUL_LINK_AURA        = 25228; // dummy aura applied, after spell SOUL_LINK
+    HEALTH_FUNNEL         = m_ai->initSpell(HEALTH_FUNNEL_1);
+    DETECT_INVISIBILITY   = m_ai->initSpell(DETECT_INVISIBILITY_1);
+    CREATE_FIRESTONE      = m_ai->initSpell(CREATE_FIRESTONE_1);
+    CREATE_HEALTHSTONE    = m_ai->initSpell(CREATE_HEALTHSTONE_1);
+    CREATE_SOULSTONE      = m_ai->initSpell(CREATE_SOULSTONE_1);
+    CREATE_SPELLSTONE     = m_ai->initSpell(CREATE_SPELLSTONE_1);
+    // demon summon
+    SUMMON_IMP            = m_ai->initSpell(SUMMON_IMP_1);
+    SUMMON_VOIDWALKER     = m_ai->initSpell(SUMMON_VOIDWALKER_1);
+    SUMMON_SUCCUBUS       = m_ai->initSpell(SUMMON_SUCCUBUS_1);
+    SUMMON_FELHUNTER      = m_ai->initSpell(SUMMON_FELHUNTER_1);
+    // demon skills should be initialized on demons
+    BLOOD_PACT            = 0; // imp skill
+    CONSUME_SHADOWS       = 0; // voidwalker skill
+    // RANGED COMBAT
+    SHOOT                 = m_ai->initSpell(SHOOT_3);
+
+    RECENTLY_BANDAGED     = 11196; // first aid check
+
+    // racial
+    ESCAPE_ARTIST         = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    PERCEPTION            = m_ai->initSpell(PERCEPTION_ALL); // human
+    BLOOD_FURY            = m_ai->initSpell(BLOOD_FURY_ALL); // orc
+    WILL_OF_THE_FORSAKEN  = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+
+    m_lastDemon           = 0;
+    m_isTempImp           = false;
+    m_CurrentCurse        = 0;
+}
+
+PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
+
+CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
+{
+    m_CurrentCurse = 0;
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
+{
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    //Unit* pVictim = pTarget->getVictim();
+    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
+    Pet *pet = m_bot->GetPet();
+    uint32 spec = m_bot->GetSpec();
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
+
+    // Voidwalker is near death - sacrifice it for a shield
+    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE) && pet->GetHealthPercent() < 10)
+        m_ai->CastPetSpell(SACRIFICE);
+
+    // Use healthstone
+    if (m_ai->GetHealthPercent() < 30)
+    {
+        Item* healthStone = m_ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (healthStone)
+            m_ai->UseItem(healthStone);
+    }
+
+    // Voidwalker sacrifice gives shield - but you lose the pet (and it's DPS/tank) - use only as last resort for your own health!
+    if (m_ai->GetHealthPercent() < 20 && pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE))
+        m_ai->CastPetSpell(SACRIFICE);
+
+    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
+    // if in melee range OR can't shoot OR have no ranged (wand) equipped
+    else if(m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE && (meleeReach || SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true)))
+        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
+
+    //Used to determine if this bot is highest on threat
+    Unit *newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget) // TODO: && party has a tank
+    {
+        // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
+        if (newTarget->GetHealthPercent() > 25)
+        {
+            // If elite
+            if (m_ai->IsElite(newTarget))
+            {
+                // let warlock pet handle it to win some time
+                Creature * pCreature = (Creature*) newTarget;
+                if (pet)
+                {
+                    switch (pet->GetEntry())
+                    {
+                        // taunt the elite and tank it
+                        case DEMON_VOIDWALKER:
+                            if (TORMENT && m_ai->CastPetSpell(TORMENT, newTarget))
+                                return RETURN_NO_ACTION_OK;
+                        // maybe give it some love?
+                        case DEMON_SUCCUBUS:
+                            if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID)
+                                if (SEDUCTION && !newTarget->HasAura(SEDUCTION) && m_ai->CastPetSpell(SEDUCTION, newTarget))
+                                    return RETURN_NO_ACTION_OK;
+                    }
+
+                }
+                // if aggroed mob is a demon or an elemental: banish it
+                if (pCreature && (pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_DEMON || pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_ELEMENTAL))
+                {
+                    if (BANISH && !newTarget->HasAura(BANISH) && CastSpell(BANISH, newTarget))
+                        return RETURN_CONTINUE;
+                }
+
+                return RETURN_NO_ACTION_OK; // do nothing and pray tank gets aggro off you
+            }
+
+            // Not an elite. You could insert FEAR here but in any PvE situation that's 90-95% likely
+            // to worsen the situation for the group. ... So please don't.
+            return CastSpell(SHOOT, pTarget);
+        }
+    }
+
+    // Create soul shard
+    uint8 freeSpace = m_ai->GetFreeBagSpace();
+    uint8 HPThreshold = (m_ai->IsElite(pTarget) ? 10 : 25);
+    if (DRAIN_SOUL && pTarget->GetHealthPercent() < HPThreshold && m_ai->In_Reach(pTarget, DRAIN_SOUL) &&
+        !pTarget->HasAura(DRAIN_SOUL) && (shardCount < MAX_SHARD_COUNT && freeSpace > 0) && CastSpell(DRAIN_SOUL, pTarget))
+    {
+        m_ai->SetIgnoreUpdateTime(15);
+        return RETURN_CONTINUE;
+    }
+
+    if (pet && DARK_PACT && (100 * pet->GetPower(POWER_MANA) / pet->GetMaxPower(POWER_MANA)) > 10 && m_ai->GetManaPercent() <= 20)
+        if (m_ai->CastSpell(DARK_PACT, *m_bot))
+            return RETURN_CONTINUE;
+
+    // Mana check and replenishment
+    if (LIFE_TAP && m_ai->GetManaPercent() <= 20 && m_ai->GetHealthPercent() > 50)
+        if (m_ai->CastSpell(LIFE_TAP, *m_bot))
+            return RETURN_CONTINUE;
+
+    // HP, mana and aggro checks done
+    // Curse the target
+    if (CheckCurse(pTarget))
+        return RETURN_CONTINUE;
+
+    // Damage Spells
+    switch (spec)
+    {
+        case WARLOCK_SPEC_AFFLICTION:
+            if (CORRUPTION && m_ai->In_Reach(pTarget,CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
+                return RETURN_CONTINUE;
+            if (IMMOLATE && m_ai->In_Reach(pTarget,IMMOLATE) && !pTarget->HasAura(IMMOLATE) && CastSpell(IMMOLATE, pTarget))
+                return RETURN_CONTINUE;
+            if (SIPHON_LIFE > 0 && m_ai->In_Reach(pTarget,SIPHON_LIFE) && !pTarget->HasAura(SIPHON_LIFE) && CastSpell(SIPHON_LIFE, pTarget))
+                return RETURN_CONTINUE;
+            if (SHADOW_BOLT && m_ai->In_Reach(pTarget,SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
+                return RETURN_CONTINUE;
+
+            return RETURN_NO_ACTION_OK;
+
+        case WARLOCK_SPEC_DEMONOLOGY:
+            if (CORRUPTION && m_ai->In_Reach(pTarget,CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
+                return RETURN_CONTINUE;
+            if (IMMOLATE && m_ai->In_Reach(pTarget,IMMOLATE) && !pTarget->HasAura(IMMOLATE) && CastSpell(IMMOLATE, pTarget))
+                return RETURN_CONTINUE;
+            if (SHADOW_BOLT && m_ai->In_Reach(pTarget,SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
+                return RETURN_CONTINUE;
+
+            return RETURN_NO_ACTION_OK;
+
+        case WARLOCK_SPEC_DESTRUCTION:
+            if (SHADOWBURN && pTarget->GetHealthPercent() < (HPThreshold / 2.0) && m_ai->In_Reach(pTarget, SHADOWBURN) && !pTarget->HasAura(SHADOWBURN) && CastSpell(SHADOWBURN, pTarget))
+                return RETURN_CONTINUE;
+            if (CORRUPTION && m_ai->In_Reach(pTarget,CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
+                return RETURN_CONTINUE;
+            if (IMMOLATE && m_ai->In_Reach(pTarget,IMMOLATE) && !pTarget->HasAura(IMMOLATE) && CastSpell(IMMOLATE, pTarget))
+                return RETURN_CONTINUE;
+            if (CONFLAGRATE && m_ai->In_Reach(pTarget,CONFLAGRATE) && pTarget->HasAura(IMMOLATE) && !m_bot->HasSpellCooldown(CONFLAGRATE) && CastSpell(CONFLAGRATE, pTarget))
+                return RETURN_CONTINUE;
+            if (SHADOW_BOLT && m_ai->In_Reach(pTarget,SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
+                return RETURN_CONTINUE;
+
+            return RETURN_NO_ACTION_OK;
+
+            //if (DRAIN_LIFE && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(DRAIN_LIFE) && !pTarget->HasAura(DRAIN_MANA) && m_ai->GetHealthPercent() <= 70)
+            //    m_ai->CastSpell(DRAIN_LIFE, *pTarget);
+            //    //m_ai->SetIgnoreUpdateTime(5);
+            //else if (HOWL_OF_TERROR && !pTarget->HasAura(HOWL_OF_TERROR) && m_ai->GetAttackerCount() > 3 && LastSpellAffliction < 8)
+            //    m_ai->CastSpell(HOWL_OF_TERROR, *pTarget);
+            //    m_ai->TellMaster("casting howl of terror!");
+            //else if (FEAR && !pTarget->HasAura(FEAR) && pVictim == m_bot && m_ai->GetAttackerCount() >= 2 && LastSpellAffliction < 9)
+            //    m_ai->CastSpell(FEAR, *pTarget);
+            //    //m_ai->TellMaster("casting fear!");
+            //    //m_ai->SetIgnoreUpdateTime(1.5);
+            //else if (RAIN_OF_FIRE && LastSpellDestruction < 3 && m_ai->GetAttackerCount() >= 3)
+            //    m_ai->CastSpell(RAIN_OF_FIRE, *pTarget);
+            //    //m_ai->TellMaster("casting rain of fire!");
+            //    //m_ai->SetIgnoreUpdateTime(8);
+            //else if (SEARING_PAIN && LastSpellDestruction < 8)
+            //    m_ai->CastSpell(SEARING_PAIN, *pTarget);
+            //else if (SOUL_FIRE && LastSpellDestruction < 9)
+            //    m_ai->CastSpell(SOUL_FIRE, *pTarget);
+            //    //m_ai->SetIgnoreUpdateTime(6);
+            //else if (HELLFIRE && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE) && m_ai->GetAttackerCount() >= 5 && m_ai->GetHealthPercent() >= 50)
+            //    m_ai->CastSpell(HELLFIRE);
+            //    m_ai->TellMaster("casting hellfire!");
+            //    //m_ai->SetIgnoreUpdateTime(15);
+    }
+
+    // No spec due to low level OR no spell found yet
+    if (CORRUPTION && m_ai->In_Reach(pTarget,CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
+        return RETURN_CONTINUE;
+    if (IMMOLATE && m_ai->In_Reach(pTarget,IMMOLATE) && !pTarget->HasAura(IMMOLATE) && CastSpell(IMMOLATE, pTarget))
+        return RETURN_CONTINUE;
+    if (SHADOW_BOLT && m_ai->In_Reach(pTarget,SHADOW_BOLT))
+        return CastSpell(SHADOW_BOLT, pTarget);
+
+    return RETURN_NO_ACTION_OK;
+} // end DoNextCombatManeuver
+
+CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (FEAR && m_ai->In_Reach(pTarget,FEAR) && m_ai->CastSpell(FEAR, *pTarget))
+        return RETURN_CONTINUE;
+    if (SHADOW_BOLT && m_ai->In_Reach(pTarget,SHADOW_BOLT) && m_ai->CastSpell(SHADOW_BOLT))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+// Decision tree for putting a curse on the current target
+bool PlayerbotWarlockAI::CheckCurse(Unit* pTarget)
+{
+    Creature * pCreature = (Creature*) pTarget;
+    uint32 CurseToCast = 0;
+
+    // Prevent low health humanoid from fleeing or fleeing too fast
+    // Curse of Exhaustion first to avoid increasing damage output on tank
+    if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
+    {
+        if (CURSE_OF_EXHAUSTION && m_ai->In_Reach(pTarget,CURSE_OF_EXHAUSTION) && !pTarget->HasAura(CURSE_OF_EXHAUSTION))
+        {
+            if (AMPLIFY_CURSE && !m_bot->HasSpellCooldown(AMPLIFY_CURSE))
+                CastSpell(AMPLIFY_CURSE, m_bot);
+
+            if (CastSpell(CURSE_OF_EXHAUSTION, pTarget))
+            {
+                m_CurrentCurse = CURSE_OF_EXHAUSTION;
+                return true;
+            }
+        }
+        else if (CURSE_OF_RECKLESSNESS && m_ai->In_Reach(pTarget,CURSE_OF_RECKLESSNESS) && !pTarget->HasAura(CURSE_OF_RECKLESSNESS) && !pTarget->HasAura(CURSE_OF_EXHAUSTION) && CastSpell(CURSE_OF_RECKLESSNESS, pTarget))
+        {
+            m_CurrentCurse = CURSE_OF_RECKLESSNESS;
+            return true;
+        }
+    }
+
+    // If bot already put a curse and curse is still active on target: no need to go further
+    if (m_CurrentCurse > 0 && pTarget->HasAura(m_CurrentCurse))
+        return false;
+
+    // No curse or effect worn off: choose again which curse to use
+
+    // Target is a boss
+    if (pCreature && pCreature->IsWorldBoss())
+    {
+        if (m_bot->GetGroup())
+        {
+            uint8 mages = 0;
+            uint8 warlocks = 1;
+            Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *groupMember = sObjectMgr.GetPlayer(itr->guid);
+                if (!groupMember || !groupMember->isAlive())
+                    continue;
+                switch (groupMember->getClass())
+                {
+                    case CLASS_WARLOCK:
+                        warlocks++;
+                        continue;
+                    case CLASS_MAGE:
+                        mages++;
+                        continue;
+                }
+            }
+            if (warlocks > 1 && warlocks > mages)
+                CurseToCast = CURSE_OF_SHADOW;
+            else if (mages > warlocks)
+                CurseToCast = CURSE_OF_THE_ELEMENTS;
+            else
+                CurseToCast = CURSE_OF_AGONY;
+        }
+    // If target is not elite, no need to put a curse useful
+    // in the long run: go for direct damage
+    } else if (!m_ai->IsElite(pTarget))
+        CurseToCast = CURSE_OF_AGONY;
+    // Enemy elite mages have low health but can cast dangerous spells: group safety before bot DPS
+    else if (pCreature && pCreature->GetCreatureInfo()->UnitClass == 8)
+        CurseToCast = CURSE_OF_TONGUES;
+    // Default case: Curse of Agony
+    else
+        CurseToCast = CURSE_OF_AGONY;
+
+    // Try to curse the target with the selected curse
+    if (CurseToCast && m_ai->In_Reach(pTarget,CurseToCast) && !pTarget->HasAura(CurseToCast))
+    {
+        if (CurseToCast == CURSE_OF_AGONY)
+            if (AMPLIFY_CURSE && !m_bot->HasSpellCooldown(AMPLIFY_CURSE))
+                CastSpell(AMPLIFY_CURSE, m_bot);
+
+        if (CastSpell(CurseToCast, pTarget))
+        {
+            m_CurrentCurse = CurseToCast;
+            return true;
+        }
+    }
+    // else: go for Curse of Agony
+    else if (CURSE_OF_AGONY && m_ai->In_Reach(pTarget,CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_AGONY))
+    {
+        if (AMPLIFY_CURSE && !m_bot->HasSpellCooldown(AMPLIFY_CURSE))
+            CastSpell(AMPLIFY_CURSE, m_bot);
+
+        if (CastSpell(CURSE_OF_AGONY, pTarget))
+        {
+            m_CurrentCurse = CURSE_OF_AGONY;
+            return true;
+        }
+    }
+    // else: go for Curse of Weakness
+    else if (CURSE_OF_WEAKNESS && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(CURSE_OF_AGONY))
+    {
+        if (AMPLIFY_CURSE && !m_bot->HasSpellCooldown(AMPLIFY_CURSE))
+            CastSpell(AMPLIFY_CURSE, m_bot);
+
+        if (CastSpell(CURSE_OF_WEAKNESS, pTarget))
+        {
+            m_CurrentCurse = CURSE_OF_WEAKNESS;
+            return true;
+        }
+    }
+    else
+        return false;
+}
+
+void PlayerbotWarlockAI::CheckDemon()
+{
+    uint32 spec = m_bot->GetSpec();
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
+    Pet *pet = m_bot->GetPet();
+    uint32 demonOfChoice;
+
+    // If pet other than imp is active: return
+    if (pet && pet->GetEntry() != DEMON_IMP)
+        return;
+
+    //Assign demon of choice
+    if (spec == WARLOCK_SPEC_AFFLICTION)
+        demonOfChoice = DEMON_FELHUNTER;
+    else if (spec == WARLOCK_SPEC_DEMONOLOGY)
+        demonOfChoice = DEMON_SUCCUBUS;
+    else if (spec == WARLOCK_SPEC_DESTRUCTION)
+        demonOfChoice = DEMON_IMP;
+
+    // Summon demon
+    if (!pet || m_isTempImp)
+    {
+        uint32 summonSpellId;
+        if (demonOfChoice != DEMON_IMP && shardCount > 0)
+        {
+            switch (demonOfChoice)
+            {
+                case DEMON_VOIDWALKER:
+                    summonSpellId = SUMMON_VOIDWALKER;
+                    break;
+
+                case DEMON_FELHUNTER:
+                    summonSpellId = SUMMON_FELHUNTER;
+                    break;
+
+                case DEMON_SUCCUBUS:
+                    summonSpellId = SUMMON_SUCCUBUS;
+                    break;
+
+                default:
+                    summonSpellId = 0;
+            }
+
+            if (summonSpellId && m_ai->CastSpell(summonSpellId))
+            {
+                //m_ai->TellMaster("Summoning favorite demon...");
+                m_isTempImp = false;
+                return;
+            }
+        }
+
+        if (!pet && SUMMON_IMP && m_ai->CastSpell(SUMMON_IMP))
+        {
+            if (demonOfChoice != DEMON_IMP)
+                m_isTempImp = true;
+            else
+                m_isTempImp = false;
+
+            //m_ai->TellMaster("Summoning Imp...");
+            return;
+        }
+    }
+
+    return;
+}
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    //uint32 spec = m_bot->GetSpec();
+    Pet *pet = m_bot->GetPet();
+
+    // Initialize pet spells
+    if (pet && pet->GetEntry() != m_lastDemon)
+    {
+        switch (pet->GetEntry())
+        {
+            case DEMON_IMP:
+                BLOOD_PACT       = m_ai->initPetSpell(BLOOD_PACT_ICON);
+                FIREBOLT         = m_ai->initPetSpell(FIREBOLT_ICON);
+                FIRE_SHIELD      = m_ai->initPetSpell(FIRE_SHIELD_ICON);
+                break;
+
+            case DEMON_VOIDWALKER:
+                CONSUME_SHADOWS  = m_ai->initPetSpell(CONSUME_SHADOWS_ICON);
+                SACRIFICE        = m_ai->initPetSpell(SACRIFICE_ICON);
+                SUFFERING        = m_ai->initPetSpell(SUFFERING_ICON);
+                TORMENT          = m_ai->initPetSpell(TORMENT_ICON);
+                break;
+
+            case DEMON_SUCCUBUS:
+                LASH_OF_PAIN     = m_ai->initPetSpell(LASH_OF_PAIN_ICON);
+                SEDUCTION        = m_ai->initPetSpell(SEDUCTION_ICON);
+                SOOTHING_KISS    = m_ai->initPetSpell(SOOTHING_KISS_ICON);
+                break;
+
+            case DEMON_FELHUNTER:
+                DEVOUR_MAGIC     = m_ai->initPetSpell(DEVOUR_MAGIC_ICON);
+                SPELL_LOCK       = m_ai->initPetSpell(SPELL_LOCK_ICON);
+                break;
+        }
+
+        m_lastDemon = pet->GetEntry();
+    }
+
+    // Destroy extra soul shards
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
+    uint8 freeSpace = m_ai->GetFreeBagSpace();
+    if (shardCount > MAX_SHARD_COUNT || (freeSpace == 0 && shardCount > 1))
+        m_bot->DestroyItemCount(SOUL_SHARD, shardCount > MAX_SHARD_COUNT ? shardCount - MAX_SHARD_COUNT : 1, true, false);
+
+    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR - Strongest one available is chosen
+    if (DEMON_ARMOR)
+    {
+        if (m_ai->SelfBuff(DEMON_ARMOR))
+            return;
+    }
+    else if (DEMON_SKIN)
+        if (m_ai->SelfBuff(DEMON_SKIN))
+            return;
+
+    // healthstone creation
+    if (CREATE_HEALTHSTONE && shardCount > 0)
+    {
+        Item* const healthStone = m_ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (!healthStone && m_ai->CastSpell(CREATE_HEALTHSTONE))
+            return;
+    }
+
+    // soulstone creation and use
+    if (CREATE_SOULSTONE)
+    {
+        Item* soulStone = m_ai->FindConsumable(SOULSTONE_DISPLAYID);
+        if (!soulStone)
+        {
+            if (shardCount > 0 && !m_bot->HasSpellCooldown(CREATE_SOULSTONE) && m_ai->CastSpell(CREATE_SOULSTONE))
+                return;
+        }
+        else
+        {
+            uint32 soulStoneSpell = soulStone->GetProto()->Spells[0].SpellId;
+            Player* master = GetMaster();
+            if (!master->HasAura(soulStoneSpell) && !m_bot->HasSpellCooldown(soulStoneSpell))
+            {
+                // TODO: first choice: healer. Second choice: anyone else with revive spell. Third choice: self or master.
+                m_ai->UseItem(soulStone, master);
+                return;
+            }
+        }
+    }
+
+    // hp/mana check
+    if (pet && DARK_PACT && (100 * pet->GetPower(POWER_MANA) / pet->GetMaxPower(POWER_MANA)) > 40 && m_ai->GetManaPercent() <= 60)
+        if (m_ai->CastSpell(DARK_PACT, *m_bot))
+            return;
+
+    if (LIFE_TAP && m_ai->GetManaPercent() <= 80 && m_ai->GetHealthPercent() > 50)
+        if (m_ai->CastSpell(LIFE_TAP, *m_bot))
+            return;
+
+    // Do not waste time/soul shards to create spellstone or firestone
+    // if two-handed weapon (staff) or off-hand item are already equiped
+    // Spellstone creation and use (Spellstone dominates firestone completely as I understand it)
+    Item* const weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    Item* const offweapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && !offweapon && weapon->GetProto()->SubClass != ITEM_SUBCLASS_WEAPON_STAFF && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        Item* const stone = m_ai->FindConsumable(SPELLSTONE_DISPLAYID);
+        Item* const stone2 = m_ai->FindConsumable(FIRESTONE_DISPLAYID);
+        uint8 spellstone_count = m_bot->GetItemCount(SPELLSTONE, false, nullptr);
+        if (spellstone_count == 0)
+            spellstone_count = m_bot->GetItemCount(GREATER_SPELLSTONE, false, nullptr);
+        if (spellstone_count == 0)
+            spellstone_count = m_bot->GetItemCount(MAJOR_SPELLSTONE, false, nullptr);
+        uint8 firestone_count = m_bot->GetItemCount(LESSER_FIRESTONE, false, nullptr);
+        if (firestone_count == 0)
+            firestone_count = m_bot->GetItemCount(FIRESTONE, false, nullptr);
+        if (firestone_count == 0)
+            firestone_count = m_bot->GetItemCount(GREATER_FIRESTONE, false, nullptr);
+        if (firestone_count == 0)
+            firestone_count = m_bot->GetItemCount(MAJOR_FIRESTONE, false, nullptr);
+        if (spellstone_count == 0 && firestone_count == 0)
+        {
+            if (CREATE_SPELLSTONE && shardCount > 0 && m_ai->CastSpell(CREATE_SPELLSTONE))
+                return;
+            else if (CREATE_SPELLSTONE == 0 && CREATE_FIRESTONE > 0 && shardCount > 0 && m_ai->CastSpell(CREATE_FIRESTONE))
+                return;
+        }
+        else if (stone)
+        {
+            m_ai->UseItem(stone, EQUIPMENT_SLOT_OFFHAND);
+            return;
+        }
+        else
+        {
+            m_ai->UseItem(stone2, EQUIPMENT_SLOT_OFFHAND);
+            return;
+        }
+    }
+
+    if (EatDrinkBandage())
+        return;
+
+    //Heal Voidwalker
+    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && CONSUME_SHADOWS && pet->GetHealthPercent() < 75 && !pet->HasAura(CONSUME_SHADOWS))
+        m_ai->CastPetSpell(CONSUME_SHADOWS);
+
+    CheckDemon();
+
+    // Soul link demon
+    if (pet && SOUL_LINK && !m_bot->HasAura(SOUL_LINK_AURA) && m_ai->CastSpell(SOUL_LINK, *m_bot))
+        return;
+
+    // Check demon buffs
+    if (pet && pet->GetEntry() == DEMON_IMP && BLOOD_PACT && !m_bot->HasAura(BLOOD_PACT) && m_ai->CastPetSpell(BLOOD_PACT))
+        return;
+} // end DoNonCombatActions
+
+// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
+uint32 PlayerbotWarlockAI::Neutralize(uint8 creatureType)
+{
+    if (!m_bot)         return 0;
+    if (!m_ai)          return 0;
+    if (!creatureType)  return 0;
+
+    // TODO: add a way to handle spell cast by pet like Seduction
+    if (creatureType != CREATURE_TYPE_DEMON && creatureType != CREATURE_TYPE_ELEMENTAL)
+    {
+        m_ai->TellMaster("I can't banish that target.");
+        return 0;
+    }
+
+    if (BANISH)
+        return BANISH;
+    else
+        return 0;
+
+    return 0;
+}
\ No newline at end of file
diff -ruN mangos-classic/src/game/playerbot/PlayerbotWarlockAI.h portalclassic/src/game/playerbot/PlayerbotWarlockAI.h
--- mangos-classic/src/game/playerbot/PlayerbotWarlockAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotWarlockAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,231 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+#define SOUL_SHARD 6265
+#define SPELLSTONE 5522
+#define GREATER_SPELLSTONE 13602
+#define MAJOR_SPELLSTONE 13603
+#define LESSER_FIRESTONE 1254
+#define FIRESTONE 13699
+#define GREATER_FIRESTONE 13700
+#define MAJOR_FIRESTONE 13701
+#define MAX_SHARD_COUNT 15 // Maximum soul shard count bot should keep
+
+enum
+{
+    SPELL_CURSES,
+    SPELL_AFFLICTION,
+    SPELL_DESTRUCTION,
+    SPELL_DEMONOLOGY
+};
+
+enum StoneDisplayId
+{
+    FIRESTONE_DISPLAYID   = 24380,
+    SPELLSTONE_DISPLAYID  = 21610,
+    SOULSTONE_DISPLAYID   = 6009,
+    HEALTHSTONE_DISPLAYID = 8026
+};
+
+enum DemonEntry
+{
+    DEMON_IMP        = 416,
+    DEMON_VOIDWALKER = 1860,
+    DEMON_SUCCUBUS   = 1863,
+    DEMON_FELHUNTER  = 417
+};
+
+enum DemonSpellIconIds
+{
+    // Imp
+    BLOOD_PACT_ICON       = 541,
+    FIREBOLT_ICON         = 18,
+    FIRE_SHIELD_ICON      = 16,
+    // Felhunter
+    DEVOUR_MAGIC_ICON     = 47,
+    SPELL_LOCK_ICON       = 77,
+    // Succubus
+    LASH_OF_PAIN_ICON     = 596,
+    SEDUCTION_ICON        = 48,
+    SOOTHING_KISS_ICON    = 694,
+    // Voidwalker
+    CONSUME_SHADOWS_ICON  = 207,
+    SACRIFICE_ICON        = 693,
+    SUFFERING_ICON        = 9,
+    TORMENT_ICON          = 173
+};
+
+enum WarlockSpells
+{
+    AMPLIFY_CURSE_1                 = 18288,
+    BANISH_1                        = 710,
+    CONFLAGRATE_1                   = 17962,
+    CORRUPTION_1                    = 172,
+    CREATE_FIRESTONE_1              = 6366,
+    CREATE_HEALTHSTONE_1            = 6201,
+    CREATE_SOULSTONE_1              = 693,
+    CREATE_SPELLSTONE_1             = 2362,
+    CURSE_OF_AGONY_1                = 980,
+    CURSE_OF_DOOM_1                 = 603,
+    CURSE_OF_EXHAUSTION_1           = 18223,
+    CURSE_OF_RECKLESSNESS_1         = 704,
+    CURSE_OF_SHADOW_1               = 17862,
+    CURSE_OF_THE_ELEMENTS_1         = 1490,
+    CURSE_OF_TONGUES_1              = 1714,
+    CURSE_OF_WEAKNESS_1             = 702,
+    DARK_PACT_1                     = 18220,
+    DEATH_COIL_WARLOCK_1            = 6789,
+    DEMON_ARMOR_1                   = 706,
+    DEMON_SKIN_1                    = 687,
+    DETECT_INVISIBILITY_1           = 132,
+    DRAIN_LIFE_1                    = 689,
+    DRAIN_MANA_1                    = 5138,
+    DRAIN_SOUL_1                    = 1120,
+    ENSLAVE_DEMON_1                 = 1098,
+    EYE_OF_KILROGG_1                = 126,
+    FEAR_1                          = 5782,
+    FEL_DOMINATION_1                = 18708,
+    HEALTH_FUNNEL_1                 = 755,
+    HELLFIRE_1                      = 1949,
+    HOWL_OF_TERROR_1                = 5484,
+    IMMOLATE_1                      = 348,
+    INFERNO_1                       = 1122,
+    LIFE_TAP_1                      = 1454,
+    RAIN_OF_FIRE_1                  = 5740,
+    RITUAL_OF_DOOM_1                = 18540,
+    RITUAL_OF_SUMMONING_1           = 698,
+    SEARING_PAIN_1                  = 5676,
+    SENSE_DEMONS_1                  = 5500,
+    SHADOW_BOLT_1                   = 686,
+    SHADOW_WARD_1                   = 6229,
+    SHADOWBURN_1                    = 17877,
+    SHOOT_3                         = 5019,
+    SIPHON_LIFE_1                   = 18265,
+    SOUL_FIRE_1                     = 6353,
+    SOUL_LINK_1                     = 19028,
+    SUMMON_FELHUNTER_1              = 691,
+    SUMMON_IMP_1                    = 688,
+    SUMMON_SUCCUBUS_1               = 712,
+    SUMMON_VOIDWALKER_1             = 697,
+    UNENDING_BREATH_1               = 5697
+};
+
+//class Player;
+class MANGOS_DLL_SPEC PlayerbotWarlockAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarlockAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarlockAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    uint32 Neutralize(uint8 creatureType);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    CombatManeuverReturns CastSpell(uint32 nextAction, Unit *pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
+
+    bool CheckCurse(Unit* pTarget);
+    void CheckDemon();
+
+    // CURSES
+    uint32 CURSE_OF_WEAKNESS,
+           CURSE_OF_AGONY,
+           CURSE_OF_EXHAUSTION,
+           CURSE_OF_RECKLESSNESS,
+           CURSE_OF_SHADOW,
+           CURSE_OF_TONGUES,
+           CURSE_OF_THE_ELEMENTS,
+           CURSE_OF_DOOM;
+
+    // RANGED
+    uint32 SHOOT;
+
+    // AFFLICTION
+    uint32 AMPLIFY_CURSE,
+           CORRUPTION,
+           DRAIN_SOUL,
+           DRAIN_LIFE,
+           DRAIN_MANA,
+           LIFE_TAP,
+           DARK_PACT,
+           HOWL_OF_TERROR,
+           FEAR,
+           SIPHON_LIFE;
+
+    // DESTRUCTION
+    uint32 SHADOW_BOLT,
+           IMMOLATE,
+           SEARING_PAIN,
+           CONFLAGRATE,
+           SOUL_FIRE,
+           HELLFIRE,
+           RAIN_OF_FIRE,
+           SHADOWBURN;
+
+    // DEMONOLOGY
+    uint32 BANISH,
+           DEMON_SKIN,
+           DEMON_ARMOR,
+           SHADOW_WARD,
+           ENSLAVE_DEMON,
+           SOUL_LINK,
+           SOUL_LINK_AURA,
+           HEALTH_FUNNEL,
+           DETECT_INVISIBILITY,
+           CREATE_FIRESTONE,
+           CREATE_SOULSTONE,
+           CREATE_HEALTHSTONE,
+           CREATE_SPELLSTONE;
+
+    // DEMON SUMMON
+    uint32 SUMMON_IMP,
+           SUMMON_VOIDWALKER,
+           SUMMON_SUCCUBUS,
+           SUMMON_FELHUNTER;
+
+    // DEMON SKILLS
+    uint32 BLOOD_PACT,
+           FIREBOLT,
+           FIRE_SHIELD,
+           ANGUISH,
+           INTERCEPT,
+           DEVOUR_MAGIC,
+           SPELL_LOCK,
+           LASH_OF_PAIN,
+           SEDUCTION,
+           SOOTHING_KISS,
+           CONSUME_SHADOWS,
+           SACRIFICE,
+           SUFFERING,
+           TORMENT;
+
+    // racial
+    uint32 STONEFORM,
+           ESCAPE_ARTIST,
+           PERCEPTION,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 m_lastDemon;      // Last demon entry used for spell initialization
+    bool m_isTempImp;        // True if imp summoned temporarily until soul shard acquired for demon of choice.
+    uint32 m_CurrentCurse;   // Curse currently active on bot's target
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/PlayerbotWarriorAI.cpp portalclassic/src/game/playerbot/PlayerbotWarriorAI.cpp
--- mangos-classic/src/game/playerbot/PlayerbotWarriorAI.cpp	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotWarriorAI.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,570 @@
+/*
+   Name    : PlayerbotWarriorAI.cpp
+   Complete: maybe around 37%
+   Author  : Natsukawa
+   Version : 0.39
+ */
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotMgr.h"
+#include "../SpellAuras.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    SHOOT_BOW               = m_ai->initSpell(SHOOT_BOW_1); // GENERAL
+    SHOOT_GUN               = m_ai->initSpell(SHOOT_GUN_1); // GENERAL
+    SHOOT_XBOW              = m_ai->initSpell(SHOOT_XBOW_1); // GENERAL
+
+    BATTLE_STANCE           = m_ai->initSpell(BATTLE_STANCE_1); //ARMS
+    CHARGE                  = m_ai->initSpell(CHARGE_1); //ARMS
+    OVERPOWER               = m_ai->initSpell(OVERPOWER_1); // ARMS
+    HEROIC_STRIKE           = m_ai->initSpell(HEROIC_STRIKE_1); //ARMS
+    REND                    = m_ai->initSpell(REND_1); //ARMS
+    THUNDER_CLAP            = m_ai->initSpell(THUNDER_CLAP_1);  //ARMS
+    HAMSTRING               = m_ai->initSpell(HAMSTRING_1);  //ARMS
+    MOCKING_BLOW            = m_ai->initSpell(MOCKING_BLOW_1);  //ARMS
+    RETALIATION             = m_ai->initSpell(RETALIATION_1);  //ARMS
+    SWEEPING_STRIKES        = m_ai->initSpell(SWEEPING_STRIKES_1); //ARMS
+    MORTAL_STRIKE           = m_ai->initSpell(MORTAL_STRIKE_1);  //ARMS
+    BLOODRAGE               = m_ai->initSpell(BLOODRAGE_1); //PROTECTION
+    DEFENSIVE_STANCE        = m_ai->initSpell(DEFENSIVE_STANCE_1); //PROTECTION
+    SUNDER_ARMOR            = m_ai->initSpell(SUNDER_ARMOR_1); //PROTECTION
+    TAUNT                   = m_ai->initSpell(TAUNT_1); //PROTECTION
+    SHIELD_BASH             = m_ai->initSpell(SHIELD_BASH_1); //PROTECTION
+    REVENGE                 = m_ai->initSpell(REVENGE_1); //PROTECTION
+    SHIELD_BLOCK            = m_ai->initSpell(SHIELD_BLOCK_1); //PROTECTION
+    DISARM                  = m_ai->initSpell(DISARM_1); //PROTECTION
+    SHIELD_WALL             = m_ai->initSpell(SHIELD_WALL_1); //PROTECTION
+    SHIELD_SLAM             = m_ai->initSpell(SHIELD_SLAM_1); //PROTECTION
+    CONCUSSION_BLOW         = m_ai->initSpell(CONCUSSION_BLOW_1); //PROTECTION
+    LAST_STAND              = m_ai->initSpell(LAST_STAND_1); //PROTECTION
+    BATTLE_SHOUT            = m_ai->initSpell(BATTLE_SHOUT_1); //FURY
+    DEMORALIZING_SHOUT      = m_ai->initSpell(DEMORALIZING_SHOUT_1); //FURY
+    CLEAVE                  = m_ai->initSpell(CLEAVE_1); //FURY
+    INTIMIDATING_SHOUT      = m_ai->initSpell(INTIMIDATING_SHOUT_1); //FURY
+    EXECUTE                 = m_ai->initSpell(EXECUTE_1); //FURY
+    CHALLENGING_SHOUT       = m_ai->initSpell(CHALLENGING_SHOUT_1); //FURY
+    SLAM                    = m_ai->initSpell(SLAM_1); //FURY
+    BERSERKER_STANCE        = m_ai->initSpell(BERSERKER_STANCE_1); //FURY
+    INTERCEPT               = m_ai->initSpell(INTERCEPT_1); //FURY
+    DEATH_WISH              = m_ai->initSpell(DEATH_WISH_1); //FURY
+    BERSERKER_RAGE          = m_ai->initSpell(BERSERKER_RAGE_1); //FURY
+    WHIRLWIND               = m_ai->initSpell(WHIRLWIND_1); //FURY
+    PUMMEL                  = m_ai->initSpell(PUMMEL_1); //FURY
+    BLOODTHIRST             = m_ai->initSpell(BLOODTHIRST_1); //FURY
+    RECKLESSNESS            = m_ai->initSpell(RECKLESSNESS_1); //FURY
+    PIERCING_HOWL           = m_ai->initSpell(PIERCING_HOWL_1); //FURY
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    STONEFORM               = m_ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    PERCEPTION              = m_ai->initSpell(PERCEPTION_ALL); // human
+    SHADOWMELD              = m_ai->initSpell(SHADOWMELD_ALL); // night elf
+    BLOOD_FURY              = m_ai->initSpell(BLOOD_FURY_ALL); // orc
+    WAR_STOMP               = m_ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = m_ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+
+    //Procs
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
+
+CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuver(Unit* pTarget)
+{
+    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
+    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
+        {
+            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
+            {
+                if (m_bot->GetCombatDistance(pTarget, true) <= ATTACK_DISTANCE)
+                {
+                    // Set everyone's UpdateAI() waiting to 2 seconds
+                    m_ai->SetGroupIgnoreUpdateTime(2);
+                    // Clear their TEMP_WAIT_TANKAGGRO flag
+                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+                    // Start attacking, force target on current target
+                    m_ai->Attack(m_ai->GetCurrentTarget());
+
+                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
+                }
+                else
+                {
+                    // TODO: add check if target is ranged
+                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
+                }
+            }
+            else
+                return RETURN_NO_ACTION_OK; // wait it out
+        }
+        else
+        {
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
+        }
+    }
+
+    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
+    {
+        if (m_WaitUntil > m_ai->CurrentTime() && !m_ai->IsGroupInCombat())
+            return RETURN_NO_ACTION_OK; // wait it out
+        else
+            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
+    }
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoFirstCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoFirstCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuverPVE(Unit* pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    float fTargetDist = m_bot->GetCombatDistance(pTarget, true);
+
+    if (DEFENSIVE_STANCE && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK))
+    {
+        if (!m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DEFENSIVE_STANCE))
+            return RETURN_CONTINUE;
+        else if (TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(TAUNT, *pTarget))
+            return RETURN_FINISHED_FIRST_MOVES;
+    }
+
+    if (BERSERKER_STANCE)
+    {
+        if (!m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKER_STANCE))
+            return RETURN_CONTINUE;
+        if (BLOODRAGE > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->GetRageAmount() <= 10)
+            return m_ai->CastSpell(BLOODRAGE) ? RETURN_FINISHED_FIRST_MOVES : RETURN_NO_ACTION_ERROR;
+        if (INTERCEPT > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
+        {
+            if (fTargetDist < 8.0f)
+                return RETURN_NO_ACTION_OK;
+            else if (fTargetDist > 25.0f)
+                return RETURN_CONTINUE; // wait to come into range
+            else if (INTERCEPT > 0 && m_ai->CastSpell(INTERCEPT, *pTarget))
+            {
+                float x, y, z;
+                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+                m_bot->Relocate(x, y, z);
+                return RETURN_FINISHED_FIRST_MOVES;
+            }
+        }
+    }
+
+    if (BATTLE_STANCE)
+    {
+        if (!m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_STANCE))
+            return RETURN_CONTINUE;
+        if (CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
+        {
+            if (fTargetDist < 8.0f)
+                return RETURN_NO_ACTION_OK;
+            if (fTargetDist > 25.0f)
+                return RETURN_CONTINUE; // wait to come into range
+            else if (CHARGE > 0 && m_ai->CastSpell(CHARGE, *pTarget))
+            {
+                float x, y, z;
+                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+                m_bot->Relocate(x, y, z);
+                return RETURN_FINISHED_FIRST_MOVES;
+            }
+        }
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+// TODO: blatant copy of PVE for now, please PVP-port it
+CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuverPVP(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    float fTargetDist = m_bot->GetCombatDistance(pTarget, true);
+
+    if (DEFENSIVE_STANCE && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK))
+    {
+        if (!m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DEFENSIVE_STANCE))
+            return RETURN_CONTINUE;
+        else if (TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(TAUNT, *pTarget))
+            return RETURN_FINISHED_FIRST_MOVES;
+    }
+
+    if (BERSERKER_STANCE)
+    {
+        if (!m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKER_STANCE))
+            return RETURN_CONTINUE;
+        if (BLOODRAGE > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->GetRageAmount() <= 10)
+            return m_ai->CastSpell(BLOODRAGE) ? RETURN_FINISHED_FIRST_MOVES : RETURN_NO_ACTION_ERROR;
+        if (INTERCEPT > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
+        {
+            if (fTargetDist < 8.0f)
+                return RETURN_NO_ACTION_OK;
+            else if (fTargetDist > 25.0f)
+                return RETURN_CONTINUE; // wait to come into range
+            else if (INTERCEPT > 0 && m_ai->CastSpell(INTERCEPT, *pTarget))
+            {
+                float x, y, z;
+                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+                m_bot->Relocate(x, y, z);
+                return RETURN_FINISHED_FIRST_MOVES;
+            }
+        }
+    }
+
+    if (BATTLE_STANCE)
+    {
+        if (!m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_STANCE))
+            return RETURN_CONTINUE;
+        if (CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
+        {
+            if (fTargetDist < 8.0f)
+                return RETURN_NO_ACTION_OK;
+            if (fTargetDist > 25.0f)
+                return RETURN_CONTINUE; // wait to come into range
+            else if (CHARGE > 0 && m_ai->CastSpell(CHARGE, *pTarget))
+            {
+                float x, y, z;
+                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+                m_bot->Relocate(x, y, z);
+                return RETURN_FINISHED_FIRST_MOVES;
+            }
+        }
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    // Face enemy, make sure bot is attacking
+    if (!m_bot->HasInArc(M_PI_F, pTarget))
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+
+    switch (m_ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_PVP_DUEL:
+        case PlayerbotAI::SCENARIO_PVP_BG:
+        case PlayerbotAI::SCENARIO_PVP_ARENA:
+        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
+            return DoNextCombatManeuverPVP(pTarget);
+        case PlayerbotAI::SCENARIO_PVE:
+        case PlayerbotAI::SCENARIO_PVE_ELITE:
+        case PlayerbotAI::SCENARIO_PVE_RAID:
+        default:
+            return DoNextCombatManeuverPVE(pTarget);
+            break;
+    }
+
+    return RETURN_NO_ACTION_ERROR;
+}
+
+CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuverPVE(Unit *pTarget)
+{
+    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
+    if (!m_bot) return RETURN_NO_ACTION_ERROR;
+
+    //Unit* pVictim = pTarget->getVictim();
+    //float fTargetDist = m_bot->GetCombatDistance(pTarget, true);
+    uint32 spec = m_bot->GetSpec();
+
+    //Used to determine if this bot is highest on threat
+    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+
+    // do shouts, berserker rage, etc...
+    if (BERSERKER_RAGE > 0 && !m_bot->HasAura(BERSERKER_RAGE, EFFECT_INDEX_0))
+        m_ai->CastSpell(BERSERKER_RAGE);
+    else if (BLOODRAGE > 0 && m_ai->GetRageAmount() <= 10)
+        m_ai->CastSpell(BLOODRAGE);
+
+    Creature * pCreature = (Creature*) pTarget;
+
+    // Prevent low health humanoid from fleeing with Hamstring
+    if (pCreature && (m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) || m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0)) && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
+    {
+        if (HAMSTRING > 0 && !pTarget->HasAura(HAMSTRING, EFFECT_INDEX_0) && m_ai->CastSpell(HAMSTRING, *pTarget))
+            return RETURN_CONTINUE;
+    }
+
+    CheckShouts();
+
+    switch (spec)
+    {
+        case WARRIOR_SPEC_ARMS:
+            // Execute doesn't scale too well with extra rage and uses up *all* rage preventing use of other skills
+            if (EXECUTE > 0 && pTarget->GetHealthPercent() < 20 && m_ai->CastSpell (EXECUTE, *pTarget))
+                return RETURN_CONTINUE;
+            if (REND > 0 && !pTarget->HasAura(REND, EFFECT_INDEX_0) && m_ai->CastSpell(REND, *pTarget))
+                return RETURN_CONTINUE;
+            if (MORTAL_STRIKE > 0 && !m_bot->HasSpellCooldown(MORTAL_STRIKE) && m_ai->CastSpell(MORTAL_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+            // No way to tell if overpower is active (yet), however taste for blood works
+            if (OVERPOWER > 0 && m_ai->CastSpell(OVERPOWER, *pTarget))
+                return RETURN_CONTINUE;
+            if (THUNDER_CLAP > 0 && !pTarget->HasAura(THUNDER_CLAP) && m_ai->CastSpell(THUNDER_CLAP, *pTarget))
+                return RETURN_CONTINUE;
+            if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+            if (SLAM > 0 && m_ai->CastSpell(SLAM, *pTarget))
+            {
+                m_ai->SetIgnoreUpdateTime(1.5); // TODO: SetIgnoreUpdateTime takes a uint8 - how will 1.5 work as a value?
+                return RETURN_CONTINUE;
+            }
+
+        case WARRIOR_SPEC_FURY:
+            if (EXECUTE > 0 && pTarget->GetHealthPercent() < 20 && m_ai->CastSpell (EXECUTE, *pTarget))
+                return RETURN_CONTINUE;
+            if (BLOODTHIRST > 0 && !m_bot->HasSpellCooldown(BLOODTHIRST) && m_ai->CastSpell(BLOODTHIRST, *pTarget))
+                return RETURN_CONTINUE;
+            if (WHIRLWIND > 0 && !m_bot->HasSpellCooldown(WHIRLWIND) && m_ai->CastSpell(WHIRLWIND, *pTarget))
+                return RETURN_CONTINUE;
+            if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+
+        case WARRIOR_SPEC_PROTECTION:
+            // First check: is bot's target targeting bot?
+            if (!newTarget)
+            {
+                // Cast taunt on bot current target if the mob is targeting someone else
+                if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK && TAUNT > 0 && !m_bot->HasSpellCooldown(TAUNT) && m_ai->CastSpell(TAUNT, *pTarget))
+                    return RETURN_CONTINUE;
+            }
+
+            // If tank is on the verge of dying but "I DON'T WANT TO DIE !!! :'-(("
+            // TODO: should behaviour (or treshold) be different between elite and normal mobs? We don't want bots to burn such precious cooldown needlessly
+            if (m_bot->GetHealthPercent() < 10)
+            {
+                // Cast Last Stand first because it has lower cooldown
+                if (LAST_STAND > 0 && !m_bot->HasAura(LAST_STAND, EFFECT_INDEX_0) && m_ai->CastSpell(LAST_STAND, *m_bot))
+                {
+                    m_ai->TellMaster("I'm using LAST STAND");
+                    return RETURN_CONTINUE;
+                }
+                // Cast Shield Wall only if Last Stand is on cooldown and not active
+                if (SHIELD_WALL > 0 && (m_bot->HasSpellCooldown(LAST_STAND) || LAST_STAND == 0) && !m_bot->HasAura(LAST_STAND, EFFECT_INDEX_0) && !m_bot->HasAura(SHIELD_WALL, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_WALL, *m_bot))
+                {
+                    m_ai->TellMaster("I'm using SHIELD WALL");
+                    return RETURN_CONTINUE;
+                }
+            }
+
+            if (REVENGE > 0 && !m_bot->HasSpellCooldown(REVENGE))
+            {
+                uint8 base = pTarget->RollMeleeOutcomeAgainst(m_bot, BASE_ATTACK);
+                uint8 off = pTarget->RollMeleeOutcomeAgainst(m_bot, OFF_ATTACK);
+                if (base == MELEE_HIT_PARRY || base == MELEE_HIT_DODGE || base == MELEE_HIT_BLOCK || off == MELEE_HIT_PARRY || off == MELEE_HIT_DODGE || off == MELEE_HIT_BLOCK)
+                    if (m_ai->CastSpell(REVENGE, *pTarget))
+                        return RETURN_CONTINUE;
+            }
+            if (REND > 0 && !pTarget->HasAura(REND, EFFECT_INDEX_0) && m_ai->CastSpell(REND, *pTarget))
+                return RETURN_CONTINUE;
+            //Do not waste rage applying Sunder Armor if it is already stacked 5 times
+            if (SUNDER_ARMOR > 0)
+            {
+                if (!pTarget->HasAura(SUNDER_ARMOR) && m_ai->CastSpell(SUNDER_ARMOR, *pTarget))   // no stacks: cast it
+                    return RETURN_CONTINUE;
+                else
+                {
+                    SpellAuraHolder* holder = pTarget->GetSpellAuraHolder(SUNDER_ARMOR);
+                    if (holder && (holder->GetStackAmount() < 5) && m_ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                        return RETURN_CONTINUE;
+                }
+            }
+            if (DEMORALIZING_SHOUT > 0 && !pTarget->HasAura(DEMORALIZING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(DEMORALIZING_SHOUT, *pTarget))
+                return RETURN_CONTINUE;
+            // TODO: only cast disarm if target has equipment?
+            if (DISARM > 0 && !pTarget->HasAura(DISARM, EFFECT_INDEX_0) && m_ai->CastSpell(DISARM, *pTarget))
+                return RETURN_CONTINUE;
+            // check that target is dangerous (elite) before casting shield block: preserve bot cooldowns
+            if (SHIELD_BLOCK > 0 && m_ai->IsElite(pTarget) && !m_bot->HasAura(SHIELD_BLOCK, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_BLOCK, *m_bot))
+                return RETURN_CONTINUE;
+            if (CONCUSSION_BLOW > 0 && !m_bot->HasSpellCooldown(CONCUSSION_BLOW) && m_ai->CastSpell(CONCUSSION_BLOW, *pTarget))
+                return RETURN_CONTINUE;
+            if (SHIELD_SLAM > 0 && !m_bot->HasSpellCooldown(SHIELD_SLAM) && m_ai->CastSpell(SHIELD_SLAM, *pTarget))
+                return RETURN_CONTINUE;
+            if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                return RETURN_CONTINUE;
+
+        /*case WarriorSpellPreventing:
+            if (SHIELD_BASH > 0 && m_ai->CastSpell(SHIELD_BASH, *pTarget))
+                return RETURN_CONTINUE;
+            if (PUMMEL > 0 && m_ai->CastSpell(PUMMEL, *pTarget))
+                return RETURN_CONTINUE;
+            break;
+
+        case WarriorBattle:
+            if (DEATH_WISH > 0 && !m_bot->HasAura(DEATH_WISH, EFFECT_INDEX_0) && m_ai->CastSpell(DEATH_WISH, *m_bot))
+                return RETURN_CONTINUE;
+            if (RETALIATION > 0 && pVictim == m_bot && m_ai->GetAttackerCount() >= 2 && !m_bot->HasAura(RETALIATION, EFFECT_INDEX_0) && m_ai->CastSpell(RETALIATION, *m_bot))
+                return RETURN_CONTINUE;
+            if (SWEEPING_STRIKES > 0 && m_ai->GetAttackerCount() >= 2 && !m_bot->HasAura(SWEEPING_STRIKES, EFFECT_INDEX_0) && m_ai->CastSpell(SWEEPING_STRIKES, *m_bot))
+                return RETURN_CONTINUE;
+            if (INTIMIDATING_SHOUT > 0 && m_ai->GetAttackerCount() > 5 && m_ai->CastSpell(INTIMIDATING_SHOUT, *pTarget))
+                return RETURN_CONTINUE;
+            if (CHALLENGING_SHOUT > 0 && pVictim != m_bot && m_ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura(CHALLENGING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(CHALLENGING_SHOUT, *pTarget))
+                return RETURN_CONTINUE;
+            if (CLEAVE > 0 && m_ai->CastSpell(CLEAVE, *pTarget))
+                return RETURN_CONTINUE;
+            if (PIERCING_HOWL > 0 && && m_ai->GetAttackerCount() >= 3 && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura(PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura(SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura(CONCUSSION_BLOW, EFFECT_INDEX_0) && m_ai->CastSpell(PIERCING_HOWL, *pTarget))
+                return RETURN_CONTINUE;
+            if (MOCKING_BLOW > 0 && pVictim != m_bot && m_ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura(CHALLENGING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(MOCKING_BLOW, *pTarget))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura(PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura(CONCUSSION_BLOW, EFFECT_INDEX_0) && m_ai->CastSpell(WAR_STOMP, *pTarget))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_HUMAN && m_bot->hasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && m_ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_UNDEAD && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && m_ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && m_ai->CastSpell(STONEFORM, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_GNOME && m_bot->hasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && m_ai->CastSpell(ESCAPE_ARTIST, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && m_ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0) && m_ai->CastSpell(BLOOD_FURY, *m_bot))
+                return RETURN_CONTINUE;
+            if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKING, *m_bot))
+                return RETURN_CONTINUE;
+            break;*/
+    }
+
+    return RETURN_NO_ACTION_OK;
+}
+
+CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuverPVP(Unit* pTarget)
+{
+    if (m_ai->CastSpell(HEROIC_STRIKE))
+        return RETURN_CONTINUE;
+
+    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
+}
+
+//Buff and rebuff shouts
+void PlayerbotWarriorAI::CheckShouts()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    if (!m_bot->HasAura(BATTLE_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_SHOUT))
+        return;
+}
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    if (!m_ai)  return;
+    if (!m_bot) return;
+
+    uint32 spec = m_bot->GetSpec();
+
+    //Stance Check
+    if (spec == WARRIOR_SPEC_ARMS && !m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
+        m_ai->CastSpell(BATTLE_STANCE);
+    else if (spec == WARRIOR_SPEC_FURY && !m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
+        m_ai->CastSpell(BERSERKER_STANCE);
+    else if (spec == WARRIOR_SPEC_PROTECTION && !m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0))
+        m_ai->CastSpell(DEFENSIVE_STANCE);
+
+    // hp check
+    if (EatDrinkBandage(false))
+        return;
+} // end DoNonCombatActions
+
+// Match up with "Pull()" below
+bool PlayerbotWarriorAI::CanPull()
+{
+    if (!m_bot) return false;
+    if (!m_ai) return false;
+
+    if (m_bot->GetUInt32Value(PLAYER_AMMO_ID)) // Having ammo equipped means a weapon is equipped as well. Probably. [TODO: does this work with throwing knives? Can a playerbot 'cheat' ammo into the slot without a proper weapon?]
+    {
+        // Can't do this, CanPull CANNOT check for anything that requires a target
+        //if (!m_ai->IsInRange(m_ai->GetCurrentTarget(), AUTO_SHOT))
+        //{
+        //    m_ai->TellMaster("I'm out of range.");
+        //    return false;
+        //}
+        return true;
+    }
+
+    return false;
+}
+
+// Match up with "CanPull()" above
+bool PlayerbotWarriorAI::Pull()
+{
+    if (!m_bot) return false;
+    if (!m_ai)  return false;
+
+    // In Classic, Warriors had 3 differents spells for shooting with range weapons
+    // So we need to determine which one to use
+    // First step: look for the item equiped in range slot
+    Item* pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+    if (!pItem)
+    {
+        m_ai->TellMaster("I don't have ranged weapon equiped.");
+        return false;
+    }
+
+    ItemPrototype const* pProto = pItem->GetProto();
+    if (pProto && pProto->Class == ITEM_CLASS_WEAPON)
+    {
+        switch (pProto->SubClass)
+        {
+            case ITEM_SUBCLASS_WEAPON_BOW:
+                SHOOT = SHOOT_BOW;
+                break;
+            case ITEM_SUBCLASS_WEAPON_GUN:
+                SHOOT = SHOOT_GUN;
+                break;
+            case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                SHOOT = SHOOT_XBOW;
+                break;
+            default:
+                m_ai->TellMaster("Can't pull: equiped range item is neither a gun, bow or crossbow.");
+                return false;
+        }
+    }
+    else
+        return false;
+
+    if (m_bot->GetCombatDistance(m_ai->GetCurrentTarget(), true) > ATTACK_DISTANCE)
+    {
+        if (!m_ai->In_Reach(m_ai->GetCurrentTarget(), SHOOT))
+        {
+            m_ai->TellMaster("I'm out of range.");
+            return false;
+        }
+
+        // shoot at the target
+//        if (m_ai->CastSpell(SHOOT, m_ai->GetCurrentTarget()))
+        m_bot->CastSpell(m_ai->GetCurrentTarget(), SHOOT, true);
+        m_ai->TellMaster("I'm PULLING %s.", m_ai->GetCurrentTarget()->GetName());
+        return true;
+    }
+    else // target is in melee range
+    {
+        m_ai->Attack(m_ai->GetCurrentTarget());
+        return true;
+    }
+
+    return false;
+}
diff -ruN mangos-classic/src/game/playerbot/PlayerbotWarriorAI.h portalclassic/src/game/playerbot/PlayerbotWarriorAI.h
--- mangos-classic/src/game/playerbot/PlayerbotWarriorAI.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/PlayerbotWarriorAI.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,155 @@
+#ifndef _PlayerbotWarriorAI_H
+#define _PlayerbotWarriorAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    WarriorSpellPreventing,
+    WarriorBattle,
+    WarriorDefensive,
+    WarriorBerserker
+};
+
+enum WarriorSpells
+{
+    BATTLE_SHOUT_1                  = 6673,
+    BATTLE_STANCE_1                 = 2457,
+    BERSERKER_RAGE_1                = 18499,
+    BERSERKER_STANCE_1              = 2458,
+    BLOODRAGE_1                     = 2687,
+    BLOODTHIRST_1                   = 23881,
+    CHALLENGING_SHOUT_1             = 1161,
+    CHARGE_1                        = 100,
+    CLEAVE_1                        = 845,
+    CONCUSSION_BLOW_1               = 12809,
+    DEATH_WISH_1                    = 12292,
+    DEFENSIVE_STANCE_1              = 71,
+    DEMORALIZING_SHOUT_1            = 1160,
+    DISARM_1                        = 676,
+    EXECUTE_1                       = 5308,
+    HAMSTRING_1                     = 1715,
+    HEROIC_STRIKE_1                 = 78,
+    INTERCEPT_1                     = 20252,
+    INTERVENE_1                     = 3411,
+    INTIMIDATING_SHOUT_1            = 5246,
+    LAST_STAND_1                    = 12975,
+    MOCKING_BLOW_1                  = 694,
+    MORTAL_STRIKE_1                 = 12294,
+    OVERPOWER_1                     = 7384,
+    PIERCING_HOWL_1                 = 12323,
+    PUMMEL_1                        = 6552,
+    RECKLESSNESS_1                  = 1719,
+    REND_1                          = 772,
+    RETALIATION_1                   = 20230,
+    REVENGE_1                       = 6572,
+    SHIELD_BASH_1                   = 72,
+    SHIELD_BLOCK_1                  = 2565,
+    SHIELD_SLAM_1                   = 23922,
+    SHIELD_WALL_1                   = 871,
+    SHOOT_BOW_1                     = 2480,
+    SHOOT_GUN_1                     = 7918,
+    SHOOT_XBOW_1                    = 7919,
+    SLAM_1                          = 1464,
+    SUNDER_ARMOR_1                  = 7386,
+    SWEEPING_STRIKES_1              = 12328,
+    TAUNT_1                         = 355,
+    THUNDER_CLAP_1                  = 6343,
+    WHIRLWIND_1                     = 1680
+
+    //Procs
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotWarriorAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarriorAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarriorAI();
+
+    // all combat actions go here
+    CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
+    bool Pull();
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //Buff/rebuff shouts
+    void CheckShouts();
+
+    // Utility Functions
+    bool CanPull();
+
+private:
+    CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
+    CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
+    CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
+
+    // ARMS
+    uint32 BATTLE_STANCE,
+        CHARGE,
+        HEROIC_STRIKE,
+        REND,
+        THUNDER_CLAP,
+        HAMSTRING,
+        MOCKING_BLOW,
+        RETALIATION,
+        SWEEPING_STRIKES,
+        MORTAL_STRIKE;
+
+    // PROTECTION
+    uint32 DEFENSIVE_STANCE,
+        BLOODRAGE,
+        SUNDER_ARMOR,
+        TAUNT,
+        SHIELD_BASH,
+        REVENGE,
+        SHIELD_BLOCK,
+        DISARM,
+        SHIELD_WALL,
+        SHIELD_SLAM,
+        CONCUSSION_BLOW,
+        LAST_STAND;
+
+    // FURY
+    uint32 BERSERKER_STANCE,
+        BATTLE_SHOUT,
+        DEMORALIZING_SHOUT,
+        OVERPOWER,
+        CLEAVE,
+        INTIMIDATING_SHOUT,
+        EXECUTE,
+        CHALLENGING_SHOUT,
+        SLAM,
+        INTERCEPT,
+        DEATH_WISH,
+        BERSERKER_RAGE,
+        WHIRLWIND,
+        PUMMEL,
+        BLOODTHIRST,
+        RECKLESSNESS,
+        PIERCING_HOWL;
+
+    // racial
+    uint32 STONEFORM,
+        ESCAPE_ARTIST,
+        PERCEPTION,
+        SHADOWMELD,
+        BLOOD_FURY,
+        WAR_STOMP,
+        BERSERKING,
+        WILL_OF_THE_FORSAKEN;
+
+    // general
+    uint32 SHOOT,
+        SHOOT_BOW,
+        SHOOT_GUN,
+        SHOOT_XBOW;
+
+    uint32 SpellSequence;
+};
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/config.h portalclassic/src/game/playerbot/config.h
--- mangos-classic/src/game/playerbot/config.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/config.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PB_CONFIG_H
+#define PB_CONFIG_H
+
+#include "Platform/CompilerDefs.h"
+
+// Format is YYYYMMDDRR where RR is the change in the conf file
+// for that day.
+#define PLAYERBOT_CONF_VERSION    2011031001
+
+#if PLATFORM == PLATFORM_WINDOWS
+  #define _PLAYERBOT_CONFIG  "playerbot.conf"
+#else
+  #define _PLAYERBOT_CONFIG  SYSCONFDIR "playerbot.conf"
+#endif
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/config.h.in portalclassic/src/game/playerbot/config.h.in
--- mangos-classic/src/game/playerbot/config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/config.h.in	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PB_CONFIG_H
+#define PB_CONFIG_H
+
+#include "Platform/CompilerDefs.h"
+
+// Format is YYYYMMDDRR where RR is the change in the conf file
+// for that day.
+#define PLAYERBOT_CONF_VERSION    2011031001
+
+#if PLATFORM == PLATFORM_WINDOWS
+  #define _PLAYERBOT_CONFIG  "playerbot.conf"
+#else
+  #define _PLAYERBOT_CONFIG  SYSCONFDIR"playerbot.conf"
+#endif
+
+#endif
diff -ruN mangos-classic/src/game/playerbot/playerbot.conf.dist.in portalclassic/src/game/playerbot/playerbot.conf.dist.in
--- mangos-classic/src/game/playerbot/playerbot.conf.dist.in	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/playerbot.conf.dist.in	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1,76 @@
+#####################################
+# Playerbot Configuration file      #
+#####################################
+
+[PlayerbotConf]
+ConfVersion=2011031001
+
+###################################################################################################################
+# PLAYERBOTAI CONFIGURATION
+#
+#    PlayerbotAI.DisableBots
+#        Disable the bot command and bot menu
+#        Default: 0 - off
+#                 1 - on
+#
+#    PlayerbotAI.DebugWhisper
+#        Enable debug output by whispering master
+#        Default: 0 - off
+#                 1 - on
+#
+#    PlayerbotAI.FollowDistanceMin
+#    PlayerbotAI.FollowDistanceMax
+#        Min. and Max. follow distance for bots
+#        Default: 0.5 / 1.0
+#
+#    PlayerbotAI.MaxNumBots
+#        Limits the number of bots per account (Max 9)
+#        Default: 9
+#
+#    PlayerbotAI.RestrictBotLevel
+#        Restrict the allowed bot level (Current Max 60)
+#        Default: 60
+#
+#    PlayerbotAI.BotguyQuests
+#        List of Quest ids, any of which, once completed will enable botguy menu on NPCs
+#        List must be enclosed in double quotes ("") and multiple Quest Ids separated by a delimiter(,)
+#        Example: "805,383,2160,54,8350,9313,1656,2159"
+#        Default: "" no quest restriction, memu always displayed by NPCs
+#
+#    PlayerbotAI.BotguyCost
+#        Cost (Copper coins) levied on summoning a bot
+#        If player has the cost, botguy menu will be displayed by NPCs
+#        Default: 0 - no cost, menu always displayed by NPCs
+#
+#    PlayerbotAI.Collect.Combat
+#    PlayerbotAI.Collect.Quest
+#    PlayerbotAI.Collect.Profession
+#    PlayerbotAI.Collect.Loot
+#    PlayerbotAI.Collect.Skin
+#    PlayerbotAI.Collect.Objects
+#        Enable collection options for after combat, quest items, profession, all loot, skin, or nearby objects
+#                 0 - off
+#        Default: 1 - on
+#
+#    PlayerbotAI.SellGarbage
+#        Allow bots to automatically sell all [GRAY|POOR] quality items as the player activates vendor
+#        Default: 0 - off
+#                 1 - on
+#
+###################################################################################################################
+
+PlayerbotAI.DisableBots = 0
+PlayerbotAI.DebugWhisper = 0
+PlayerbotAI.FollowDistanceMin = 0.5
+PlayerbotAI.FollowDistanceMax = 1.0
+PlayerbotAI.MaxNumBots = 9
+PlayerbotAI.RestrictBotLevel = 60
+PlayerbotAI.BotguyQuests = ""
+PlayerbotAI.BotguyCost = 0
+PlayerbotAI.Collect.Combat = 1
+PlayerbotAI.Collect.Quest = 1
+PlayerbotAI.Collect.Profession = 1
+PlayerbotAI.Collect.Loot = 1
+PlayerbotAI.Collect.Skin = 1
+PlayerbotAI.Collect.Objects = 1
+PlayerbotAI.SellGarbage = 0
diff -ruN mangos-classic/src/game/playerbot/revision_sql.h portalclassic/src/game/playerbot/revision_sql.h
--- mangos-classic/src/game/playerbot/revision_sql.h	1970-01-01 01:00:00.000000000 +0100
+++ portalclassic/src/game/playerbot/revision_sql.h	2016-06-20 09:28:57.000000000 +0200
@@ -0,0 +1 @@
+#define REVISION_DB_PLAYERBOTAI "playerbotai_characters_svdata_003"
diff -ruN mangos-classic/src/mangosd/Master.cpp portalclassic/src/mangosd/Master.cpp
--- mangos-classic/src/mangosd/Master.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/mangosd/Master.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -36,6 +36,7 @@
 #include "RASocket.h"
 #include "Util.h"
 #include "revision_sql.h"
+#include "playerbot/revision_sql.h"
 #include "MaNGOSsoap.h"
 #include "MassMailMgr.h"
 #include "DBCStores.h"
diff -ruN mangos-classic/src/shared/Database/Database.cpp portalclassic/src/shared/Database/Database.cpp
--- mangos-classic/src/shared/Database/Database.cpp	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/src/shared/Database/Database.cpp	2016-06-20 09:28:57.000000000 +0200
@@ -497,8 +497,16 @@
             sLog.outErrorDb("  [B] You need: --> `%s.sql`", req_sql_update_name);
             sLog.outErrorDb();
             sLog.outErrorDb("You must apply all updates after [A] to [B] to use mangos with this database.");
-            sLog.outErrorDb("These updates are included in the sql/updates folder.");
-            sLog.outErrorDb("Please read the included [README] in sql/updates for instructions on updating.");
+            if (reqName.find("playerbotai") != std::string::npos)
+            {
+                sLog.outErrorDb("These updates are included in the [sql/playerbotai] folder.");
+                sLog.outErrorDb("Please read the [doc/README.Playerbot] file for instructions on updating.");
+            }
+            else
+            {
+                sLog.outErrorDb("These updates are included in the sql/updates folder.");
+                sLog.outErrorDb("Please read the included [README] in sql/updates for instructions on updating.");
+            }
         }
         else
         {
Binary files mangos-classic/win/.DS_Store and portalclassic/win/.DS_Store differ
diff -ruN mangos-classic/win/VC120/game.vcxproj portalclassic/win/VC120/game.vcxproj
--- mangos-classic/win/VC120/game.vcxproj	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/win/VC120/game.vcxproj	2016-06-20 09:28:57.000000000 +0200
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug_NoPCH|Win32">
@@ -439,6 +439,18 @@
     <ClCompile Include="..\..\src\game\PetHandler.cpp" />
     <ClCompile Include="..\..\src\game\PetitionsHandler.cpp" />
     <ClCompile Include="..\..\src\game\Player.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotClassAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotDruidAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotHunterAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMageAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMgr.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPaladinAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPriestAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotRogueAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotShamanAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarlockAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarriorAI.cpp" />
     <ClCompile Include="..\..\src\game\PlayerDump.cpp" />
     <ClCompile Include="..\..\src\game\PointMovementGenerator.cpp" />
     <ClCompile Include="..\..\src\game\PoolManager.cpp" />
@@ -585,6 +597,18 @@
     <ClInclude Include="..\..\src\game\Pet.h" />
     <ClInclude Include="..\..\src\game\PetAI.h" />
     <ClInclude Include="..\..\src\game\Player.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotClassAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotDruidAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotHunterAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMageAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMgr.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPaladinAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPriestAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotRogueAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotShamanAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarlockAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarriorAI.h" />
     <ClInclude Include="..\..\src\game\PlayerDump.h" />
     <ClInclude Include="..\..\src\game\PointMovementGenerator.h" />
     <ClInclude Include="..\..\src\game\PoolManager.h" />
@@ -650,4 +674,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN mangos-classic/win/VC120/game.vcxproj.filters portalclassic/win/VC120/game.vcxproj.filters
--- mangos-classic/win/VC120/game.vcxproj.filters	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/win/VC120/game.vcxproj.filters	2016-06-20 09:28:57.000000000 +0200
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
     <Filter Include="World/Handlers">
@@ -409,6 +409,42 @@
     <ClCompile Include="..\..\src\game\UnitAuraProcHandler.cpp">
       <Filter>World/Handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotClassAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotDruidAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotHunterAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMageAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMgr.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPaladinAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPriestAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotRogueAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotShamanAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarlockAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarriorAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\game\AuctionHouseBot\AuctionHouseBot.cpp">
       <Filter>AhBot</Filter>
     </ClCompile>
@@ -817,6 +853,42 @@
     <ClInclude Include="..\..\src\game\Camera.h">
       <Filter>Object</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotClassAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotDruidAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotHunterAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMageAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMgr.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPaladinAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPriestAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotRogueAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotShamanAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarlockAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarriorAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\src\game\MoveMap.h">
       <Filter>World/Handlers</Filter>
     </ClInclude>
diff -ruN mangos-classic/win/VC140/game.vcxproj portalclassic/win/VC140/game.vcxproj
--- mangos-classic/win/VC140/game.vcxproj	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/win/VC140/game.vcxproj	2016-06-20 09:28:57.000000000 +0200
@@ -439,6 +439,18 @@
     <ClCompile Include="..\..\src\game\PetHandler.cpp" />
     <ClCompile Include="..\..\src\game\PetitionsHandler.cpp" />
     <ClCompile Include="..\..\src\game\Player.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotClassAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotDruidAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotHunterAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMageAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMgr.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPaladinAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPriestAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotRogueAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotShamanAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarlockAI.cpp" />
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarriorAI.cpp" />
     <ClCompile Include="..\..\src\game\PlayerDump.cpp" />
     <ClCompile Include="..\..\src\game\PointMovementGenerator.cpp" />
     <ClCompile Include="..\..\src\game\PoolManager.cpp" />
@@ -585,6 +597,18 @@
     <ClInclude Include="..\..\src\game\Pet.h" />
     <ClInclude Include="..\..\src\game\PetAI.h" />
     <ClInclude Include="..\..\src\game\Player.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotClassAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotDruidAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotHunterAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMageAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMgr.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPaladinAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPriestAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotRogueAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotShamanAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarlockAI.h" />
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarriorAI.h" />
     <ClInclude Include="..\..\src\game\PlayerDump.h" />
     <ClInclude Include="..\..\src\game\PointMovementGenerator.h" />
     <ClInclude Include="..\..\src\game\PoolManager.h" />
diff -ruN mangos-classic/win/VC140/game.vcxproj.filters portalclassic/win/VC140/game.vcxproj.filters
--- mangos-classic/win/VC140/game.vcxproj.filters	2016-06-20 09:29:07.000000000 +0200
+++ portalclassic/win/VC140/game.vcxproj.filters	2016-06-20 09:28:57.000000000 +0200
@@ -406,6 +406,42 @@
     <ClCompile Include="..\..\src\game\UnitAuraProcHandler.cpp">
       <Filter>World/Handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotClassAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotDruidAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotHunterAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMageAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotMgr.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPaladinAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotPriestAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotRogueAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotShamanAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarlockAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\playerbot\PlayerbotWarriorAI.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\game\AuctionHouseBot\AuctionHouseBot.cpp">
       <Filter>AhBot</Filter>
     </ClCompile>
@@ -814,6 +850,42 @@
     <ClInclude Include="..\..\src\game\Camera.h">
       <Filter>Object</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotClassAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotDruidAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotHunterAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMageAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotMgr.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPaladinAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotPriestAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotRogueAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotShamanAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarlockAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\playerbot\PlayerbotWarriorAI.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\src\game\MoveMap.h">
       <Filter>World/Handlers</Filter>
     </ClInclude>
@@ -911,4 +983,4 @@
       <Filter>World/Handlers</Filter>
     </ClInclude>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
